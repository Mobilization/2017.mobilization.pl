// Generated by CoffeeScript 1.9.1
(function() {
  var TaskGroup, base, extractOptsAndCallback, isWindows, ref, ref1, safefs, safeps, typeChecker,
    slice = [].slice;

  safeps = null;

  TaskGroup = require('taskgroup').TaskGroup;

  typeChecker = require('typechecker');

  safefs = require('safefs');

  extractOptsAndCallback = require('extract-opts');

  isWindows = (typeof process !== "undefined" && process !== null ? (ref = process.platform) != null ? ref.indexOf('win') : void 0 : void 0) === 0;

  if (global.safepsGlobal == null) {
    global.safepsGlobal = {};
  }

  if ((base = global.safepsGlobal).pool == null) {
    base.pool = new TaskGroup().setConfig({
      concurrency: (ref1 = process.env.NODE_MAX_OPEN_PROCESSES) != null ? ref1 : 100,
      pauseOnError: false
    }).run();
  }

  safeps = {
    openProcess: function(fn) {
      global.safepsGlobal.pool.addTask(fn);
      return safeps;
    },
    requireFresh: function(path) {
      var result;
      path = require('path').resolve(path);
      delete require.cache[path];
      result = require(path);
      delete require.cache[path];
      return result;
    },
    isWindows: function() {
      return isWindows;
    },
    getLocaleCode: function(lang) {
      var localeCode;
      if (lang == null) {
        lang = null;
      }
      if (lang == null) {
        lang = process.env.LANG || '';
      }
      localeCode = lang.replace(/\..+/, '').replace('-', '_').toLowerCase() || null;
      return localeCode;
    },
    getLanguageCode: function(localeCode) {
      var languageCode;
      if (localeCode == null) {
        localeCode = null;
      }
      localeCode = safeps.getLocaleCode(localeCode) || '';
      languageCode = localeCode.replace(/^([a-z]+)[_-]([a-z]+)$/i, '$1').toLowerCase() || null;
      return languageCode;
    },
    getCountryCode: function(localeCode) {
      var countryCode;
      if (localeCode == null) {
        localeCode = null;
      }
      localeCode = safeps.getLocaleCode(localeCode) || '';
      countryCode = localeCode.replace(/^([a-z]+)[_-]([a-z]+)$/i, '$2').toLowerCase() || null;
      return countryCode;
    },
    hasSpawnSync: function() {
      return require('child_process').spawnSync != null;
    },
    hasExecSync: function() {
      return require('child_process').execSync != null;
    },
    isExecutable: function(path, opts, next) {
      var fs, ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.sync) {
        return safeps.isExecutableSync(path, opts, next);
      }
      fs = require('fs');
      if (fs.access) {
        fs.access(path, fs.X_OK, function(err) {
          var executable;
          executable = !err;
          return next(null, executable);
        });
      } else {
        require('child_process').exec(path + ' --version', function(err) {
          var executable;
          executable = !err || (err.code !== 127 && /EACCESS|Permission denied/.test(err.message) === false);
          return next(null, executable);
        });
      }
      return this;
    },
    isExecutableSync: function(path, opts, next) {
      var err, executable, fs;
      fs = require('fs');
      if (fs.accessSync) {
        try {
          fs.accessSync(path, fs.X_OK);
          executable = true;
        } catch (_error) {
          err = _error;
          executable = false;
        }
      } else {
        try {
          require('child_process').execSync(path + ' --version');
          executable = true;
        } catch (_error) {
          err = _error;
          executable = err.code !== 127 && /EACCESS|Permission denied/.test(err.message) === false;
        }
      }
      if (next) {
        next(null, executable);
        return this;
      } else {
        return executable;
      }
    },
    prepareExecutableOptions: function(opts) {
      opts || (opts = {});
      if (opts.safe == null) {
        opts.safe = true;
      }
      if (opts.env == null) {
        opts.env = process.env;
      }
      if (opts.stdin == null) {
        opts.stdin = null;
      }
      if (opts.stdio == null) {
        opts.stdio = null;
      }
      if (opts.stdio) {
        opts.read = opts.output = false;
        opts.outputPrefix = null;
      } else {
        if (opts.read == null) {
          opts.read = true;
        }
        if (opts.output == null) {
          opts.output = !!opts.outputPrefix;
        }
        if (opts.outputPrefix == null) {
          opts.outputPrefix = null;
        }
      }
      if (opts.env === false) {
        delete opts.env;
      }
      return opts;
    },

    /*
    	Internal: Prepare result of an execution
    	result: Object
    		pid Number Pid of the child process
    		output Array Array of results from stdio output
    		stdout Buffer|String The contents of output[1]
    		stderr Buffer|String The contents of output[2]
    		status Number The exit code of the child process
    		signal String The signal used to kill the child process
    		error Error The error object if the child process failed or timed out
     */
    prepareExecutableResult: function(result, opts) {
      var message, tmp;
      if (opts.output) {
        safeps.outputData(result.stdout, 'stdout', opts.outputPrefix);
        safeps.outputData(result.stderr, 'stderr', opts.outputPrefix);
      }
      if (result.error) {
        return result;
      }
      if ((result.status != null) && result.status !== 0) {
        message = "Command exited with a non-zero status code.";
        if (result.stdout) {
          tmp = safeps.prefixData(result.stdout);
          if (tmp) {
            message += "\nThe command's stdout output:\n" + tmp;
          }
        }
        if (result.stderr) {
          tmp = safeps.prefixData(result.stderr);
          if (tmp) {
            message += "\nThe command's stderr output:\n" + tmp;
          }
        }
        result.error = new Error(message);
        return result;
      }
      return result;
    },
    prefixData: function(data, prefix) {
      if (prefix == null) {
        prefix = '>\t';
      }
      data = (data != null ? typeof data.toString === "function" ? data.toString() : void 0 : void 0) || '';
      if (prefix && data) {
        data = prefix + data.trim().replace(/\n/g, '\n' + prefix) + '\n';
      }
      return data;
    },
    outputData: function(data, mode, prefix) {
      if (mode == null) {
        mode = 'stdout';
      }
      if (data.toString().trim().length !== 0) {
        if (prefix) {
          data = safeps.prefixData(data, prefix);
        }
        process[mode].write(data);
      }
      return null;
    },
    spawnSync: function(command, opts, next) {
      var ref2, result, wasSync;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      opts = safeps.prepareExecutableOptions(opts);
      opts.sync = true;
      if (typeChecker.isString(command)) {
        command = command.split(' ');
      }
      if (opts.safe) {
        wasSync = 0;
        safeps.getExecPath(command[0], opts, function(err, execPath) {
          if (err) {
            return;
          }
          command[0] = execPath;
          return wasSync = 1;
        });
        if (wasSync === 0) {
          process.stderr.write('safeps.spawnSync: was unable to get the executable path synchronously');
        }
      }
      result = require('child_process').spawnSync(command[0], command.slice(1), opts);
      result = safeps.prepareExecutableResult(result, opts);
      if (next) {
        return next(result.error, result.stdout, result.stderr, result.status, result.signal);
      } else {
        return result;
      }
    },
    spawn: function(command, opts, next) {
      var ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      opts = safeps.prepareExecutableOptions(opts);
      if (opts.sync) {
        return safeps.spawnSync(command, opts, next);
      }
      safeps.openProcess(function(closeProcess) {
        var exited, result, tasks;
        if (typeChecker.isString(command)) {
          command = command.split(' ');
        }
        result = {};
        exited = false;
        tasks = new TaskGroup().done(function(err) {
          exited = true;
          closeProcess();
          return next(err || result.error, result.stdout, result.stderr, result.status, result.signal);
        });
        if (opts.safe) {
          tasks.addTask(function(complete) {
            return safeps.getExecPath(command[0], opts, function(err, execPath) {
              if (err) {
                return complete(err);
              }
              command[0] = execPath;
              return complete();
            });
          });
        }
        tasks.addTask(function(complete) {
          var ref3, ref4, ref5, ref6;
          result.pid = require('child_process').spawn(command[0], command.slice(1), opts);
          if (opts.stdin) {
            if ((ref3 = result.pid.stdin) != null) {
              ref3.write(opts.stdin);
            }
            if ((ref4 = result.pid.stdin) != null) {
              ref4.end();
            }
          }
          if (opts.read) {
            result.stdout = null;
            result.stderr = null;
            if ((ref5 = result.pid.stdout) != null) {
              ref5.on('data', function(data) {
                if (opts.output) {
                  safeps.outputData(data, 'stdout', opts.outputPrefix);
                }
                if (result.stdout) {
                  return result.stdout = Buffer.concat([result.stdout, data]);
                } else {
                  return result.stdout = data;
                }
              });
            }
            if ((ref6 = result.pid.stderr) != null) {
              ref6.on('data', function(data) {
                if (opts.output) {
                  safeps.outputData(data, 'stderr', opts.outputPrefix);
                }
                if (result.stderr) {
                  return result.stderr = Buffer.concat([result.stderr, data]);
                } else {
                  return result.stderr = data;
                }
              });
            }
          }
          return result.pid.on('close', function(status, signal) {
            result.status = status;
            result.signal = signal;
            if (exited === true) {
              return;
            }
            opts.output = false;
            result = safeps.prepareExecutableResult(result, opts);
            return complete(result.error);
          });
        });
        return tasks.run();
      });
      return this;
    },
    spawnMultiple: function(commands, opts, next) {
      var ref2, results, tasks;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.concurrency == null) {
        opts.concurrency = 1;
      }
      results = [];
      tasks = new TaskGroup().setConfig({
        concurrency: opts.concurrency
      }).done(function(err) {
        return next(err, results);
      });
      if (!typeChecker.isArray(commands)) {
        commands = [commands];
      }
      commands.forEach(function(command) {
        return tasks.addTask(function(complete) {
          return safeps.spawn(command, opts, function() {
            var args, err;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            err = args[0] || null;
            results.push(args);
            return complete(err);
          });
        });
      });
      tasks.run();
      return this;
    },
    spawnCommand: function(command, args, opts, next) {
      var pieces, ref2;
      if (args == null) {
        args = [];
      }
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      pieces = [command].concat(args);
      safeps.spawn(pieces, opts, next);
      return this;
    },
    spawnCommands: function(command, multiArgs, opts, next) {
      var args, i, len, pieces, ref2;
      if (multiArgs == null) {
        multiArgs = [];
      }
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      pieces = [];
      for (i = 0, len = multiArgs.length; i < len; i++) {
        args = multiArgs[i];
        pieces.push([command].concat(args));
      }
      safeps.spawnMultiple(pieces, opts, next);
      return this;
    },
    execSync: function(command, opts) {
      var err, error, next, ref2, result, stdout;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      opts = safeps.prepareExecutableOptions(opts);
      opts.sync = true;
      if (opts.output === true && !opts.outputPrefix) {
        opts.stdio = 'inherit';
        delete opts.output;
      }
      try {
        stdout = require('child_process').execSync(command, opts);
      } catch (_error) {
        err = _error;
        error = err;
      }
      result = safeps.prepareExecutableResult({
        error: error,
        stdout: stdout
      }, opts);
      if (next) {
        return next(result.error, result.stdout, result.stderr);
      } else {
        return result;
      }
    },
    exec: function(command, opts, next) {
      var ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      opts = safeps.prepareExecutableOptions(opts);
      if (opts.sync) {
        return safeps.execSync(command, opts, next);
      }
      safeps.openProcess(function(closeProcess) {
        if (opts.output === true && !opts.outputPrefix) {
          opts.stdio = 'inherit';
          delete opts.output;
        }
        return require('child_process').exec(command, opts, function(error, stdout, stderr) {
          var result;
          closeProcess();
          result = safeps.prepareExecutableResult({
            error: error,
            stdout: stdout,
            stderr: stderr
          }, opts);
          return next(result.error, result.stdout, result.stderr);
        });
      });
      return this;
    },
    execMultiple: function(commands, opts, next) {
      var ref2, results, tasks;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.concurrency == null) {
        opts.concurrency = 1;
      }
      results = [];
      tasks = new TaskGroup().setConfig({
        concurrency: opts.concurrency
      }).done(function(err) {
        return next(err, results);
      });
      if (!typeChecker.isArray(commands)) {
        commands = [commands];
      }
      commands.forEach(function(command) {
        return tasks.addTask(function(complete) {
          return safeps.exec(command, opts, function() {
            var args, err;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            err = args[0] || null;
            results.push(args);
            return complete(err);
          });
        });
      });
      tasks.run();
      return this;
    },
    determineExecPath: function(possibleExecPaths, opts, next) {
      var execPath, pathUtil, ref2, tasks;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.sync == null) {
        opts.sync = false;
      }
      pathUtil = require('path');
      execPath = null;
      tasks = new TaskGroup({
        sync: opts.sync
      }).done(function(err) {
        return next(err, execPath);
      });
      possibleExecPaths.forEach(function(possibleExecPath) {
        if (!possibleExecPath) {
          return;
        }
        return tasks.addTask(function(complete) {
          if (execPath) {
            return complete();
          }
          possibleExecPath = pathUtil.resolve(possibleExecPath);
          return safeps.isExecutable(possibleExecPath, opts, function(err, executable) {
            if (err || !executable) {
              return complete();
            }
            execPath = possibleExecPath;
            return complete();
          });
        });
      });
      tasks.run();
      return this;
    },
    getEnvironmentPaths: function() {
      var environmentPaths, pathUtil;
      pathUtil = require('path');
      environmentPaths = process.env.PATH.split(pathUtil.delimiter);
      return environmentPaths;
    },
    getStandardExecPaths: function(execName) {
      var pathUtil, standardExecPaths;
      pathUtil = require('path');
      standardExecPaths = [process.cwd()].concat(safeps.getEnvironmentPaths());
      if (execName) {
        standardExecPaths = standardExecPaths.map(function(path) {
          return pathUtil.join(path, execName);
        });
      }
      return standardExecPaths;
    },
    getPossibleExecPaths: function(execName) {
      var i, len, possibleExecPaths, standardExecPath, standardExecPaths;
      if (isWindows && execName.indexOf('.') === -1) {
        standardExecPaths = safeps.getStandardExecPaths(execName);
        possibleExecPaths = [];
        for (i = 0, len = standardExecPaths.length; i < len; i++) {
          standardExecPath = standardExecPaths[i];
          possibleExecPaths.push(standardExecPath, standardExecPath + '.exe', standardExecPath + '.cmd', standardExecPath + '.bat');
        }
      } else {
        possibleExecPaths = safeps.getStandardExecPaths(execName);
      }
      return possibleExecPaths;
    },
    execPathCache: {},
    getExecPath: function(execName, opts, next) {
      var execNameCapitalized, getExecMethodName, possibleExecPaths, ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.cache == null) {
        opts.cache = true;
      }
      if (execName.substr(0, 1) === '/' || execName.substr(1, 1) === ':') {
        next(null, execName);
        return this;
      }
      execNameCapitalized = execName[0].toUpperCase() + execName.substr(1);
      getExecMethodName = 'get' + execNameCapitalized + 'Path';
      if (safeps[getExecMethodName] != null) {
        return safeps[getExecMethodName](opts, next);
      } else {
        if (opts.cache && (safeps.execPathCache[execName] != null)) {
          next(null, safeps.execPathCache[execName]);
          return this;
        }
        possibleExecPaths = safeps.getPossibleExecPaths(execName);
        safeps.determineExecPath(possibleExecPaths, opts, function(err, execPath) {
          if (err) {
            return next(err);
          }
          if (!execPath) {
            err = new Error('Could not locate the ' + execName + ' executable path');
            return next(err);
          }
          if (opts.cache) {
            safeps.execPathCache[execName] = execPath;
          }
          return next(null, execPath);
        });
      }
      return this;
    },
    getHomePath: function(opts, next) {
      var homePath, ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.cache == null) {
        opts.cache = true;
      }
      if (opts.cache && (safeps.cachedHomePath != null)) {
        next(null, safeps.cachedHomePath);
        return this;
      }
      homePath = process.env.USERPROFILE || process.env.HOME;
      homePath || (homePath = null);
      if (opts.cache) {
        safeps.cachedHomePath = homePath;
      }
      next(null, homePath);
      return this;
    },
    getTmpPath: function(opts, next) {
      var pathUtil, ref2, tmpDirName, tmpPath;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.cache == null) {
        opts.cache = true;
      }
      if (opts.cache && (safeps.cachedTmpPath != null)) {
        next(null, safeps.cachedTmpPath);
        return this;
      }
      pathUtil = require('path');
      tmpDirName = isWindows ? 'temp' : 'tmp';
      tmpPath = process.env.TMPDIR || process.env.TMP || process.env.TEMP;
      if (!tmpPath) {
        safeps.getHomePath(opts, function(err, homePath) {
          if (err) {
            return next(err);
          }
          tmpPath = pathUtil.resolve(homePath, tmpDirName);
          if (!tmpPath) {
            return tmpPath = isWindows ? pathUtil.resolve(process.env.windir || 'C:\\Windows', tmpDirName) : '/tmp';
          }
        });
      }
      tmpPath || (tmpPath = null);
      if (opts.cache) {
        safeps.cachedTmpPath = tmpPath;
      }
      next(null, tmpPath);
      return this;
    },
    getGitPath: function(opts, next) {
      var execName, possibleExecPaths, ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.cache == null) {
        opts.cache = true;
      }
      if (opts.cache && (safeps.cachedGitPath != null)) {
        next(null, safeps.cachedGitPath);
        return this;
      }
      execName = isWindows ? 'git.exe' : 'git';
      possibleExecPaths = [];
      if (process.env.GIT_PATH) {
        possibleExecPaths.push(process.env.GIT_PATH);
      }
      if (process.env.GITPATH) {
        possibleExecPaths.push(process.env.GITPATH);
      }
      possibleExecPaths = possibleExecPaths.concat(safeps.getStandardExecPaths(execName)).concat(isWindows ? ["/Program Files (x64)/Git/bin/" + execName, "/Program Files (x86)/Git/bin/" + execName, "/Program Files/Git/bin/" + execName] : ["/usr/local/bin/" + execName, "/usr/bin/" + execName, "~/bin/" + execName]);
      safeps.determineExecPath(possibleExecPaths, opts, function(err, execPath) {
        if (opts.cache) {
          safeps.cachedGitPath = execPath;
        }
        if (err) {
          return next(err);
        }
        if (!execPath) {
          err = new Error('Could not locate git binary');
          return next(err);
        }
        return next(null, execPath);
      });
      return this;
    },
    getNodePath: function(opts, next) {
      var execName, possibleExecPaths, ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.cache == null) {
        opts.cache = true;
      }
      if (opts.cache && (safeps.cachedNodePath != null)) {
        next(null, safeps.cachedNodePath);
        return this;
      }
      execName = isWindows ? 'node.exe' : 'node';
      possibleExecPaths = [];
      if (process.env.NODE_PATH) {
        possibleExecPaths.push(process.env.NODE_PATH);
      }
      if (process.env.NODEPATH) {
        possibleExecPaths.push(process.env.NODEPATH);
      }
      if (/node(.exe)?$/.test(process.execPath)) {
        possibleExecPaths.push(process.execPath);
      }
      possibleExecPaths = possibleExecPaths.concat(safeps.getStandardExecPaths(execName)).concat(isWindows ? ["/Program Files (x64)/nodejs/" + execName, "/Program Files (x86)/nodejs/" + execName, "/Program Files/nodejs/" + execName] : ["/usr/local/bin/" + execName, "/usr/bin/" + execName, "~/bin/" + execName]);
      safeps.determineExecPath(possibleExecPaths, opts, function(err, execPath) {
        if (opts.cache) {
          safeps.cachedNodePath = execPath;
        }
        if (err) {
          return next(err);
        }
        if (!execPath) {
          err = new Error('Could not locate node binary');
          return next(err);
        }
        return next(null, execPath);
      });
      return this;
    },
    getNpmPath: function(opts, next) {
      var execName, possibleExecPaths, ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.cache == null) {
        opts.cache = true;
      }
      if (opts.cache && (safeps.cachedNpmPath != null)) {
        next(null, safeps.cachedNpmPath);
        return this;
      }
      execName = isWindows ? 'npm.cmd' : 'npm';
      possibleExecPaths = [];
      if (process.env.NPM_PATH) {
        possibleExecPaths.push(process.env.NPM_PATH);
      }
      if (process.env.NPMPATH) {
        possibleExecPaths.push(process.env.NPMPATH);
      }
      if (/node(.exe)?$/.test(process.execPath)) {
        possibleExecPaths.push(process.execPath.replace(/node(.exe)?$/, execName));
      }
      possibleExecPaths = possibleExecPaths.concat(safeps.getStandardExecPaths(execName)).concat(isWindows ? ["/Program Files (x64)/nodejs/" + execName, "/Program Files (x86)/nodejs/" + execName, "/Program Files/nodejs/" + execName] : ["/usr/local/bin/" + execName, "/usr/bin/" + execName, "~/node_modules/.bin/" + execName]);
      safeps.determineExecPath(possibleExecPaths, opts, function(err, execPath) {
        if (opts.cache) {
          safeps.cachedNpmPath = execPath;
        }
        if (err) {
          return next(err);
        }
        if (!execPath) {
          err = new Error('Could not locate npm binary');
          return next(err);
        }
        return next(null, execPath);
      });
      return this;
    },
    initGitRepo: function(opts, next) {
      var commands, ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.path) {
        opts.cwd = opts.path;
        delete opts.path;
      }
      opts.cwd || (opts.cwd = process.cwd());
      opts.remote || (opts.remote = 'origin');
      opts.branch || (opts.branch = 'master');
      commands = [];
      commands.push(['init']);
      if (opts.url) {
        commands.push(['remote', 'add', opts.remote, opts.url]);
      }
      commands.push(['fetch', opts.remote]);
      commands.push(['pull', opts.remote, opts.branch]);
      commands.push(['submodule', 'init']);
      commands.push(['submodule', 'update', '--recursive']);
      safeps.spawnCommands('git', commands, opts, next);
      return this;
    },
    initOrPullGitRepo: function(opts, next) {
      var ref2;
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.path) {
        opts.cwd = opts.path;
        delete opts.path;
      }
      opts.cwd || (opts.cwd = process.cwd());
      opts.remote || (opts.remote = 'origin');
      opts.branch || (opts.branch = 'master');
      safefs.ensurePath(opts.cwd, function(err, exists) {
        if (err) {
          return complete(err);
        }
        if (exists) {
          return safeps.spawnCommand('git', ['pull', opts.remote, opts.branch], opts, function() {
            var err, result;
            err = arguments[0], result = 2 <= arguments.length ? slice.call(arguments, 1) : [];
            return next(err, 'pull', result);
          });
        } else {
          return safeps.initGitRepo(opts, function(err, result) {
            return next(err, 'init', result);
          });
        }
      });
      return this;
    },
    initNodeModules: function(opts, next) {
      var nodeModulesPath, packageJsonPath, partTwo, pathUtil, ref2;
      pathUtil = require('path');
      ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
      if (opts.path) {
        opts.cwd = opts.path;
        delete opts.path;
      }
      opts.cwd || (opts.cwd = process.cwd());
      if (opts.args == null) {
        opts.args = [];
      }
      if (opts.force == null) {
        opts.force = false;
      }
      packageJsonPath = pathUtil.join(opts.cwd, 'package.json');
      nodeModulesPath = pathUtil.join(opts.cwd, 'node_modules');
      partTwo = function() {
        return safefs.exists(packageJsonPath, function(exists) {
          var command;
          if (!exists) {
            return next();
          }
          command = ['install'].concat(opts.args);
          return safeps.spawnCommand('npm', command, opts, next);
        });
      };
      if (opts.force === false) {
        safefs.exists(nodeModulesPath, function(exists) {
          if (exists) {
            return next();
          }
          return partTwo();
        });
      } else {
        partTwo();
      }
      return this;
    }
  };

  module.exports = safeps;

}).call(this);
