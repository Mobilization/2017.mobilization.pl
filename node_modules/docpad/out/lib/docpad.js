// Generated by CoffeeScript 1.10.0
var BasePlugin, CSON, Collection, DocPad, DocumentModel, ElementsCollection, EventEmitterGrouped, Events, FileModel, FilesCollection, MetaCollection, Model, PluginLoader, QueryCollection, ScriptsCollection, StylesCollection, TaskGroup, ambi, balUtil, corePath, docpadUtil, eachr, extendr, extractOptsAndCallback, ignorefs, isUser, lazyRequire, pathUtil, pick, queryEngine, ref, ref1, rimraf, safefs, safeps, scandir, setImmediate, superAgent, typeChecker, union, uniq, util,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

pathUtil = require('path');

lazyRequire = require('lazy-require');

corePath = pathUtil.resolve(__dirname, '..', '..');

if ((indexOf.call(process.argv, '--profile') >= 0)) {
  debugger;
  if (process.env.DOCPAD_PROFILER.indexOf('nodetime') !== -1) {
    if (!process.env.NODETIME_KEY) {
      throw new Error('NODETIME_KEY environment variable is undefined');
    }
    console.log('Loading profiling tool: nodetime');
    require('lazy-require').sync('nodetime', {
      cwd: corePath
    }, function(err, nodetime) {
      if (err) {
        console.log('Failed to load profiling tool: nodetime');
        return console.log(err.stack || err);
      } else {
        nodetime.profile({
          accountKey: process.env.NODETIME_KEY,
          appName: 'DocPad'
        });
        return console.log('Profiling with nodetime with account key:', process.env.NODETIME_KEY);
      }
    });
  }
  if (process.env.DOCPAD_PROFILER.indexOf('webkit-devtools-agent') !== -1) {
    console.log('Loading profiling tool: webkit-devtools-agent');
    require('lazy-require').sync('webkit-devtools-agent', {
      cwd: corePath
    }, function(err, agent) {
      if (err) {
        console.log('Failed to load profiling tool: webkit-devtools-agent');
        return console.log(err.stack || err);
      } else {
        agent.start();
        return console.log("Profiling with webkit-devtools-agent on pid " + process.pid + " at http://127.0.0.1:9999/");
      }
    });
  }
  if (process.env.DOCPAD_PROFILER.indexOf('v8-profiler') !== -1) {
    console.log('Loading profiling tool: v8-profiler');
    require('lazy-require').sync('v8-profiler-helper', {
      cwd: corePath
    }, function(err, profiler) {
      if (err) {
        console.log('Failed to load profiling tool: v8-profiler');
        console.log(err.stack || err);
      } else {
        profiler.startProfile('docpad-profile');
        console.log("Profiling with v8-profiler");
      }
      return process.on('exit', function() {
        return profiler.stopProfile('docpad-profile');
      });
    });
  }
}

util = require('util');

queryEngine = require('query-engine');

ref = require('underscore'), uniq = ref.uniq, union = ref.union, pick = ref.pick;

CSON = require('cson');

balUtil = require('bal-util');

scandir = require('scandirectory');

extendr = require('extendr');

eachr = require('eachr');

typeChecker = require('typechecker');

ambi = require('ambi');

TaskGroup = require('taskgroup').TaskGroup;

safefs = require('safefs');

safeps = require('safeps');

ignorefs = require('ignorefs');

rimraf = require('rimraf');

superAgent = require('superagent');

extractOptsAndCallback = require('extract-opts');

EventEmitterGrouped = require('event-emitter-grouped').EventEmitterGrouped;

ref1 = require('./base'), Events = ref1.Events, Model = ref1.Model, Collection = ref1.Collection, QueryCollection = ref1.QueryCollection;

docpadUtil = require('./util');

FileModel = require('./models/file');

DocumentModel = require('./models/document');

FilesCollection = require('./collections/files');

ElementsCollection = require('./collections/elements');

MetaCollection = require('./collections/meta');

ScriptsCollection = require('./collections/scripts');

StylesCollection = require('./collections/styles');

PluginLoader = require('./plugin-loader');

BasePlugin = require('./plugin');

setImmediate = (typeof global !== "undefined" && global !== null ? global.setImmediate : void 0) || process.nextTick;

isUser = docpadUtil.isUser();


/**
 * Contains methods for managing the DocPad application.
 * This includes managing a DocPad projects files and
 * documents, watching directories, emitting events and
 * managing the node.js/express.js web server.
 * Extends https://github.com/bevry/event-emitter-grouped
 *
 * The class is instantiated in the docpad-server.js file
 * which is the entry point for a DocPad application.
 *
 * 	new DocPad(docpadConfig, function(err, docpad) {
 * 		if (err) {
 * 			return docpadUtil.writeError(err);
 * 		}
 * 		return docpad.action(action, function(err) {
 * 			if (err) {
 * 				return docpadUtil.writeError(err);
 * 			}
 * 			return console.log('OK');
 * 		});
 * 	});
 *
 * @class Docpad
 * @constructor
 * @extends EventEmitterGrouped
 */

DocPad = (function(superClass) {
  extend(DocPad, superClass);

  DocPad.create = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(this, args, function(){});
  };

  DocPad.createInstance = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return (function(func, args, ctor) {
      ctor.prototype = func.prototype;
      var child = new ctor, result = func.apply(child, args);
      return Object(result) === result ? result : child;
    })(this, args, function(){});
  };

  DocPad.require = function(relativePath) {
    var absolutePath;
    absolutePath = pathUtil.normalize(pathUtil.join(__dirname, relativePath));
    if (absolutePath.replace(__dirname, '') === absolutePath) {
      throw new Error("docpad.require is limited to local docpad files only: " + relativePath);
    }
    return require(absolutePath);
  };


  /**
  	 * Events class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee
  	 * @property {Object} Events
   */

  DocPad.prototype.Events = Events;


  /**
  	 * Model class
  	 * Extension of the Backbone Model class
  	 * http://backbonejs.org/#Model
  	 * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee
  	 * @property {Object} Model
   */

  DocPad.prototype.Model = Model;


  /**
  	 * Collection class
  	 * Extension of the Backbone Collection class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee
  	 * http://backbonejs.org/#Collection
  	 * @property {Object} Collection
   */

  DocPad.prototype.Collection = Collection;


  /**
  	 * QueryCollection class
  	 * Extension of the Query Engine QueryCollection class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee
  	 * https://github.com/bevry/query-engine/blob/master/src/documents/lib/query-engine.js.coffee
  	 * @property {Object} QueryCollection
   */

  DocPad.prototype.QueryCollection = QueryCollection;


  /**
  	 * File Model class
  	 * Extension of the Model class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/models/file.coffee
  	 * @property {Object} FileModel
   */

  DocPad.prototype.FileModel = FileModel;


  /**
  	 * Document Model class
  	 * Extension of the File Model class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/models/document.coffee
  	 * @property {Object} DocumentModel
   */

  DocPad.prototype.DocumentModel = DocumentModel;


  /**
  	 * Collection of files in a DocPad project
  	 * Extension of the QueryCollection class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/collections/files.coffee
  	 * @property {Object} FilesCollection
   */

  DocPad.prototype.FilesCollection = FilesCollection;


  /**
  	 * Collection of elements in a DocPad project
  	 * Extension of the Collection class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/collections/elements.coffee
  	 * @property {Object} ElementsCollection
   */

  DocPad.prototype.ElementsCollection = ElementsCollection;


  /**
  	 * Collection of metadata in a DocPad project
  	 * Extension of the ElementsCollection class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/collections/meta.coffee
  	 * @property {Object} MetaCollection
   */

  DocPad.prototype.MetaCollection = MetaCollection;


  /**
  	 * Collection of JS script files in a DocPad project
  	 * Extension of the ElementsCollection class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/collections/scripts.coffee
  	 * @property {Object} ScriptsCollection
   */

  DocPad.prototype.ScriptsCollection = ScriptsCollection;


  /**
  	 * Collection of CSS style files in a DocPad project
  	 * Extension of the ElementsCollection class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/collections/styles.coffee
  	 * @property {Object} StylesCollection
   */

  DocPad.prototype.StylesCollection = StylesCollection;


  /**
  	 * Plugin Loader class
  	 * https://github.com/docpad/docpad/blob/master/src/lib/plugin-loader.coffee
  	 * Loads the DocPad plugins from the file system into
  	 * a DocPad project
  	 * @property {Object} PluginLoader
   */

  DocPad.prototype.PluginLoader = PluginLoader;


  /**
  	 * Base class for all DocPad plugins
  	 * https://github.com/docpad/docpad/blob/master/src/lib/plugin.coffee
  	 * @property {Object} BasePlugin
   */

  DocPad.prototype.BasePlugin = BasePlugin;


  /**
  	 * DocPad's version number
  	 * @private
  	 * @property {Number} version
   */

  DocPad.prototype.version = null;


  /**
  	 * Get the DocPad version number
  	 * @method getVersion
  	 * @return {Number}
   */

  DocPad.prototype.getVersion = function() {
    if (this.version == null) {
      this.version = require(this.packagePath).version;
    }
    return this.version;
  };


  /**
  	 * Get the DocPad version string
  	 * @method getVersionString
  	 * @return {String}
   */

  DocPad.prototype.getVersionString = function() {
    if (docpadUtil.isLocalDocPadExecutable()) {
      return util.format(this.getLocale().versionLocal, this.getVersion(), this.corePath);
    } else {
      return util.format(this.getLocale().versionGlobal, this.getVersion(), this.corePath);
    }
  };


  /**
  	 * The plugin version requirements
  	 * @property {String} pluginVersion
   */

  DocPad.prototype.pluginVersion = '2';


  /**
  	 * Get the process platform
  	 * @method getProcessPlatform
  	 * @return {Object}
   */

  DocPad.prototype.getProcessPlatform = function() {
    return process.platform;
  };


  /**
  	 * Get the process version string
  	 * @method getProcessVersion
  	 * @return {String}
   */

  DocPad.prototype.getProcessVersion = function() {
    return process.version.replace(/^v/, '');
  };


  /**
  	 * The express.js server instance bound to DocPad.
  	 * http://expressjs.com
  	 * @private
  	 * @property {Object} serverExpress
   */

  DocPad.prototype.serverExpress = null;


  /**
  	 * The Node.js http server instance bound to DocPad
  	 * https://nodejs.org/api/http.html
  	 * @private
  	 * @property {Object} serverHttp
   */

  DocPad.prototype.serverHttp = null;


  /**
  	 * Get the DocPad express.js server instance and, optionally,
  	 * the node.js https server instance
  	 * @method getServer
  	 * @param {Boolean} [both=false]
  	 * @return {Object}
   */

  DocPad.prototype.getServer = function(both) {
    var serverExpress, serverHttp;
    if (both == null) {
      both = false;
    }
    serverExpress = this.serverExpress, serverHttp = this.serverHttp;
    if (both) {
      return {
        serverExpress: serverExpress,
        serverHttp: serverHttp
      };
    } else {
      return serverExpress;
    }
  };


  /**
  	 * Set the express.js server and node.js http server
  	 * to bind to DocPad
  	 * @method setServer
  	 * @param {Object} servers
   */

  DocPad.prototype.setServer = function(servers) {
    if (servers.serverExpress && servers.serverHttp) {
      this.serverExpress = servers.serverExpress;
      this.serverHttp = servers.serverHttp;
    }
    delete this.config.serverHttp;
    delete this.config.serverExpress;
    return delete this.config.server;
  };


  /**
  	 * Destructor. Close and destroy the node.js http server
  	 * @private
  	 * @method destroyServer
   */

  DocPad.prototype.destroyServer = function() {
    var ref2;
    if ((ref2 = this.serverHttp) != null) {
      ref2.close();
    }
    return this.serverHttp = null;
  };


  /**
  	 * Internal property. The caterpillar logger instances bound to DocPad
  	 * @private
  	 * @property {Object} loggerInstances
   */

  DocPad.prototype.loggerInstances = null;


  /**
  	 * Get the caterpillar logger instance bound to DocPad
  	 * @method getLogger
  	 * @return {Object} caterpillar logger
   */

  DocPad.prototype.getLogger = function() {
    var ref2;
    return (ref2 = this.loggerInstances) != null ? ref2.logger : void 0;
  };


  /**
  	 * Get all the caterpillar logger instances bound to DocPad
  	 * @method getLoggers
  	 * @return {Object} collection of caterpillar loggers
   */

  DocPad.prototype.getLoggers = function() {
    return this.loggerInstances;
  };


  /**
  	 * Sets the caterpillar logger instances bound to DocPad
  	 * @method setLoggers
  	 * @param {Object} loggers
  	 * @return {Object} logger instances bound to DocPad
   */

  DocPad.prototype.setLoggers = function(loggers) {
    if (this.loggerInstances) {
      this.warn(this.getLocale().loggersAlreadyDefined);
    } else {
      this.loggerInstances = loggers;
      this.loggerInstances.logger.setConfig({
        dry: true
      });
      this.loggerInstances.console.setConfig({
        dry: false
      }).pipe(process.stdout);
    }
    return loggers;
  };


  /**
  	 * Destructor. Destroy the caterpillar logger instances bound to DocPad
  	 * @private
  	 * @method {Object} destroyLoggers
   */

  DocPad.prototype.destroyLoggers = function() {
    var key, ref2, value;
    if (this.loggerInstances) {
      ref2 = this.loggerInstances;
      for (key in ref2) {
        if (!hasProp.call(ref2, key)) continue;
        value = ref2[key];
        value.end();
      }
    }
    return this;
  };


  /**
  	 * The action runner instance bound to docpad
  	 * @private
  	 * @property {Object} actionRunnerInstance
   */

  DocPad.prototype.actionRunnerInstance = null;


  /**
  	 * Get the action runner instance bound to docpad
  	 * @method getActionRunner
  	 * @return {Object} the action runner instance
   */

  DocPad.prototype.getActionRunner = function() {
    return this.actionRunnerInstance;
  };


  /**
  	 * Apply the passed DocPad action arguments
  	 * @method {Object} action
  	 * @param {Object} args
  	 * @return {Object}
   */

  DocPad.prototype.action = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return docpadUtil.action.apply(this, args);
  };


  /**
  	 * The error runner instance bound to DocPad
  	 * @property {Object} errorRunnerInstance
   */

  DocPad.prototype.errorRunnerInstance = null;


  /**
  	 * Get the error runner instance
  	 * @method {Object} getErrorRunner
  	 * @return {Object} the error runner instance
   */

  DocPad.prototype.getErrorRunner = function() {
    return this.errorRunnerInstance;
  };


  /**
  	 * The track runner instance bound to DocPad
  	 * @private
  	 * @property {Object} trackRunnerInstance
   */

  DocPad.prototype.trackRunnerInstance = null;


  /**
  	 * Get the track runner instance
  	 * @method getTrackRunner
  	 * @return {Object} the track runner instance
   */

  DocPad.prototype.getTrackRunner = function() {
    return this.trackRunnerInstance;
  };


  /**
  	 * Event Listing. String array of event names.
  	 * Whenever an event is created, it must be applied here to be available to plugins and configuration files
  	 * https://github.com/bevry/docpad/wiki/Events
  	 * @private
  	 * @property {Array} string array of event names
   */

  DocPad.prototype.events = ['extendTemplateData', 'extendCollections', 'docpadLoaded', 'docpadReady', 'docpadDestroy', 'consoleSetup', 'generateBefore', 'populateCollectionsBefore', 'populateCollections', 'contextualizeBefore', 'contextualizeAfter', 'renderBefore', 'renderCollectionBefore', 'render', 'renderDocument', 'renderCollectionAfter', 'renderAfter', 'writeBefore', 'writeAfter', 'generateAfter', 'generated', 'serverBefore', 'serverExtend', 'serverAfter', 'notify'];


  /**
  	 * Get the list of available events
  	 * @method getEvents
  	 * @return {Object} string array of event names
   */

  DocPad.prototype.getEvents = function() {
    return this.events;
  };


  /**
  	 * QueryEngine collection
  	 * @private
  	 * @property {Object} database
   */

  DocPad.prototype.database = null;


  /**
  	 * A FilesCollection of models updated
  	 * from the DocPad database after each regeneration.
  	 * @private
  	 * @property {Object} databaseTempCache FileCollection of models
   */

  DocPad.prototype.databaseTempCache = null;


  /**
  	 * Description for getDatabase
  	 * @method {Object} getDatabase
   */

  DocPad.prototype.getDatabase = function() {
    return this.database;
  };


  /**
  	 * Safe method for retrieving the database by
  	 * either returning the database itself or the temporary
  	 * database cache
  	 * @method getDatabaseSafe
  	 * @return {Object}
   */

  DocPad.prototype.getDatabaseSafe = function() {
    return this.databaseTempCache || this.database;
  };


  /**
  	 * Destructor. Destroy the DocPad database
  	 * @private
  	 * @method destroyDatabase
   */

  DocPad.prototype.destroyDatabase = function() {
    if (this.database != null) {
      this.database.destroy();
      this.database = null;
    }
    if (this.databaseTempCache != null) {
      this.databaseTempCache.destroy();
      this.databaseTempCache = null;
    }
    return this;
  };


  /**
  	 * Files by url. Used to speed up fetching
  	 * @private
  	 * @property {Object} filesByUrl
   */

  DocPad.prototype.filesByUrl = null;


  /**
  	 * Files by Selector. Used to speed up fetching
  	 * @private
  	 * @property {Object} filesBySelector
   */

  DocPad.prototype.filesBySelector = null;


  /**
  	 * Files by Out Path. Used to speed up conflict detection. Do not use for anything else
  	 * @private
  	 * @property {Object} filesByOutPath
   */

  DocPad.prototype.filesByOutPath = null;


  /**
  	 * Blocks
  	 * @private
  	 * @property {Object} blocks
   */

  DocPad.prototype.blocks = null;


  /* {
  		 * A collection of meta elements
  		meta: null  # Elements Collection
  
  		 * A collection of script elements
  		scripts: null  # Scripts Collection
  
  		 * Collection of style elements
  		styles: null  # Styles Collection
  	}
   */


  /**
  	 * Get a block by block name. Optionally clone block.
  	 * @method getBlock
  	 * @param {String} name
  	 * @param {Object} [clone]
  	 * @return {Object} block
   */

  DocPad.prototype.getBlock = function(name, clone) {
    var block, classname;
    block = this.blocks[name];
    if (clone) {
      classname = name[0].toUpperCase() + name.slice(1) + 'Collection';
      block = new this[classname](block.models);
    }
    return block;
  };


  /**
  	 * Set a block by name and value
  	 * @method setBlock
  	 * @param {String} name
  	 * @param {Object} value
   */

  DocPad.prototype.setBlock = function(name, value) {
    if (this.blocks[name] != null) {
      this.blocks[name].destroy();
      if (value) {
        this.blocks[name] = value;
      } else {
        delete this.blocks[name];
      }
    } else {
      this.blocks[name] = value;
    }
    return this;
  };


  /**
  	 * Get all blocks
  	 * @method getBlocks
  	 * @return {Object} collection of blocks
   */

  DocPad.prototype.getBlocks = function() {
    return this.blocks;
  };


  /**
  	 * Set all blocks
  	 * @method setBlocks
  	 * @param {Object} blocks
   */

  DocPad.prototype.setBlocks = function(blocks) {
    var name, value;
    for (name in blocks) {
      if (!hasProp.call(blocks, name)) continue;
      value = blocks[name];
      this.setBlock(name, value);
    }
    return this;
  };


  /**
  	 * Apply the passed function to each block
  	 * @method eachBlock
  	 * @param {Function} fn
   */

  DocPad.prototype.eachBlock = function(fn) {
    eachr(this.blocks, fn);
    return this;
  };


  /**
  	 * Destructor. Destroy all blocks
  	 * @private
  	 * @method destroyBlocks
   */

  DocPad.prototype.destroyBlocks = function() {
    var block, name, ref2;
    if (this.blocks) {
      ref2 = this.blocks;
      for (name in ref2) {
        if (!hasProp.call(ref2, name)) continue;
        block = ref2[name];
        block.destroy();
        this.blocks[name] = null;
      }
    }
    return this;
  };


  /**
  	 * The DocPad collections
  	 * @private
  	 * @property {Object} collections
   */

  DocPad.prototype.collections = null;


  /**
  	 * Get a collection by collection name or key.
  	 * This is often accessed within the docpad.coffee
  	 * file or a layout/page via @getCollection.
  	 * Because getCollection returns a docpad collection,
  	 * a call to this method is often chained with a
  	 * QueryEngine style query.
  	 *
  	 * 	@getCollection('documents').findAllLive({relativeOutDirPath: 'posts'},[{date:-1}])
  	 *
  	 * @method getCollection
  	 * @param {String} value
  	 * @return {Object} collection
   */

  DocPad.prototype.getCollection = function(value) {
    var collection, i, j, len, len1, ref2, ref3;
    if (value) {
      if (typeof value === 'string') {
        if (value === 'database') {
          return this.getDatabase();
        } else {
          ref2 = this.collections;
          for (i = 0, len = ref2.length; i < len; i++) {
            collection = ref2[i];
            if (value === collection.options.name || value === collection.options.key) {
              return collection;
            }
          }
        }
      } else {
        ref3 = this.collections;
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          collection = ref3[j];
          if (value === collection) {
            return collection;
          }
        }
      }
    }
    return null;
  };


  /**
  	 * Destroy a collection by collection name or key
  	 * @method destroyCollection
  	 * @param {String} value
  	 * @return {Object} description
   */

  DocPad.prototype.destroyCollection = function(value) {
    if (value) {
      if (typeof value === 'string' && value !== 'database') {
        this.collections = this.collections.filter(function(collection) {
          if (value === collection.options.name || value === collection.options.key) {
            if (collection != null) {
              collection.destroy();
            }
            return false;
          } else {
            return true;
          }
        });
      } else if (value !== this.getDatabase()) {
        this.collections = this.collections.filter(function(collection) {
          if (value === collection) {
            if (collection != null) {
              collection.destroy();
            }
            return false;
          } else {
            return true;
          }
        });
      }
    }
    return null;
  };


  /**
  	 * Add a collection
  	 * @method addCollection
  	 * @param {Object} collection
   */

  DocPad.prototype.addCollection = function(collection) {
    if (collection && (collection !== this.getDatabase() && collection !== this.getCollection(collection))) {
      this.collections.push(collection);
    }
    return this;
  };


  /**
  	 * Set a name for a collection.
  	 * A collection can have multiple names
  	 *
  	 * The partials plugin (https://github.com/docpad/docpad-plugin-partials)
  	 * creates a live collection and passes this to setCollection with
  	 * the name 'partials'.
  	 *
  	 * 	# Add our partials collection
  	 *	docpad.setCollection('partials', database.createLiveChildCollection()
  	 *		.setQuery('isPartial', {
  	 *				$or:
  	 *					isPartial: true
  	 *					fullPath: $startsWith: config.partialsPath
  	 *		})
  	 *		.on('add', (model) ->
  	 *			docpad.log('debug', util.format(locale.addingPartial, model.getFilePath()))
  	 *			model.setDefaults(
  	 *				isPartial: true
  	 *				render: false
  	 *				write: false
  	 *			)
  	 *		)
  	 *	)
  	 *
  	 *
  	 * @method setCollection
  	 * @param {String} name the name to give to the collection
  	 * @param {Object} collection a DocPad collection
   */

  DocPad.prototype.setCollection = function(name, collection) {
    if (collection) {
      if (name) {
        collection.options.name = name;
        if (this.getCollection(name) !== collection) {
          this.destroyCollection(name);
        }
      }
      return this.addCollection(collection);
    } else {
      return this.destroyCollection(name);
    }
  };


  /**
  	 * Get the DocPad project's collections
  	 * @method getCollections
  	 * @return {Object} the collections
   */

  DocPad.prototype.getCollections = function() {
    return this.collections;
  };


  /**
  	 * Set the DocPad project's collections
  	 * @method setCollections
   */

  DocPad.prototype.setCollections = function(collections) {
    var i, len, name, value;
    if (Array.isArray(collections)) {
      for (i = 0, len = collections.length; i < len; i++) {
        value = collections[i];
        this.addCollection(value);
      }
    } else {
      for (name in collections) {
        if (!hasProp.call(collections, name)) continue;
        value = collections[name];
        this.setCollection(name, value);
      }
    }
    return this;
  };


  /**
  	 * Apply the passed function to each collection
  	 * @method eachCollection
  	 * @param {Function} fn
   */

  DocPad.prototype.eachCollection = function(fn) {
    var collection, i, index, len, ref2;
    fn(this.getDatabase(), 'database');
    ref2 = this.collections;
    for (index = i = 0, len = ref2.length; i < len; index = ++i) {
      collection = ref2[index];
      fn(collection, collection.options.name || collection.options.key || index);
    }
    return this;
  };


  /**
  	 * Destructor. Destroy the DocPad project's collections.
  	 * @private
  	 * @method destroyCollections
   */

  DocPad.prototype.destroyCollections = function() {
    var collection, i, len, ref2;
    if (this.collections) {
      ref2 = this.collections;
      for (i = 0, len = ref2.length; i < len; i++) {
        collection = ref2[i];
        collection.destroy();
      }
      this.collections = [];
    }
    return this;
  };


  /**
  	 * Get all the files in the DocPad database (will use live collections)
  	 * @method getFiles
  	 * @param {Object} query
  	 * @param {Object} sorting
  	 * @param {Object} paging
  	 * @return {Object} collection
   */

  DocPad.prototype.getFiles = function(query, sorting, paging) {
    var collection, key;
    key = JSON.stringify({
      query: query,
      sorting: sorting,
      paging: paging
    });
    collection = this.getCollection(key);
    if (!collection) {
      collection = this.getDatabase().findAllLive(query, sorting, paging);
      collection.options.key = key;
      this.addCollection(collection);
    }
    return collection;
  };


  /**
  	 * Get a single file based on a query
  	 * @method getFile
  	 * @param {Object} query
  	 * @param {Object} sorting
  	 * @param {Object} paging
  	 * @return {Object} a file
   */

  DocPad.prototype.getFile = function(query, sorting, paging) {
    var file;
    file = this.getDatabase().findOne(query, sorting, paging);
    return file;
  };


  /**
  	 * Get files at a path
  	 * @method getFilesAtPath
  	 * @param {String} path
  	 * @param {Object} sorting
  	 * @param {Object} paging
  	 * @return {Object} files
   */

  DocPad.prototype.getFilesAtPath = function(path, sorting, paging) {
    var files, query;
    query = {
      $or: [
        {
          relativePath: {
            $startsWith: path
          }
        }, {
          fullPath: {
            $startsWith: path
          }
        }
      ]
    };
    files = this.getFiles(query, sorting, paging);
    return files;
  };


  /**
  	 * Get a file at a relative or absolute path or url
  	 * @method getFileAtPath
  	 * @param {String} path
  	 * @param {Object} sorting
  	 * @param {Object} paging
  	 * @return {Object} a file
   */

  DocPad.prototype.getFileAtPath = function(path, sorting, paging) {
    var file;
    file = this.getDatabase().fuzzyFindOne(path, sorting, paging);
    return file;
  };


  /**
  	 * Get a file by its url
  	 * @method getFileByUrl
  	 * @param {String} url
  	 * @param {Object} [opts={}]
  	 * @return {Object} a file
   */

  DocPad.prototype.getFileByUrl = function(url, opts) {
    var file;
    if (opts == null) {
      opts = {};
    }
    if (opts.collection == null) {
      opts.collection = this.getDatabase();
    }
    file = opts.collection.get(this.filesByUrl[url]);
    return file;
  };


  /**
  	 * Get a file by its id
  	 * @method getFileById
  	 * @param {String} id
  	 * @param {Object} [opts={}]
  	 * @return {Object} a file
   */

  DocPad.prototype.getFileById = function(id, opts) {
    var file;
    if (opts == null) {
      opts = {};
    }
    if (opts.collection == null) {
      opts.collection = this.getDatabase();
    }
    file = opts.collection.get(id);
    return file;
  };


  /**
  	 * Remove the query string from a url
  	 * Pathname convention taken from document.location.pathname
  	 * @method getUrlPathname
  	 * @param {String} url
  	 * @return {String}
   */

  DocPad.prototype.getUrlPathname = function(url) {
    return url.replace(/\?.*/, '');
  };


  /**
  	 * Get a file by its route and return
  	 * it to the supplied callback.
  	 * @method getFileByRoute
  	 * @param {String} url
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @param {String} next.file
   */

  DocPad.prototype.getFileByRoute = function(url, next) {
    var cleanUrl, database, docpad, file;
    docpad = this;
    if (docpad.generated === false) {
      docpad.once('generated', function() {
        return docpad.getFileByRoute(url, next);
      });
      return this;
    }
    database = docpad.getDatabaseSafe();
    cleanUrl = docpad.getUrlPathname(url);
    file = docpad.getFileByUrl(url, {
      collection: database
    }) || docpad.getFileByUrl(cleanUrl, {
      collection: database
    });
    next(null, file);
    return this;
  };


  /**
  	 * Get a file by its selector
  	 * @method getFileBySelector
  	 * @param {Object} selector
  	 * @param {Object} [opts={}]
  	 * @return {Object} a file
   */

  DocPad.prototype.getFileBySelector = function(selector, opts) {
    var file;
    if (opts == null) {
      opts = {};
    }
    if (opts.collection == null) {
      opts.collection = this.getDatabase();
    }
    file = opts.collection.get(this.filesBySelector[selector]);
    if (!file) {
      file = opts.collection.fuzzyFindOne(selector);
      if (file) {
        this.filesBySelector[selector] = file.id;
      }
    }
    return file;
  };


  /**
  	 * Skeletons Collection
  	 * @private
  	 * @property {Object} skeletonsCollection
   */

  DocPad.prototype.skeletonsCollection = null;


  /**
  	 * Get Skeletons
  	 * Get all the available skeletons with their details and
  	 * return this collection to the supplied callback.
  	 * @method getSkeletons
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.skeletonsCollection DocPad collection of skeletons
  	 * @return {Object} DocPad skeleton collection
   */

  DocPad.prototype.getSkeletons = function(next) {
    var docpad, locale;
    docpad = this;
    locale = this.getLocale();
    if (this.skeletonsCollection != null) {
      return next(null, this.skeletonsCollection);
    }
    this.skeletonsCollection = new Collection();
    this.skeletonsCollection.comparator = queryEngine.generateComparator({
      position: 1,
      name: 1
    });
    this.getExchange(function(err, exchange) {
      var index;
      if (err) {
        return next(err);
      }
      index = 0;
      if (exchange) {
        eachr(exchange.skeletons, function(skeleton, skeletonKey) {
          if (skeleton.id == null) {
            skeleton.id = skeletonKey;
          }
          if (skeleton.name == null) {
            skeleton.name = skeletonKey;
          }
          if (skeleton.position == null) {
            skeleton.position = index;
          }
          docpad.skeletonsCollection.add(new Model(skeleton));
          return ++index;
        });
      }
      docpad.skeletonsCollection.add(new Model({
        id: 'none',
        name: locale.skeletonNoneName,
        description: locale.skeletonNoneDescription,
        position: index
      }));
      return next(null, docpad.skeletonsCollection);
    });
    return this;
  };


  /**
  	 * Plugins that are loading really slow
  	 * @property {Object} slowPlugins
   */

  DocPad.prototype.slowPlugins = null;


  /**
  	 * Loaded plugins indexed by name
  	 * @property {Object} loadedPlugins
   */

  DocPad.prototype.loadedPlugins = null;


  /**
  	 * A listing of all the available extensions for DocPad
  	 * @property {Object} exchange
   */

  DocPad.prototype.exchange = null;


  /**
  	 * The DocPad directory
  	 * @property {String} corePath
   */

  DocPad.prototype.corePath = corePath;


  /**
  	 * The DocPad library directory
  	 * @private
  	 * @property {String} libPath
   */

  DocPad.prototype.libPath = __dirname;


  /**
  	 * The main DocPad file
  	 * @property {String} mainPath
   */

  DocPad.prototype.mainPath = pathUtil.resolve(__dirname, 'docpad');


  /**
  	 * The DocPad package.json path
  	 * @property {String} packagePath
   */

  DocPad.prototype.packagePath = pathUtil.resolve(__dirname, '..', '..', 'package.json');


  /**
  	 * The DocPad locale path
  	 * @property {String} localePath
   */

  DocPad.prototype.localePath = pathUtil.resolve(__dirname, '..', '..', 'locale');


  /**
  	 * The DocPad debug log path (docpad-debug.log)
  	 * @property {String} debugLogPath
   */

  DocPad.prototype.debugLogPath = pathUtil.join(process.cwd(), 'docpad-debug.log');


  /**
  	 * The User's configuration path (.docpad.cson)
  	 * @property {String} userConfigPath
   */

  DocPad.prototype.userConfigPath = '.docpad.cson';


  /**
  	 * Description for initialTemplateData
  	 * @private
  	 * @property {Object} initialTemplateData
   */

  DocPad.prototype.initialTemplateData = null;


  /**
  	 * Plugin's Extended Template Data
  	 * @private
  	 * @property {Object} pluginsTemplateData
   */

  DocPad.prototype.pluginsTemplateData = null;


  /**
  	 * Get Complete Template Data
  	 * @method getTemplateData
  	 * @param {Object} userTemplateData
  	 * @return {Object} templateData
   */

  DocPad.prototype.getTemplateData = function(userTemplateData) {
    var base, base1, base2, docpad, locale, templateData;
    userTemplateData || (userTemplateData = {});
    docpad = this;
    locale = this.getLocale();
    if (this.initialTemplateData == null) {
      this.initialTemplateData = {
        site: {},
        getEnvironment: function() {
          return docpad.getEnvironment();
        },
        getEnvironments: function() {
          return docpad.getEnvironments();
        },
        referencesOthers: function(flag) {
          var document;
          document = this.getDocument();
          document.referencesOthers();
          return null;
        },
        getDocument: function() {
          return this.documentModel;
        },
        getPath: function(path, parentPath) {
          var document;
          document = this.getDocument();
          path = document.getPath(path, parentPath);
          return path;
        },
        getFiles: function(query, sorting, paging) {
          var result;
          this.referencesOthers();
          result = docpad.getFiles(query, sorting, paging);
          return result;
        },
        getFile: function(query, sorting, paging) {
          var result;
          this.referencesOthers();
          result = docpad.getFile(query, sorting, paging);
          return result;
        },
        getFilesAtPath: function(path, sorting, paging) {
          var result;
          this.referencesOthers();
          path = this.getPath(path);
          result = docpad.getFilesAtPath(path, sorting, paging);
          return result;
        },
        getFileAtPath: function(relativePath) {
          var path, result;
          this.referencesOthers();
          path = this.getPath(relativePath);
          result = docpad.getFileAtPath(path);
          return result;
        },
        getFileById: function(id) {
          var result;
          this.referencesOthers();
          result = docpad.getFileById(id);
          return result;
        },
        getDatabase: function() {
          this.referencesOthers();
          return docpad.getDatabase();
        },
        getCollection: function(name) {
          this.referencesOthers();
          return docpad.getCollection(name);
        },
        getBlock: function(name) {
          return docpad.getBlock(name, true);
        },
        include: function(subRelativePath, strict) {
          var err, file;
          if (strict == null) {
            strict = true;
          }
          file = this.getFileAtPath(subRelativePath);
          if (file) {
            if (strict && file.get('rendered') === false) {
              if (docpad.getConfig().renderPasses === 1) {
                docpad.warn(util.format(locale.renderedEarlyViaInclude, subRelativePath));
              }
              return null;
            }
            return file.getOutContent();
          } else {
            err = new Error(util.format(locale.includeFailed, subRelativePath));
            throw err;
          }
        }
      };
    }
    templateData = extendr.extend({}, this.initialTemplateData, this.pluginsTemplateData, this.getConfig().templateData, userTemplateData);
    (base = templateData.site).url || (base.url = this.getSimpleServerUrl());
    (base1 = templateData.site).date || (base1.date = new Date());
    (base2 = templateData.site).keywords || (base2.keywords = []);
    if (typeChecker.isString(templateData.site.keywords)) {
      templateData.site.keywords = templateData.site.keywords.split(/,\s*/g);
    }
    return templateData;
  };


  /**
  	 * Determined locale
  	 * @private
  	 * @property {Object} locale
   */

  DocPad.prototype.locale = null;


  /**
  	 * Get the locale (language code and locale code)
  	 * @method getLocale
  	 * @return {Object} locale
   */

  DocPad.prototype.getLocale = function() {
    var code, codes, config, locales;
    if ((this.locale != null) === false) {
      config = this.getConfig();
      codes = uniq(['en', safeps.getLanguageCode(config.localeCode), safeps.getLanguageCode(safeps.getLocaleCode()), safeps.getLocaleCode(config.localeCode), safeps.getLocaleCode(safeps.getLocaleCode())]);
      locales = (function() {
        var i, len, results;
        results = [];
        for (i = 0, len = codes.length; i < len; i++) {
          code = codes[i];
          results.push(this.loadLocale(code));
        }
        return results;
      }).call(this);
      this.locale = extendr.extend.apply(extendr, locales);
    }
    return this.locale;
  };


  /**
  	 * Load the locale
  	 * @method loadLocale
  	 * @param {String} code
  	 * @return {Object} locale
   */

  DocPad.prototype.loadLocale = function(code) {
    var locale, localeFilename, localePath;
    localeFilename = code + ".cson";
    localePath = pathUtil.join(this.localePath, localeFilename);
    if (!safefs.existsSync(localePath)) {
      return null;
    }
    locale = CSON.parseCSONFile(localePath);
    if (locale instanceof Error) {
      locale.context = "Failed to parse the CSON locale file: " + localePath;
      docpad.error(locale);
      return null;
    }
    return locale;
  };


  /**
  	 * Get the DocPad environment, eg: development,
  	 * production or static
  	 * @method getEnvironment
  	 * @return {String} the environment
   */

  DocPad.prototype.getEnvironment = function() {
    var env;
    env = this.getConfig().env || 'development';
    return env;
  };


  /**
  	 * Get the environments
  	 * @method getEnvironments
  	 * @return {Array} array of environment strings
   */

  DocPad.prototype.getEnvironments = function() {
    var env, envs;
    env = this.getEnvironment();
    envs = env.split(/[, ]+/);
    return envs;
  };


  /**
  	 * Hash Key
  	 * The key that we use to hash some data before sending it to our statistic server
  	 * @private
  	 * @property {String} string constant
   */

  DocPad.prototype.hashKey = '7>9}$3hP86o,4=@T';


  /**
  	 * Website Package Configuration
  	 * @private
  	 * @property {Object} websitePackageConfig
   */

  DocPad.prototype.websitePackageConfig = null;


  /**
  	 * Merged Configuration
  	 * Merged in the order of:
  	 * - initialConfig
  	 * - userConfig
  	 * - websiteConfig
  	 * - instanceConfig
  	 * - environmentConfig
  	 * Use getConfig to retrieve this value
  	 * @private
  	 * @property {Object} config
   */

  DocPad.prototype.config = null;


  /**
  	 * Instance Configuration
  
  	 * @private
  	 * @property {Object} instanceConfig
   */

  DocPad.prototype.instanceConfig = null;


  /**
  	 * Website Configuration
  	 * Merged into the config property
  	 * @private
  	 * @property {Object} websiteConfig
   */

  DocPad.prototype.websiteConfig = null;


  /**
  	 * User Configuraiton
  	 * Merged into the config property
  	 * @private
  	 * @property {Object} userConfig
   */

  DocPad.prototype.userConfig = {
    name: null,
    email: null,
    username: null,
    subscribed: null,
    subscribeTryAgain: null,
    tos: null,
    identified: null
  };


  /**
  	 * Initial Configuration. The default docpadConfig
  	 * settings that can be overridden in a project's docpad.coffee file.
  	 * Merged into the config property
  	 * @private
  	 * @property {Object} initialConfig
   */

  DocPad.prototype.initialConfig = {
    force: false,
    global: false,
    enableUnlistedPlugins: true,
    enabledPlugins: {},
    skipUnsupportedPlugins: true,
    warnUncompiledPrivatePlugins: true,
    plugins: {},
    rootPath: process.cwd(),
    databaseCachePath: '.docpad.db',
    packagePath: 'package.json',
    configPaths: ['docpad.js', 'docpad.coffee', 'docpad.json', 'docpad.cson'],
    pluginPaths: [],
    pluginsPaths: ['node_modules', 'plugins'],
    reloadPaths: [],
    regeneratePaths: [],
    regenerateDelay: 100,
    slowFilesDelay: 20 * 1000,
    outPath: 'out',
    srcPath: 'src',
    documentsPaths: ['documents', 'render'],
    filesPaths: ['files', 'static', 'public'],
    layoutsPaths: ['layouts'],
    ignorePaths: false,
    ignoreHiddenFiles: false,
    ignoreCommonPatterns: true,
    ignoreCustomPatterns: false,
    watchOptions: null,
    port: null,
    hostname: null,
    maxAge: 86400000,
    serverExpress: null,
    serverHttp: null,
    extendServer: true,
    middlewareStandard: true,
    middlewareBodyParser: true,
    middlewareMethodOverride: true,
    middlewareExpressRouter: true,
    middleware404: true,
    middleware500: true,
    logLevel: ((indexOf.call(process.argv, '-d') >= 0) ? 7 : 6),
    catchExceptions: true,
    reportErrors: process.argv.join('').indexOf('test') === -1,
    reportStatistics: process.argv.join('').indexOf('test') === -1,
    color: null,
    databaseCache: false,
    detectEncoding: false,
    renderSingleExtensions: false,
    renderPasses: 1,
    offline: false,
    checkVersion: false,
    welcome: false,
    prompts: false,
    progress: true,
    poweredByDocPad: true,
    helperUrl: true ? 'http://helper.docpad.org/' : 'http://localhost:8000/',
    safeMode: false,
    templateData: {},
    collections: {},
    events: {},
    regenerateEvery: false,
    regenerateEveryOptions: {
      populate: true,
      partial: false
    },
    localeCode: null,
    env: null,
    environments: {
      development: {
        maxAge: false,
        checkVersion: isUser,
        welcome: isUser,
        prompts: isUser
      }
    }
  };


  /**
  	 * Regenerate Timer
  	 * When config.regenerateEvery is set to a value, we create a timer here
  	 * @private
  	 * @property {Object} regenerateTimer
   */

  DocPad.prototype.regenerateTimer = null;


  /**
  	 * Get the DocPad configuration. Commonly
  	 * called within the docpad.coffee file or within
  	 * plugins to access application specific configurations.
  	 * 	serverExtend: (opts) ->
  			 * Extract the server from the options
  			{server} = opts
  			docpad = @docpad
  
  			 * As we are now running in an event,
  			 * ensure we are using the latest copy of the docpad configuraiton
  			 * and fetch our urls from it
  			latestConfig = docpad.getConfig()
  			oldUrls = latestConfig.templateData.site.oldUrls or []
  			newUrl = latestConfig.templateData.site.url
  
  			 * Redirect any requests accessing one of our sites oldUrls to the new site url
  			server.use (req,res,next) ->
  				...
  	 * @method getConfig
  	 * @return {Object} the DocPad configuration object
   */

  DocPad.prototype.getConfig = function() {
    return this.config || {};
  };


  /**
  	 * Get the port that DocPad is listening on (eg 9778)
  	 * @method getPort
  	 * @return {Number} the port number
   */

  DocPad.prototype.getPort = function() {
    var ref2, ref3;
    return (ref2 = (ref3 = this.getConfig().port) != null ? ref3 : require('hostenv').PORT) != null ? ref2 : 9778;
  };


  /**
  	 * Get the Hostname
  	 * @method getHostname
  	 * @return {String}
   */

  DocPad.prototype.getHostname = function() {
    var ref2, ref3;
    return (ref2 = (ref3 = this.getConfig().hostname) != null ? ref3 : require('hostenv').HOSTNAME) != null ? ref2 : '0.0.0.0';
  };


  /**
  	 * Get address
  	 * @method getServerUrl
  	 * @param {Object} [opts={}]
  	 * @return {String}
   */

  DocPad.prototype.getServerUrl = function(opts) {
    var ref2;
    if (opts == null) {
      opts = {};
    }
    if (opts.hostname == null) {
      opts.hostname = this.getHostname();
    }
    if (opts.port == null) {
      opts.port = this.getPort();
    }
    if (opts.simple == null) {
      opts.simple = false;
    }
    if (opts.simple === true && ((ref2 = opts.hostname) === '0.0.0.0' || ref2 === '::' || ref2 === '::1')) {
      return "http://127.0.0.1:" + opts.port;
    } else {
      return "http://" + opts.hostname + ":" + opts.port;
    }
  };


  /**
  	 * Get simple server URL (changes 0.0.0.0, ::, and ::1 to 127.0.0.1)
  	 * @method getSimpleServerUrl
  	 * @param {Object} [opts={}]
  	 * @param {Boolean} [opts.simple=true]
  	 * @return {String}
   */

  DocPad.prototype.getSimpleServerUrl = function(opts) {
    if (opts == null) {
      opts = {};
    }
    opts.simple = true;
    return this.getServerUrl(opts);
  };


  /**
  	 * Constructor method. Sets up the DocPad instance.
  	 * next(err)
  	 * @method constructor
  	 * @param {Object} instanceConfig
  	 * @param {Function} next callback
  	 * @param {Error} next.err
   */

  function DocPad(instanceConfig, next) {
    var action, configEventContext, docpad, i, len, logger, loggerConsole, loggers, methodName, ref2, ref3, ref4;
    ref2 = extractOptsAndCallback(instanceConfig, next), instanceConfig = ref2[0], next = ref2[1];
    docpad = this;
    this.TaskGroup = (function(superClass1) {
      extend(_Class, superClass1);

      function _Class() {
        var tasks;
        _Class.__super__.constructor.apply(this, arguments);
        tasks = this;
        tasks.on('started', function() {
          var config, name, progress, totals;
          config = tasks.getConfig();
          name = tasks.getNames();
          progress = config.progress;
          if (progress) {
            totals = tasks.getItemTotals();
            return progress.step(name).total(totals.total).setTick(totals.completed);
          } else {
            return docpad.log('debug', name + ' > started');
          }
        });
        tasks.on('item.add', function(item) {
          var config, name, progress, totals;
          config = tasks.getConfig();
          name = item.getNames();
          progress = config.progress;
          if (progress) {
            totals = tasks.getItemTotals();
            return progress.step(name).total(totals.total).setTick(totals.completed);
          } else {
            return docpad.log('debug', name + ' > added');
          }
        });
        tasks.on('item.started', function(item) {
          var config, name, progress, totals;
          config = tasks.getConfig();
          name = item.getNames();
          progress = config.progress;
          if (progress) {
            totals = tasks.getItemTotals();
            return progress.step(name).total(totals.total).setTick(totals.completed);
          } else {
            return docpad.log('debug', name + ' > started');
          }
        });
        tasks.on('item.done', function(item, err) {
          var config, name, progress, totals;
          config = tasks.getConfig();
          name = item.getNames();
          progress = config.progress;
          if (progress) {
            totals = tasks.getItemTotals();
            return progress.step(name).total(totals.total).setTick(totals.completed);
          } else {
            return docpad.log('debug', name + ' > done');
          }
        });
        this;
      }

      return _Class;

    })(TaskGroup);
    ref3 = "action\nlog warn error fatal inspector notify track identify subscribe checkRequest\nserverMiddlewareRouter serverMiddlewareHeader serverMiddleware404 serverMiddleware500\ndestroyWatchers".split(/\s+/);
    for (i = 0, len = ref3.length; i < len; i++) {
      methodName = ref3[i];
      this[methodName] = this[methodName].bind(this);
    }
    this.setMaxListeners(0);
    configEventContext = {
      docpad: docpad
    };
    this.getEvents().forEach(function(eventName) {
      return docpad.on(eventName, function(opts, next) {
        var args, eventHandler, ref4;
        eventHandler = (ref4 = docpad.getConfig().events) != null ? ref4[eventName] : void 0;
        if (typeChecker.isFunction(eventHandler)) {
          args = [opts, next];
          return ambi.apply(null, [eventHandler.bind(configEventContext)].concat(slice.call(args)));
        } else {
          return next();
        }
      });
    });
    this.actionRunnerInstance = this.TaskGroup.create('action runner').whenDone(function(err) {
      if (err) {
        return docpad.error(err);
      }
    });
    this.trackRunnerInstance = this.TaskGroup.create('track runner').whenDone(function(err) {
      var locale;
      if (err && docpad.getDebugging()) {
        locale = docpad.getLocale();
        return docpad.warn(locale.trackError, err);
      }
    });
    if ((loggers = instanceConfig.loggers)) {
      delete instanceConfig.loggers;
    } else {
      logger = new (require('caterpillar').Logger)({
        lineOffset: 2
      });
      loggerConsole = logger.pipe(new (require('caterpillar-filter').Filter)).pipe(new (require('caterpillar-human').Human));
      loggers = {
        logger: logger,
        console: loggerConsole
      };
    }
    safefs.unlink(this.debugLogPath, function() {});
    this.setLoggers(loggers);
    this.setLogLevel((ref4 = instanceConfig.logLevel) != null ? ref4 : this.initialConfig.logLevel);
    this.on('log', function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return docpad.log.apply(this, args);
    });
    this.slowPlugins = {};
    this.loadedPlugins = {};
    this.exchange = {};
    this.pluginsTemplateData = {};
    this.instanceConfig = {};
    this.collections = [];
    this.blocks = {};
    this.filesByUrl = {};
    this.filesBySelector = {};
    this.filesByOutPath = {};
    this.database = new FilesCollection(null, {
      name: 'database'
    }).on('remove', function(model, options) {
      var j, len1, outPath, ref5, updatedModels, url;
      if (model.get('write') === false) {
        return;
      }
      ref5 = model.get('urls') || [];
      for (j = 0, len1 = ref5.length; j < len1; j++) {
        url = ref5[j];
        delete docpad.filesByUrl[url];
      }
      outPath = model.get('outPath');
      if (outPath) {
        updatedModels = docpad.database.findAll({
          outPath: outPath
        });
        updatedModels.remove(model);
        updatedModels.each(function(model) {
          return model.set({
            'mtime': new Date()
          });
        });
        docpad.log('debug', 'Updated mtime for these models due to remove of a similar one', updatedModels.pluck('relativePath'));
      }
      return true;
    }).on('add change:urls', function(model) {
      var j, k, len1, len2, ref5, ref6, url;
      if (model.get('write') === false) {
        return;
      }
      ref5 = model.previous('urls') || [];
      for (j = 0, len1 = ref5.length; j < len1; j++) {
        url = ref5[j];
        delete docpad.filesByUrl[url];
      }
      ref6 = model.get('urls');
      for (k = 0, len2 = ref6.length; k < len2; k++) {
        url = ref6[k];
        docpad.filesByUrl[url] = model.cid;
      }
      return true;
    }).on('add change:outPath', function(model) {
      var base, existingModel, existingModelId, existingModelPath, modelPath, outPath, previousModelId, previousModels, previousOutPath;
      if (model.get('write') === false) {
        return;
      }
      previousOutPath = model.previous('outPath');
      if (previousOutPath) {
        previousModels = docpad.database.findAll({
          outPath: previousOutPath
        });
        previousModels.remove(model);
        previousModels.each(function(model) {
          return model.set({
            'mtime': new Date()
          });
        });
        docpad.log('debug', 'Updated mtime for these models due to addition of a similar one', previousModels.pluck('relativePath'));
        previousModelId = docpad.filesByOutPath[previousOutPath];
        if (previousModelId === model.id) {
          if (previousModels.length) {
            docpad.filesByOutPath[previousOutPath] = previousModelId;
          } else {
            delete docpad.filesByOutPath[previousOutPath];
          }
        }
      }
      if ((outPath = model.get('outPath'))) {
        existingModelId = (base = docpad.filesByOutPath)[outPath] != null ? base[outPath] : base[outPath] = model.id;
        if (existingModelId !== model.id) {
          existingModel = docpad.database.get(existingModelId);
          if (existingModel) {
            modelPath = model.get('fullPath') || (model.get('relativePath') + ':' + model.id);
            existingModelPath = existingModel.get('fullPath') || (existingModel.get('relativePath') + ':' + existingModel.id);
            docpad.warn(util.format(docpad.getLocale().outPathConflict, outPath, modelPath, existingModelPath));
          } else {
            docpad.filesByOutPath[outPath] = model.id;
          }
        }
      }
      return true;
    });
    this.userConfig = extendr.dereference(this.userConfig);
    this.initialConfig = extendr.dereference(this.initialConfig);
    if (instanceConfig.action != null) {
      action = instanceConfig.action;
    } else {
      action = 'load ready';
    }
    if (action) {
      this.action(action, instanceConfig, function(err) {
        if (next != null) {
          return next(err, docpad);
        } else if (err) {
          return docpad.fatal(err);
        }
      });
    } else {
      if (typeof next === "function") {
        next(null, docpad);
      }
    }
    this;
  }


  /**
  	 * Destructor. Destroy the DocPad instance
  	 * This is an action, and should be called as such
  	 * E.g. docpad.action('destroy', next)
  	 * @method destroy
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.destroy = function(opts, next) {
    var docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    docpad.destroyRegenerateTimer();
    docpadUtil.wait(1000, function() {
      return docpad.emitSerial('docpadDestroy', function(err) {
        if (err) {
          return typeof next === "function" ? next(err) : void 0;
        }
        docpad.destroyPlugins();
        docpad.destroyServer();
        docpad.destroyWatchers();
        docpad.destroyBlocks();
        docpad.destroyCollections();
        docpad.destroyDatabase();
        docpad.destroyLoggers();
        process.removeListener('uncaughtException', docpad.error);
        docpad.removeAllListeners();
        return typeof next === "function" ? next() : void 0;
      });
    });
    return this;
  };


  /**
  	 * Emit event, serial
  	 * @private
  	 * @method emitSerial
  	 * @param {String} eventName
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.emitSerial = function(eventName, opts, next) {
    var docpad, locale, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    locale = docpad.getLocale();
    docpad.log('debug', util.format(locale.emittingEvent, eventName));
    DocPad.__super__.emitSerial.call(this, eventName, opts, function(err) {
      if (err) {
        return next(err);
      }
      docpad.log('debug', util.format(locale.emittedEvent, eventName));
      return next(err);
    });
    return this;
  };


  /**
  	 * Emit event, parallel
  	 * @private
  	 * @method emitParallel
  	 * @param {String} eventName
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.emitParallel = function(eventName, opts, next) {
    var docpad, locale, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    locale = docpad.getLocale();
    docpad.log('debug', util.format(locale.emittingEvent, eventName));
    DocPad.__super__.emitParallel.call(this, eventName, opts, function(err) {
      if (err) {
        return next(err);
      }
      docpad.log('debug', util.format(locale.emittedEvent, eventName));
      return next(err);
    });
    return this;
  };


  /**
  	 * Get the ignore options for the DocPad project
  	 * @method getIgnoreOpts
  	 * @return {Array} string array of ignore options
   */

  DocPad.prototype.getIgnoreOpts = function() {
    return pick(this.config, ['ignorePaths', 'ignoreHiddenFiles', 'ignoreCommonPatterns', 'ignoreCustomPatterns']);
  };


  /**
  	 * Is the supplied path ignored?
  	 * @method isIgnoredPath
  	 * @param {String} path
  	 * @param {Object} [opts={}]
  	 * @return {Boolean}
   */

  DocPad.prototype.isIgnoredPath = function(path, opts) {
    if (opts == null) {
      opts = {};
    }
    opts = extendr.extend(this.getIgnoreOpts(), opts);
    return ignorefs.isIgnoredPath(path, opts);
  };


  /**
  	 * Scan directory
  	 * @method scandir
  	 * @param {Object} [opts={}]
   */

  DocPad.prototype.scandir = function(opts) {
    if (opts == null) {
      opts = {};
    }
    opts = extendr.extend(this.getIgnoreOpts(), opts);
    return scandir(opts);
  };


  /**
  	 * Watch Directory. Wrapper around the Bevry watchr
  	 * module (https://github.com/bevry/watchr). Used
  	 * internally by DocPad to watch project documents
  	 * and files and then activate the regeneration process
  	 * when any of those items are updated.
  	 *
  	 * Although it is possible to pass a range of options to watchdir
  	 * in practice these options are provided as part of
  	 * the DocPad config object with a number of default options
  	 * specified in the DocPad config.
  	 * @method watchdir
  	 * @param {Object} [opts={}]
  	 * @param {String} [opts.path] a single path to watch.
  	 * @param {Array} [opts.paths] an array of paths to watch.
  	 * @param {Function} [opts.listener] a single change listener to fire when a change occurs.
  	 * @param {Array} [opts.listeners] an array of listeners.
  	 * @param {Function} [opts.next] callback.
  	 * @param {Object} [opts.stat] a file stat object to use for the path, instead of fetching a new one.
  	 * @param {Number} [opts.interval=5007] for systems that poll to detect file changes, how often should it poll in millseconds.
  	 * @param {Number} [opts.catupDelay=200] handles system swap file deletions and renaming
  	 * @param {Array} [opts.preferredMethods=['watch','watchFile'] which order should we prefer our watching methods to be tried?.
  	 * @param {Boolean} [opts.followLinks=true] follow symlinks, i.e. use stat rather than lstat.
  	 * @param {Boolean|Array} [opts.ignorePaths=false] an array of full paths to ignore.
  	 * @param {Boolean|Array} [opts.ignoreHiddenFiles=false] whether or not to ignored files which filename starts with a ".".
  	 * @param {Boolean} [opts.ignoreCommonPatterns=true] whether or not to ignore common undesirable file patterns (e.g. .svn, .git, .DS_Store, thumbs.db, etc).
  	 * @param {Boolean|Array} [opts.ignoreCustomPatterns=null] any custom ignore patterns that you would also like to ignore along with the common patterns.
  	 * @return {Object} the watcher
   */

  DocPad.prototype.watchdir = function(opts) {
    if (opts == null) {
      opts = {};
    }
    opts = extendr.extend(this.getIgnoreOpts(), opts, this.config.watchOptions);
    return require('watchr').watch(opts);
  };


  /**
  	 * DocPad is ready. Peforms the tasks needed after DocPad construction
  	 * and DocPad has loaded. Triggers the docpadReady event.
  	 * next(err,docpadInstance)
  	 * @private
  	 * @method ready
  	 * @param {Object} [opts]
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.docpadInstance
   */

  DocPad.prototype.ready = function(opts, next) {
    var config, docpad, instanceConfig, locale, pluginName, pluginsList, ref2, tasks;
    ref2 = extractOptsAndCallback(instanceConfig, next), instanceConfig = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    locale = this.getLocale();
    this.DocumentModel.prototype.defaults.renderSingleExtensions = config.renderSingleExtensions;
    this.compareVersion();
    if (this.getDebugging()) {
      pluginsList = ((function() {
        var i, len, ref3, results;
        ref3 = Object.keys(this.loadedPlugins).sort();
        results = [];
        for (i = 0, len = ref3.length; i < len; i++) {
          pluginName = ref3[i];
          results.push(pluginName + " v" + this.loadedPlugins[pluginName].version);
        }
        return results;
      }).call(this)).join(', ');
    } else {
      pluginsList = Object.keys(this.loadedPlugins).sort().join(', ');
    }
    docpad.log('info', util.format(locale.welcome, this.getVersionString()));
    docpad.log('notice', locale.welcomeDonate);
    docpad.log('info', locale.welcomeContribute);
    docpad.log('info', util.format(locale.welcomePlugins, pluginsList));
    docpad.log('info', util.format(locale.welcomeEnvironment, this.getEnvironment()));
    tasks = new this.TaskGroup('ready tasks', {
      next: function(err) {
        if (err) {
          return docpad.error(err);
        }
        return typeof next === "function" ? next(null, docpad) : void 0;
      }
    });
    tasks.addTask('welcome event', function(complete) {
      if (!config.welcome) {
        return complete();
      }
      return docpad.emitSerial('welcome', {
        docpad: docpad
      }, complete);
    });
    tasks.addTask('track', function(complete) {
      return docpad.identify(complete);
    });
    tasks.addTask('emit docpadReady', function(complete) {
      return docpad.emitSerial('docpadReady', {
        docpad: docpad
      }, complete);
    });
    tasks.run();
    return this;
  };


  /**
  	 * Performs the merging of the passed configuration objects
  	 * @private
  	 * @method mergeConfigurations
  	 * @param {Object} configPackages
  	 * @param {Object} configsToMerge
   */

  DocPad.prototype.mergeConfigurations = function(configPackages, configsToMerge) {
    var configPackage, env, envConfig, envs, i, j, len, len1, ref2;
    envs = this.getEnvironments();
    for (i = 0, len = configPackages.length; i < len; i++) {
      configPackage = configPackages[i];
      if (!configPackage) {
        continue;
      }
      configsToMerge.push(configPackage);
      for (j = 0, len1 = envs.length; j < len1; j++) {
        env = envs[j];
        envConfig = (ref2 = configPackage.environments) != null ? ref2[env] : void 0;
        if (envConfig) {
          configsToMerge.push(envConfig);
        }
      }
    }
    extendr.safeDeepExtendPlainObjects.apply(extendr, configsToMerge);
    return this;
  };


  /**
  	 * Set the instance configuration
  	 * by merging the properties of the passed object
  	 * with the existing DocPad instanceConfig object
  	 * @private
  	 * @method setInstanceConfig
  	 * @param {Object} instanceConfig
   */

  DocPad.prototype.setInstanceConfig = function(instanceConfig) {
    var logLevel;
    if (instanceConfig) {
      logLevel = this.getLogLevel();
      extendr.safeDeepExtendPlainObjects(this.instanceConfig, instanceConfig);
      if (this.config) {
        extendr.safeDeepExtendPlainObjects(this.config, instanceConfig);
      }
      if (instanceConfig.logLevel && instanceConfig.logLevel !== logLevel) {
        this.setLogLevel(instanceConfig.logLevel);
      }
    }
    return this;
  };


  /**
  	 * Set the DocPad configuration object.
  	 * Performs a number of tasks, including
  	 * merging the pass instanceConfig with DocPad's
  	 * other config objects.
  	 * next(err,config)
  	 * @private
  	 * @method setConfig
  	 * @param {Object} instanceConfig
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @param {Object} next.config
   */

  DocPad.prototype.setConfig = function(instanceConfig, next) {
    var configPackages, configsToMerge, docpad, i, j, k, key, l, len, len1, len2, len3, locale, postTasks, ref2, ref3, ref4, type, typePath, typePaths;
    ref2 = extractOptsAndCallback(instanceConfig, next), instanceConfig = ref2[0], next = ref2[1];
    docpad = this;
    locale = this.getLocale();
    if (instanceConfig) {
      this.setInstanceConfig(instanceConfig);
    }
    this.config.env = this.instanceConfig.env || this.websiteConfig.env || this.initialConfig.env || process.env.NODE_ENV;
    configPackages = [this.initialConfig, this.userConfig, this.websiteConfig, this.instanceConfig];
    configsToMerge = [this.config];
    docpad.mergeConfigurations(configPackages, configsToMerge);
    this.setServer(extendr.safeShallowExtendPlainObjects({
      serverHttp: this.config.serverHttp,
      serverExpress: this.config.serverExpress
    }, this.config.server));
    this.setLogLevel(this.config.logLevel);
    this.config.rootPath = pathUtil.resolve(this.config.rootPath);
    this.config.outPath = pathUtil.resolve(this.config.rootPath, this.config.outPath);
    this.config.srcPath = pathUtil.resolve(this.config.rootPath, this.config.srcPath);
    this.config.databaseCachePath = pathUtil.resolve(this.config.rootPath, this.config.databaseCachePath);
    this.config.packagePath = pathUtil.resolve(this.config.rootPath, this.config.packagePath);
    ref3 = ['documents', 'files', 'layouts'];
    for (i = 0, len = ref3.length; i < len; i++) {
      type = ref3[i];
      typePaths = this.config[type + 'Paths'];
      for (key = j = 0, len1 = typePaths.length; j < len1; key = ++j) {
        typePath = typePaths[key];
        typePaths[key] = pathUtil.resolve(this.config.srcPath, typePath);
      }
    }
    ref4 = ['plugins'];
    for (k = 0, len2 = ref4.length; k < len2; k++) {
      type = ref4[k];
      typePaths = this.config[type + 'Paths'];
      for (key = l = 0, len3 = typePaths.length; l < len3; key = ++l) {
        typePath = typePaths[key];
        typePaths[key] = pathUtil.resolve(this.config.rootPath, typePath);
      }
    }
    process.removeListener('uncaughtException', this.error);
    this.removeListener('error', this.error);
    if (this.config.catchExceptions) {
      process.setMaxListeners(0);
      process.on('uncaughtException', this.error);
      this.on('error', this.error);
    }
    postTasks = new this.TaskGroup('setConfig post tasks', {
      next: function(err) {
        return next(err, docpad.config);
      }

      /*
      		postTasks.addTask 'lazy depedencnies: encoding', (complete) =>
      			return complete()  unless @config.detectEncoding
      			return lazyRequire 'encoding', {cwd:corePath, stdio:'inherit'}, (err) ->
      				docpad.warn(locale.encodingLoadFailed)  if err
      				return complete()
       */
    });
    postTasks.addTask('load plugins', function(complete) {
      return docpad.loadPlugins(complete);
    });
    postTasks.addTask('extend collections', function(complete) {
      return docpad.extendCollections(complete);
    });
    postTasks.addTask('fetch plugins templateData', function(complete) {
      return docpad.emitSerial('extendTemplateData', {
        templateData: docpad.pluginsTemplateData
      }, complete);
    });
    postTasks.addTask('fire the docpadLoaded event', function(complete) {
      return docpad.emitSerial('docpadLoaded', complete);
    });
    postTasks.run();
    return this;
  };


  /**
  	 * Load the various configuration files from the
  	 * file system. Set the instanceConfig.
  	 * next(err,config)
  	 * @private
  	 * @method load
  	 * @param {Object} instanceConfig
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.config
   */

  DocPad.prototype.load = function(instanceConfig, next) {
    var docpad, locale, preTasks, ref2;
    ref2 = extractOptsAndCallback(instanceConfig, next), instanceConfig = ref2[0], next = ref2[1];
    docpad = this;
    locale = this.getLocale();
    instanceConfig || (instanceConfig = {});
    this.websitePackageConfig = {};
    this.websiteConfig = {};
    this.config = {};
    this.setInstanceConfig(instanceConfig);
    preTasks = new this.TaskGroup('load tasks', {
      next: (function(_this) {
        return function(err) {
          if (err) {
            return next(err);
          }
          return _this.setConfig(next);
        };
      })(this)
    });
    preTasks.addTask('normalize the userConfigPath', (function(_this) {
      return function(complete) {
        return safeps.getHomePath(function(err, homePath) {
          var dropboxPath;
          if (err) {
            return complete(err);
          }
          dropboxPath = pathUtil.resolve(homePath, 'Dropbox');
          return safefs.exists(dropboxPath, function(dropboxPathExists) {
            var userConfigDirPath;
            userConfigDirPath = dropboxPathExists ? dropboxPath : homePath;
            _this.userConfigPath = pathUtil.resolve(userConfigDirPath, _this.userConfigPath);
            return complete();
          });
        });
      };
    })(this));
    preTasks.addTask("load the user's configuration", (function(_this) {
      return function(complete) {
        var configPath;
        configPath = _this.userConfigPath;
        docpad.log('debug', util.format(locale.loadingUserConfig, configPath));
        return _this.loadConfigPath({
          configPath: configPath
        }, function(err, data) {
          if (err) {
            return complete(err);
          }
          extendr.extend(_this.userConfig, data || {});
          docpad.log('debug', util.format(locale.loadingUserConfig, configPath));
          return complete();
        });
      };
    })(this));
    preTasks.addTask("load the anonymous user's configuration", (function(_this) {
      return function(complete) {
        if (_this.userConfig.username) {
          return complete();
        }
        return require('getmac').getMac(function(err, macAddress) {
          var base, base1, error, macAddressHash;
          if (err || !macAddress) {
            docpad.warn(locale.macError, err);
            return complete();
          }
          try {
            macAddressHash = require('crypto').createHmac('sha1', docpad.hashKey).update(macAddress).digest('hex');
          } catch (error) {
            err = error;
            if (err) {
              return complete();
            }
          }
          if (macAddressHash) {
            if ((base = _this.userConfig).name == null) {
              base.name = "MAC " + macAddressHash;
            }
            if ((base1 = _this.userConfig).username == null) {
              base1.username = macAddressHash;
            }
          }
          return complete();
        });
      };
    })(this));
    preTasks.addTask("load the website's package data", (function(_this) {
      return function(complete) {
        var configPath, rootPath;
        rootPath = pathUtil.resolve(_this.instanceConfig.rootPath || _this.initialConfig.rootPath);
        configPath = pathUtil.resolve(rootPath, _this.instanceConfig.packagePath || _this.initialConfig.packagePath);
        docpad.log('debug', util.format(locale.loadingWebsitePackageConfig, configPath));
        return _this.loadConfigPath({
          configPath: configPath
        }, function(err, data) {
          if (err) {
            return complete(err);
          }
          data || (data = {});
          _this.websitePackageConfig = data;
          docpad.log('debug', util.format(locale.loadedWebsitePackageConfig, configPath));
          return complete();
        });
      };
    })(this));
    preTasks.addTask("read the .env file if it exists", (function(_this) {
      return function(complete) {
        var configPath, rootPath;
        rootPath = pathUtil.resolve(_this.instanceConfig.rootPath || _this.websitePackageConfig.rootPath || _this.initialConfig.rootPath);
        configPath = pathUtil.resolve(rootPath, '.env');
        docpad.log('debug', util.format(locale.loadingEnvConfig, configPath));
        return safefs.exists(configPath, function(exists) {
          if (!exists) {
            return complete();
          }
          return require('envfile').parseFile(configPath, function(err, data) {
            var key, value;
            if (err) {
              return complete(err);
            }
            for (key in data) {
              if (!hasProp.call(data, key)) continue;
              value = data[key];
              process.env[key] = value;
            }
            docpad.log('debug', util.format(locale.loadingEnvConfig, configPath));
            return complete();
          });
        });
      };
    })(this));
    preTasks.addTask("load the website's configuration", (function(_this) {
      return function(complete) {
        var configPath, configPaths, i, index, len, rootPath;
        docpad.log('debug', util.format(locale.loadingWebsiteConfig));
        rootPath = pathUtil.resolve(_this.instanceConfig.rootPath || _this.initialConfig.rootPath);
        configPaths = _this.instanceConfig.configPaths || _this.initialConfig.configPaths;
        for (index = i = 0, len = configPaths.length; i < len; index = ++i) {
          configPath = configPaths[index];
          configPaths[index] = pathUtil.resolve(rootPath, configPath);
        }
        return _this.loadConfigPath({
          configPaths: configPaths
        }, function(err, data) {
          if (err) {
            return complete(err);
          }
          data || (data = {});
          extendr.extend(_this.websiteConfig, data);
          docpad.log('debug', util.format(locale.loadedWebsiteConfig));
          return complete();
        });
      };
    })(this));
    preTasks.run();
    return this;
  };


  /**
  	 * Update user configuration with the passed data
  	 * @method updateUserConfig
  	 * @param {Object} [data={}]
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.updateUserConfig = function(data, next) {
    var docpad, ref2, userConfigPath;
    if (data == null) {
      data = {};
    }
    ref2 = extractOptsAndCallback(data, next), data = ref2[0], next = ref2[1];
    docpad = this;
    userConfigPath = this.userConfigPath;
    if (data) {
      extendr.extend(this.userConfig, data);
    }
    CSON.createCSONString(this.userConfig, function(err, userConfigString) {
      if (err) {
        err.context = "Failed to create the CSON string for the user configuration";
        return next(err);
      }
      return safefs.writeFile(userConfigPath, userConfigString, 'utf8', function(err) {
        return next(err);
      });
    });
    return this;
  };


  /**
  	 * Load a configuration url.
  	 * @method loadConfigUrl
  	 * @param {String} configUrl
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.parsedData
   */

  DocPad.prototype.loadConfigUrl = function(configUrl, next) {
    var docpad, locale;
    docpad = this;
    locale = this.getLocale();
    docpad.log('debug', util.format(locale.loadingConfigUrl, configUrl));
    superAgent.get(configUrl).timeout(30 * 1000).end(function(err, res) {
      if (err) {
        return next(err);
      }
      return CSON.parseCSONString(res.text, next);
    });
    return this;
  };


  /**
  	 * Load the configuration from a file path
  	 * passed as one of the options (opts.configPath) or
  	 * from DocPad's configPaths
  	 * @private
  	 * @method loadConfigPath
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.parsedData
   */

  DocPad.prototype.loadConfigPath = function(opts, next) {
    var docpad, load, locale, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    locale = this.getLocale();
    load = function(configPath) {
      if (!configPath) {
        return next();
      }
      docpad.log('debug', util.format(locale.loadingConfigPath, configPath));
      return safefs.exists(configPath, function(exists) {
        var csonOptions;
        if (!exists) {
          return next();
        }
        csonOptions = {
          cson: true,
          json: true,
          coffeescript: true,
          javascript: true
        };
        return CSON.requireFile(configPath, csonOptions, function(err, data) {
          var error;
          if (err) {
            err.context = util.format(locale.loadingConfigPathFailed, configPath);
            return next(err);
          }
          while (typeChecker.isFunction(data)) {
            try {
              data = data(docpad);
            } catch (error) {
              err = error;
              return next(err);
            }
          }
          if (!typeChecker.isObject(data)) {
            err = new Error("Loading the configuration " + (docpad.inspector(configPath)) + " returned an invalid result " + (docpad.inspector(data)));
            if (err) {
              return next(err);
            }
          }
          return next(null, data);
        });
      });
    };
    if (opts.configPath) {
      load(opts.configPath);
    } else {
      this.getConfigPath(opts, function(err, configPath) {
        return load(configPath);
      });
    }
    return this;
  };


  /**
  	 * Get config paths and check that those
  	 * paths exist
  	 * @private
  	 * @method getConfigPath
  	 * @param {Object} opts
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @param {String} next.path
   */

  DocPad.prototype.getConfigPath = function(opts, next) {
    var config, docpad, ref2, result, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    result = null;
    if (opts.configPaths == null) {
      opts.configPaths = config.configPaths;
    }
    if (!typeChecker.isArray(opts.configPaths)) {
      opts.configPaths = [opts.configPaths];
    }
    tasks = new this.TaskGroup('getConfigPath tasks', {
      next: function(err) {
        return next(err, result);
      }
    });
    opts.configPaths.forEach(function(configPath) {
      return tasks.addTask("Checking if [" + configPath + "] exists", function(complete) {
        if (result) {
          return complete();
        }
        return safefs.exists(configPath, function(exists) {
          if (exists) {
            result = configPath;
            tasks.clear();
            return complete();
          } else {
            return complete();
          }
        });
      });
    });
    tasks.run();
    return this;
  };


  /**
  	 * Extend collecitons. Create DocPad's
  	 * standard (documents, files
  	 * layouts) and special (generate, referencesOthers,
  	 * hasLayout, html, stylesheet) collections. Set blocks
  	 * @private
  	 * @method extendCollections
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.extendCollections = function(next) {
    var database, docpad, docpadConfig, locale, tasks;
    docpad = this;
    docpadConfig = this.getConfig();
    locale = this.getLocale();
    database = this.getDatabase();
    this.setCollections({
      documents: database.createLiveChildCollection().setQuery('isDocument', {
        render: true,
        write: true
      }).on('add', function(model) {
        return docpad.log('debug', util.format(locale.addingDocument, model.getFilePath()));
      }),
      files: database.createLiveChildCollection().setQuery('isFile', {
        render: false,
        write: true
      }).on('add', function(model) {
        return docpad.log('debug', util.format(locale.addingFile, model.getFilePath()));
      }),
      layouts: database.createLiveChildCollection().setQuery('isLayout', {
        $or: {
          isLayout: true,
          fullPath: {
            $startsWith: docpadConfig.layoutsPaths
          }
        }
      }).on('add', function(model) {
        docpad.log('debug', util.format(locale.addingLayout, model.getFilePath()));
        return model.setDefaults({
          isLayout: true,
          render: false,
          write: false
        });
      }),
      generate: database.createLiveChildCollection().setQuery('generate', {
        dynamic: false,
        ignored: false
      }).on('add', function(model) {
        return docpad.log('debug', util.format(locale.addingGenerate, model.getFilePath()));
      }),
      referencesOthers: database.createLiveChildCollection().setQuery('referencesOthers', {
        dynamic: false,
        ignored: false,
        referencesOthers: true
      }).on('add', function(model) {
        return docpad.log('debug', util.format(locale.addingReferencesOthers, model.getFilePath()));
      }),
      hasLayout: database.createLiveChildCollection().setQuery('hasLayout', {
        dynamic: false,
        ignored: false,
        layout: {
          $exists: true
        }
      }).on('add', function(model) {
        return docpad.log('debug', util.format(locale.addingHasLayout, model.getFilePath()));
      }),
      html: database.createLiveChildCollection().setQuery('isHTML', {
        write: true,
        outExtension: 'html'
      }).on('add', function(model) {
        return docpad.log('debug', util.format(locale.addingHtml, model.getFilePath()));
      }),
      stylesheet: database.createLiveChildCollection().setQuery('isStylesheet', {
        write: true,
        outExtension: 'css'
      })
    });
    this.setBlocks({
      meta: new MetaCollection(),
      scripts: new ScriptsCollection(),
      styles: new StylesCollection()
    });
    tasks = new this.TaskGroup("extendCollections tasks", {
      concurrency: 0,
      next: function(err) {
        if (err) {
          docpad.error(err);
        }
        return docpad.emitSerial('extendCollections', next);
      }
    });
    eachr(docpadConfig.collections || {}, function(fn, name) {
      var err;
      if (!name || !typeChecker.isString(name)) {
        err = new Error("Inside your DocPad configuration you have a custom collection with an invalid name of: " + (docpad.inspector(name)));
        docpad.error(err);
        return;
      }
      if (!fn || !typeChecker.isFunction(fn)) {
        err = new Error("Inside your DocPad configuration you have a custom collection called " + (docpad.inspector(name)) + " with an invalid method of: " + (docpad.inspector(fn)));
        docpad.error(err);
        return;
      }
      return tasks.addTask("creating the custom collection: " + name, function(complete) {
        return ambi([fn.bind(docpad), fn], database, function(err, collection) {
          if (err) {
            docpad.error(err);
            return complete();
          } else if (!(collection instanceof QueryCollection)) {
            docpad.warn(util.format(locale.errorInvalidCollection, name));
            return complete();
          }
          if (collection) {
            collection.live(true);
          }
          docpad.setCollection(name, collection);
          return complete();
        });
      });
    });
    tasks.run();
    return this;
  };


  /**
  	 * Reset collections. Perform a complete clean of our collections
  	 * @private
  	 * @method resetCollections
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.resetCollections = function(opts, next) {
    var database, docpad, meta, ref2, scripts, styles;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    database = docpad.getDatabase();
    docpad.generated = false;
    database.reset([]);
    meta = this.getBlock('meta').reset([]);
    scripts = this.getBlock('scripts').reset([]);
    styles = this.getBlock('styles').reset([]);
    if (docpad.getConfig().poweredByDocPad !== false) {
      meta.add("<meta name=\"generator\" content=\"DocPad v" + (docpad.getVersion()) + "\" />");
    }
    this.filesByUrl = {};
    this.filesBySelector = {};
    this.filesByOutPath = {};
    next();
    return this;
  };


  /**
  	 * Initialise git repo
  	 * @private
  	 * @method initGitRepo
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.results
   */

  DocPad.prototype.initGitRepo = function(opts, next) {
    var config, docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    if (opts.cwd == null) {
      opts.cwd = config.rootPath;
    }
    if (opts.output == null) {
      opts.output = this.getDebugging();
    }
    safeps.initGitRepo(opts, next);
    return this;
  };


  /**
  	 * Init node modules
  	 * @private
  	 * @method initNodeModules
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.results
   */

  DocPad.prototype.initNodeModules = function(opts, next) {
    var config, docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    if (opts.cwd == null) {
      opts.cwd = config.rootPath;
    }
    if (opts.output == null) {
      opts.output = docpad.getDebugging();
    }
    if (opts.force == null) {
      opts.force = config.offline ? false : true;
    }
    if (opts.args == null) {
      opts.args = [];
    }
    if (config.force) {
      opts.args.push('--force');
    }
    if (config.offline) {
      opts.args.push('--no-registry');
    }
    if (opts.output) {
      docpad.log('info', 'npm install');
    }
    safeps.initNodeModules(opts, next);
    return this;
  };


  /**
  	 * Fix node package versions
  	 * Combat to https://github.com/npm/npm/issues/4587#issuecomment-35370453
  	 * @private
  	 * @method fixNodePackageVersions
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.fixNodePackageVersions = function(opts, next) {
    var config, docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    if (opts.packagePath == null) {
      opts.packagePath = config.packagePath;
    }
    safefs.readFile(opts.packagePath, function(err, buffer) {
      var data;
      data = buffer.toString();
      data = data.replace(/("docpad(?:.*?)": ")\^/g, '$1~');
      return safefs.writeFile(opts.packagePath, data, function(err) {
        return next(err);
      });
    });
    return this;
  };


  /**
  	 * Install node module. Same as running
  	 * 'npm install' through the command line
  	 * @private
  	 * @method installNodeModule
  	 * @param {Array} names
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.result
   */

  DocPad.prototype.installNodeModule = function(names, opts, next) {
    var command, config, docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    if (opts.cwd == null) {
      opts.cwd = config.rootPath;
    }
    if (opts.args == null) {
      opts.args = [];
    }
    if (docpad.getDebugging()) {
      if (opts.stdio == null) {
        opts.stdio = 'inherit';
      }
    }
    if (opts.global == null) {
      opts.global = false;
    }
    if (opts.global === true) {
      opts.global = ['--global'];
    }
    if (opts.global && Array.isArray(opts.global) === false) {
      opts.global = [opts.global];
    }
    if (opts.save == null) {
      opts.save = !opts.global;
    }
    if (opts.save === true) {
      opts.save = ['--save'];
    }
    if (opts.save && Array.isArray(opts.save) === false) {
      opts.save = [opts.save];
    }
    command = ['npm', 'install'];
    if (!typeChecker.isArray(names)) {
      names = names.split(/[,\s]+/);
    }
    names.forEach(function(name) {
      if (!name) {
        return;
      }
      if (name.indexOf('@') === -1) {
        name += '@latest';
      }
      return command.push(name);
    });
    command.push.apply(command, opts.args);
    if (config.force) {
      command.push('--force');
    }
    if (config.offline) {
      command.push('--no-registry');
    }
    if (opts.save) {
      command.push.apply(command, opts.save);
    }
    if (opts.global) {
      command.push.apply(command, opts.global);
    }
    if (opts.output) {
      docpad.log('info', command.join(' '));
    }
    safeps.spawn(command, opts, next);
    return this;
  };


  /**
  	 * Uninstall node module. Same as running
  	 * 'npm uninstall' through the command line
  	 * @private
  	 * @method uninstallNodeModule
  	 * @param {Array} names
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.result
   */

  DocPad.prototype.uninstallNodeModule = function(names, opts, next) {
    var command, config, docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    if (opts.cwd == null) {
      opts.cwd = config.rootPath;
    }
    if (opts.output == null) {
      opts.output = docpad.getDebugging();
    }
    if (opts.args == null) {
      opts.args = [];
    }
    if (opts.global == null) {
      opts.global = false;
    }
    if (opts.global === true) {
      opts.global = ['--global'];
    }
    if (opts.global && Array.isArray(opts.global) === false) {
      opts.global = [opts.global];
    }
    if (opts.save == null) {
      opts.save = !opts.global;
    }
    if (opts.save === true) {
      opts.save = ['--save', '--save-dev'];
    }
    if (opts.save && Array.isArray(opts.save) === false) {
      opts.save = [opts.save];
    }
    command = ['npm', 'uninstall'];
    if (!typeChecker.isArray(names)) {
      names = names.split(/[,\s]+/);
    }
    command.push.apply(command, names);
    command.push.apply(command, opts.args);
    if (opts.save) {
      command.push.apply(command, opts.save);
    }
    if (opts.global) {
      command.push.apply(command, opts.global);
    }
    if (opts.output) {
      docpad.log('info', command.join(' '));
    }
    safeps.spawn(command, opts, next);
    return this;
  };


  /**
  	 * Set the log level
  	 * @private
  	 * @method setLogLevel
  	 * @param {Number} level
   */

  DocPad.prototype.setLogLevel = function(level) {
    var loggers;
    this.getLogger().setConfig({
      level: level
    });
    if (level === 7) {
      loggers = this.getLoggers();
      if ((loggers.debug != null) === false) {
        loggers.debug = loggers.logger.pipe(new (require('caterpillar-human').Human)({
          color: false
        })).pipe(require('fs').createWriteStream(this.debugLogPath));
      }
    }
    return this;
  };


  /**
  	 * Get the log level
  	 * @method getLogLevel
  	 * @return {Number} the log level
   */

  DocPad.prototype.getLogLevel = function() {
    return this.getConfig().logLevel;
  };


  /**
  	 * Are we debugging?
  	 * @method getDebugging
  	 * @return {Boolean}
   */

  DocPad.prototype.getDebugging = function() {
    return this.getLogLevel() === 7;
  };


  /**
  	 * Handle a fatal error
  	 * @private
  	 * @method fatal
  	 * @param {Object} err
   */

  DocPad.prototype.fatal = function(err) {
    var config, docpad;
    docpad = this;
    config = this.getConfig();
    if (!err) {
      return this;
    }
    this.error(err);
    docpadUtil.writeError(err);
    this.destroy();
    return this;
  };


  /**
  	 * Inspect. Converts object to JSON string. Wrapper around nodes util.inspect method.
  	 * Can't use the inspect namespace as for some silly reason it destroys everything
  	 * @method inspector
  	 * @param {Object} obj
  	 * @param {Object} opts
  	 * @return {String} JSON string of passed object
   */

  DocPad.prototype.inspector = function(obj, opts) {
    if (opts == null) {
      opts = {};
    }
    if (opts.colors == null) {
      opts.colors = this.getConfig().color;
    }
    return docpadUtil.inspect(obj, opts);
  };


  /**
  	 * Log arguments
  	 * @property {Object} log
  	 * @param {Mixed} args...
   */

  DocPad.prototype.log = function() {
    var args, logger;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    logger = this.getLogger() || console;
    logger.log.apply(logger, args);
    return this;
  };


  /**
  	 * Create an error object
  	 * @method createError
  	 * @param {Object} err
  	 * @param {Object} opts
  	 * @return {Object} the error
   */

  DocPad.prototype.createError = function(err, opts) {
    var key, ref2, ref3, ref4, ref5, ref6, ref7, ref8, value;
    if (opts == null) {
      opts = {};
    }
    if (opts.level == null) {
      opts.level = (ref2 = err.level) != null ? ref2 : 'error';
    }
    if (opts.track == null) {
      opts.track = (ref3 = err.track) != null ? ref3 : true;
    }
    if (opts.tracked == null) {
      opts.tracked = (ref4 = err.tracked) != null ? ref4 : false;
    }
    if (opts.log == null) {
      opts.log = (ref5 = err.log) != null ? ref5 : true;
    }
    if (opts.logged == null) {
      opts.logged = (ref6 = err.logged) != null ? ref6 : false;
    }
    if (opts.notify == null) {
      opts.notify = (ref7 = err.notify) != null ? ref7 : true;
    }
    if (opts.notified == null) {
      opts.notified = (ref8 = err.notified) != null ? ref8 : false;
    }
    if (err.context != null) {
      if (opts.context == null) {
        opts.context = err.context;
      }
    }
    if (!err.stack) {
      err = new Error(err);
    }
    for (key in opts) {
      if (!hasProp.call(opts, key)) continue;
      value = opts[key];
      if (err[key] == null) {
        err[key] = value;
      }
    }
    return err;
  };


  /**
  	 * Create an error (tracks it) and log it
  	 * @method error
  	 * @param {Object} err
  	 * @param {Object} [level='err']
   */

  DocPad.prototype.error = function(err, level) {
    var docpad;
    if (level == null) {
      level = 'err';
    }
    docpad = this;
    err = this.createError(err, {
      level: level
    });
    this.trackError(err);
    this.logError(err);
    this.notifyError(err);
    return this;
  };


  /**
  	 * Log an error
  	 * @method logError
  	 * @param {Object} err
   */

  DocPad.prototype.logError = function(err) {
    var docpad, locale, message, occured, ref2;
    docpad = this;
    locale = this.getLocale();
    if (err && err.log !== false && err.logged !== true) {
      err = this.createError(err, {
        logged: true
      });
      occured = (ref2 = err.level) === 'warn' || ref2 === 'warning' ? locale.warnOccured : locale.errorOccured;
      message = err.context ? err.context + locale.errorFollows : occured;
      message += '\n\n' + err.stack.toString().trim();
      message += '\n\n' + locale.errorSubmission;
      docpad.log(err.level, message);
    }
    return this;
  };


  /**
  	 * Track an error in the background
  	 * @private
  	 * @method trackError
  	 * @param {Object} err
   */

  DocPad.prototype.trackError = function(err) {
    var config, data, docpad;
    docpad = this;
    config = this.getConfig();
    if (err && err.track !== false && err.tracked !== true && config.offline === false && config.reportErrors === true) {
      err = this.createError(err, {
        tracked: true
      });
      data = {};
      data.message = err.message;
      if (err.stack) {
        data.stack = err.stack.toString().trim();
      }
      data.config = config;
      data.env = process.env;
      docpad.track('error', data);
    }
    return this;
  };


  /**
  	 * Notify error
  	 * @private
  	 * @method notifyError
  	 * @param {Object} err
   */

  DocPad.prototype.notifyError = function(err) {
    var docpad, locale, occured, ref2;
    docpad = this;
    locale = this.getLocale();
    if (err.notify !== false && err.notified !== true) {
      err.notified = true;
      occured = (ref2 = err.level) === 'warn' || ref2 === 'warning' ? locale.warnOccured : locale.errorOccured;
      docpad.notify(err.message, {
        title: occured
      });
    }
    return this;
  };


  /**
  	 * Log an error of level 'warn'
  	 * @method warn
  	 * @param {String} message
  	 * @param {Object} err
  	 * @return {Object} description
   */

  DocPad.prototype.warn = function(message, err) {
    if (err) {
      err.context = message;
      err.level = 'warn';
      this.error(err);
    } else {
      err = message instanceof Error ? message : new Error(message);
      err.level = 'warn';
      this.error(err);
    }
    return this;
  };


  /**
  	 * Send a notify event to plugins (like growl)
  	 * @method notify
  	 * @param {String} message
  	 * @param {Object} [opts={}]
   */

  DocPad.prototype.notify = function(message, opts) {
    var docpad;
    if (opts == null) {
      opts = {};
    }
    docpad = this;
    docpad.emitSerial('notify', {
      message: message,
      opts: opts
    }, function(err) {
      if (err) {
        return docpad.error(err);
      }
    });
    return this;
  };


  /**
  	 * Check Request
  	 * @private
  	 * @method checkRequest
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.res
   */

  DocPad.prototype.checkRequest = function(next) {
    if (next == null) {
      next = this.error.bind(this);
    }
    return function(err, res) {
      var ref2, ref3;
      if (err) {
        return next(err, res);
      }
      if (((ref2 = res.body) != null ? ref2.success : void 0) === false || ((ref3 = res.body) != null ? ref3.error : void 0)) {
        err = new Error(res.body.error || 'unknown request error');
        return next(err, res);
      }
      return next(null, res);
    };
  };


  /**
  	 * Subscribe to the DocPad email list.
  	 * @private
  	 * @method subscribe
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.subscribe = function(next) {
    var config, data, err, ref2;
    config = this.getConfig();
    if (config.offline === false) {
      if ((ref2 = this.userConfig) != null ? ref2.email : void 0) {
        data = {};
        data.email = this.userConfig.email;
        data.name = this.userConfig.name || null;
        data.username = this.userConfig.username || null;
        superAgent.post(config.helperUrl).type('json').set('Accept', 'application/json').query({
          method: 'add-subscriber'
        }).send(data).timeout(30 * 1000).end(this.checkRequest(next));
      } else {
        err = new Error('Email not provided');
        if (typeof next === "function") {
          next(err);
        }
      }
    } else {
      if (typeof next === "function") {
        next();
      }
    }
    return this;
  };


  /**
  	 * Track
  	 * @private
  	 * @method track
  	 * @param {String} name
  	 * @param {Object} [things={}]
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.track = function(name, things, next) {
    var config, data, docpad, ref2, trackRunner;
    if (things == null) {
      things = {};
    }
    docpad = this;
    config = this.getConfig();
    if (config.offline === false && config.reportStatistics) {
      data = {};
      data.userId = this.userConfig.username || null;
      data.event = name;
      data.properties = things;
      if ((ref2 = this.websitePackageConfig) != null ? ref2.name : void 0) {
        things.websiteName = this.websitePackageConfig.name;
      }
      things.platform = this.getProcessPlatform();
      things.environment = this.getEnvironment();
      things.version = this.getVersion();
      things.nodeVersion = this.getProcessVersion();
      eachr(docpad.loadedPlugins, function(value, key) {
        return things['plugin-' + key] = value.version || true;
      });
      trackRunner = docpad.getTrackRunner();
      trackRunner.addTask('track task', function(complete) {
        return superAgent.post(config.helperUrl).type('json').set('Accept', 'application/json').query({
          method: 'analytics',
          action: 'track'
        }).send(data).timeout(30 * 1000).end(docpad.checkRequest(function(err) {
          if (typeof next === "function") {
            next(err);
          }
          return complete(err);
        }));
      });
      trackRunner.run();
    } else {
      if (typeof next === "function") {
        next();
      }
    }
    return this;
  };


  /**
  	 * Identify DocPad user
  	 * @private
  	 * @method identify
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.identify = function(next) {
    var config, data, docpad, now, ref2, things;
    docpad = this;
    config = this.getConfig();
    if (config.offline === false && config.reportStatistics && ((ref2 = this.userConfig) != null ? ref2.username : void 0)) {
      data = {};
      data.userId = this.userConfig.username;
      data.traits = things = {};
      now = new Date();
      things.username = this.userConfig.username;
      things.email = this.userConfig.email || null;
      things.name = this.userConfig.name || null;
      things.lastLogin = now.toISOString();
      things.lastSeen = now.toISOString();
      things.countryCode = safeps.getCountryCode();
      things.languageCode = safeps.getLanguageCode();
      things.platform = this.getProcessPlatform();
      things.version = this.getVersion();
      things.nodeVersion = this.getProcessVersion();
      if (docpad.userConfig.identified !== true) {
        things.created = now.toISOString();
        docpad.getTrackRunner().addTask('create new user', function(complete) {
          return superAgent.post(config.helperUrl).type('json').set('Accept', 'application/json').query({
            method: 'analytics',
            action: 'identify'
          }).send(data).timeout(30 * 1000).end(docpad.checkRequest(function(err) {
            return docpad.updateUserConfig({
              identified: true
            }, complete);
          }));
        });
      } else {
        docpad.getTrackRunner().addTask('update user', function(complete) {
          return superAgent.post(config.helperUrl).type('json').set('Accept', 'application/json').query({
            method: 'analytics',
            action: 'identify'
          }).send(data).timeout(30 * 1000).end(docpad.checkRequest(complete));
        });
      }
    }
    if (typeof next === "function") {
      next();
    }
    return this;
  };


  /**
  	 * Create file model. Calls
  	 * {{#crossLink "DocPad/createModel:method"}}{{/crossLink}}
  	 * with the 'file' modelType.
  	 * @method createFile
  	 * @param {Object} [attrs={}]
  	 * @param {Object} [opts={}]
  	 * @return {Object} FileModel
   */

  DocPad.prototype.createFile = function(attrs, opts) {
    if (attrs == null) {
      attrs = {};
    }
    if (opts == null) {
      opts = {};
    }
    opts.modelType = 'file';
    return this.createModel(attrs, opts);
  };


  /**
  	 * Create document model. Calls
  	 * {{#crossLink "DocPad/createModel:method"}}{{/crossLink}}
  	 * with the 'document' modelType.
  	 * @method createDocument
  	 * @param {Object} [attrs={}]
  	 * @param {Object} [opts={}]
  	 * @return {Object} DocumentModel
   */

  DocPad.prototype.createDocument = function(attrs, opts) {
    if (attrs == null) {
      attrs = {};
    }
    if (opts == null) {
      opts = {};
    }
    opts.modelType = 'document';
    return this.createModel(attrs, opts);
  };


  /**
  	 * Parse the files directory and
  	 * return a files collection to
  	 * the passed callback
  	 * @method parseFileDirectory
  	 * @param {Object} [opts={}]
  	 * @param {Function} next callback
  	 * @param {Error} next.err
  	 * @param {Object} next.files files collection
   */

  DocPad.prototype.parseFileDirectory = function(opts, next) {
    if (opts == null) {
      opts = {};
    }
    if (opts.modelType == null) {
      opts.modelType = 'file';
    }
    if (opts.collection == null) {
      opts.collection = this.getDatabase();
    }
    return this.parseDirectory(opts, next);
  };


  /**
  	 * Parse the documents directory and
  	 * return a documents collection to
  	 * the passed callback.
  	 *
  	 * The partials plugin (https://github.com/docpad/docpad-plugin-partials)
  	 * uses this method to load a collection of
  	 * files from the partials directory.
  	 *
  	 * 	docpad.parseDocumentDirectory({path: config.partialsPath}, next)
  	 *
  	 * @method parseDocumentDirectory
  	 * @param {Object} [opts={}]
  	 * @param {String} [opts.modelType='document']
  	 * @param {Object} [opts.collection=docpad.database]
  	 * @param {Object} [opts.path]
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.files files collection of documents
   */

  DocPad.prototype.parseDocumentDirectory = function(opts, next) {
    if (opts == null) {
      opts = {};
    }
    if (opts.modelType == null) {
      opts.modelType = 'document';
    }
    if (opts.collection == null) {
      opts.collection = this.getDatabase();
    }
    return this.parseDirectory(opts, next);
  };


  /**
  	 * Attach events to a document model.
  	 * @private
  	 * @method attachModelEvents
  	 * @param {Object} model
   */

  DocPad.prototype.attachModelEvents = function(model) {
    var docpad;
    docpad = this;
    if (model.attachedDocumentEvents !== true) {
      model.attachedDocumentEvents = true;
      if (model.type === 'document') {
        model.on('clone', function(clonedModel) {
          return docpad.attachModelEvents(clonedModel);
        });
        model.on('render', function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return docpad.emitSerial.apply(docpad, ['render'].concat(slice.call(args)));
        });
        model.on('renderDocument', function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return docpad.emitSerial.apply(docpad, ['renderDocument'].concat(slice.call(args)));
        });
        model.on('getLayout', function(opts, next) {
          var layout;
          if (opts == null) {
            opts = {};
          }
          opts.collection = docpad.getCollection('layouts');
          layout = docpad.getFileBySelector(opts.selector, opts);
          return next(null, {
            layout: layout
          });
        });
      }
      model.on('error', function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return docpad.error.apply(docpad, args);
      });
      model.on('log', function() {
        var args, ref2, ref3;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (args.length === 2) {
          if ((ref2 = args[0]) === 'err' || ref2 === 'error') {
            docpad.error(args[1]);
            return;
          }
          if ((ref3 = args[0]) === 'warn' || ref3 === 'warning') {
            docpad.warn(args[1]);
            return;
          }
        }
        return docpad.log.apply(docpad, args);
      });
    }
    return this;
  };


  /**
  	 * Add supplied model to the DocPad database. If the passed
  	 * model definition is a plain object of properties, a new
  	 * model will be created prior to adding to the database.
  	 * Calls {{#crossLink "DocPad/createModel:method"}}{{/crossLink}}
  	 * before adding the model to the database.
  	 *
  	 *	# Override the stat's mtime to now
  	 *	# This is because renames will not update the mtime
  	 *	fileCurrentStat?.mtime = new Date()
  	 *
  	 *	# Create the file object
  	 *	file = docpad.addModel({fullPath:filePath, stat:fileCurrentStat})
  	 *
  	 * @method addModel
  	 * @param {Object} model either a plain object defining the required properties, in particular
  	 * the file path or an actual model object
  	 * @param {Object} opts
  	 * @return {Object} the model
   */

  DocPad.prototype.addModel = function(model, opts) {
    model = this.createModel(model, opts);
    this.getDatabase().add(model);
    return model;
  };


  /**
  	 * Add the supplied collection of models to the DocPad database.
  	 * Calls {{#crossLink "DocPad/createModels:method"}}{{/crossLink}}
  	 * before adding the models to the database.
  	 *
  	 * 	databaseData = JSON.parse data.toString()
  	 *	models = docpad.addModels(databaseData.models)
  	 *
  	 * @method addModels
  	 * @param {Object} models DocPad collection of models
  	 * @param {Object} opts
  	 * @return {Object} the models
   */

  DocPad.prototype.addModels = function(models, opts) {
    models = this.createModels(models, opts);
    this.getDatabase().add(models);
    return models;
  };


  /**
  	 * Create a collection of models from the supplied collection
  	 * ensuring that the collection is suitable for adding to the
  	 * DocPad database. The method calls {{#crossLink "DocPad/createModel"}}{{/crossLink}}
  	 * for each model in the models array.
  	 * @private
  	 * @method createModels
  	 * @param {Object} models DocPad collection of models
  	 * @param {Object} opts
  	 * @return {Object} the models
   */

  DocPad.prototype.createModels = function(models, opts) {
    var i, len, model, results;
    results = [];
    for (i = 0, len = models.length; i < len; i++) {
      model = models[i];
      results.push(this.createModel(model, opts));
    }
    return results;
  };


  /**
  	 * Creates either a file or document model.
  	 * The model type to be created can be passed
  	 * as an opts property, if not, the method will
  	 * attempt to determing the model type by checking
  	 * if the file is in one of the documents or
  	 * layout paths.
  	 *
  	 * Ensures a duplicate model is not created
  	 * and all required attributes are present and
  	 * events attached.
  	 *
  	 * Generally it is not necessary for an application
  	 * to manually create a model via creatModel as DocPad
  	 * will handle this process when watching a project's
  	 * file and document directories. However, it is possible
  	 * that a plugin might have a requirement to do so.
  	 *
  	 * 	model = @docpad.createModel({fullPath:fullPath})
      *   model.load()
      *   @docpad.getDatabase().add(model)
  	 *
  	 * @method createModel
  	 * @param {Object} [attrs={}]
  	 * @param {String} attrs.fullPath the full path to the file
  	 * @param {Object} [opts={}]
  	 * @param {String} opts.modelType either 'file' or 'document'
  	 * @return {Object} the file or document model
   */

  DocPad.prototype.createModel = function(attrs, opts) {
    var config, database, dirPath, docpad, fileFullPath, i, j, len, len1, model, ref2, ref3, result;
    if (attrs == null) {
      attrs = {};
    }
    if (opts == null) {
      opts = {};
    }
    if (attrs instanceof FileModel) {
      return attrs;
    }
    docpad = this;
    config = this.getConfig();
    database = this.getDatabase();
    fileFullPath = attrs.fullPath || null;
    if (attrs.fullPath) {
      result = database.findOne({
        fullPath: attrs.fullPath
      });
      if (result) {
        return result;
      }
    }
    if (fileFullPath) {
      if (!opts.modelType) {
        ref2 = config.documentsPaths.concat(config.layoutsPaths);
        for (i = 0, len = ref2.length; i < len; i++) {
          dirPath = ref2[i];
          if (fileFullPath.indexOf(dirPath) === 0) {
            attrs.relativePath || (attrs.relativePath = fileFullPath.replace(dirPath, '').replace(/^[\/\\]/, ''));
            opts.modelType = 'document';
            break;
          }
        }
      }
      if (!opts.modelType) {
        ref3 = config.filesPaths;
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          dirPath = ref3[j];
          if (fileFullPath.indexOf(dirPath) === 0) {
            attrs.relativePath || (attrs.relativePath = fileFullPath.replace(dirPath, '').replace(/^[\/\\]/, ''));
            opts.modelType = 'file';
            break;
          }
        }
      }
    }
    opts = extendr.extend({
      detectEncoding: config.detectEncoding,
      rootOutDirPath: config.outPath,
      locale: this.getLocale(),
      TaskGroup: this.TaskGroup
    }, opts);
    if (opts.modelType === 'file') {
      model = new FileModel(attrs, opts);
    } else {
      model = new DocumentModel(attrs, opts);
    }
    this.attachModelEvents(model);
    return model;
  };


  /**
  	 * Parse a directory and return a
  	 * files collection
  	 * @method parseDirectory
  	 * @param {Object} [opts={}]
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @param {Object} next.files files collection
   */

  DocPad.prototype.parseDirectory = function(opts, next) {
    var createFunction, docpad, files, locale, path, ref2;
    if (opts == null) {
      opts = {};
    }
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    locale = this.getLocale();
    path = opts.path, createFunction = opts.createFunction;
    if (createFunction == null) {
      createFunction = this.createModel;
    }
    files = opts.collection || new FilesCollection();
    safefs.exists(path, function(exists) {
      if (!exists) {
        docpad.log('debug', util.format(locale.renderDirectoryNonexistant, path));
        return next();
      }
      docpad.log('debug', util.format(locale.renderDirectoryParsing, path));
      return docpad.scandir({
        path: path,
        fileAction: function(fileFullPath, fileRelativePath, nextFile, fileStat) {
          var data, file;
          data = {
            fullPath: fileFullPath,
            relativePath: fileRelativePath,
            stat: fileStat
          };
          file = createFunction.call(docpad, data, opts);
          return file.action('load', function(err) {
            if (err) {
              return nextFile(err);
            }
            files.add(file);
            return nextFile();
          });
        },
        next: function(err) {
          if (err) {
            return next(err);
          }
          docpad.log('debug', util.format(locale.renderDirectoryParsed, path));
          return next(null, files);
        }
      });
    });
    return this;
  };


  /**
  	 * Get a plugin by it's name
  	 * @method getPlugin
  	 * @param {Object} pluginName
  	 * @return {Object} a DocPad plugin
   */

  DocPad.prototype.getPlugin = function(pluginName) {
    return this.loadedPlugins[pluginName];
  };


  /**
  	 * Check if we have any plugins
  	 * @method hasPlugins
  	 * @return {Boolean}
   */

  DocPad.prototype.hasPlugins = function() {
    return typeChecker.isEmptyObject(this.loadedPlugins) === false;
  };


  /**
  	 * Destructor. Destroy plugins
  	 * @private
  	 * @method destroyPlugins
   */

  DocPad.prototype.destroyPlugins = function() {
    var name, plugin, ref2;
    ref2 = this.loadedPlugins;
    for (name in ref2) {
      if (!hasProp.call(ref2, name)) continue;
      plugin = ref2[name];
      plugin.destroy();
      this.loadedPlugins[name] = null;
    }
    return this;
  };


  /**
  	 * Load plugins from the file system
  	 * next(err)
  	 * @private
  	 * @method loadPlugins
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.loadPlugins = function(next) {
    var docpad, locale, snore, tasks;
    docpad = this;
    locale = this.getLocale();
    this.slowPlugins = {};
    snore = balUtil.createSnore(function() {
      return docpad.log('notice', util.format(locale.pluginsSlow, Object.keys(docpad.slowPlugins).join(', ')));
    });
    tasks = new this.TaskGroup("loadPlugins tasks", {
      concurrency: 0,
      next: function(err) {
        docpad.slowPlugins = {};
        snore.clear();
        return next(err);
      }
    });
    (this.config.pluginsPaths || []).forEach(function(pluginsPath) {
      return tasks.addTask("load the website's plugins at: " + pluginsPath, function(complete) {
        return safefs.exists(pluginsPath, function(exists) {
          if (!exists) {
            return complete();
          }
          return docpad.loadPluginsIn(pluginsPath, complete);
        });
      });
    });
    (this.config.pluginPaths || []).forEach(function(pluginPath) {
      return tasks.addTask("load custom plugins at: " + pluginPath, function(complete) {
        return safefs.exists(pluginPath, function(exists) {
          if (!exists) {
            return complete();
          }
          return docpad.loadPlugin(pluginPath, complete);
        });
      });
    });
    tasks.run();
    return this;
  };


  /**
  	 * Checks if a plugin was loaded succesfully.
  	 * @method loadedPlugin
  	 * @param {String} pluginName
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Boolean} next.loaded
   */

  DocPad.prototype.loadedPlugin = function(pluginName, next) {
    var docpad, loaded;
    docpad = this;
    loaded = docpad.loadedPlugins[pluginName] != null;
    next(null, loaded);
    return this;
  };


  /**
  	 * Load a plugin from its full file path
  	 * _next(err)
  	 * @private
  	 * @method loadPlugin
  	 * @param {String} fileFullPath
  	 * @param {Function} _next
  	 * @param {Error} _next.err
  	 * @return {Object} description
   */

  DocPad.prototype.loadPlugin = function(fileFullPath, _next) {
    var config, docpad, enabled, loader, locale, next, pluginName;
    docpad = this;
    config = this.getConfig();
    locale = this.getLocale();
    next = function(err) {
      delete docpad.slowPlugins[pluginName];
      return _next(err);
    };
    loader = new PluginLoader({
      dirPath: fileFullPath,
      docpad: this,
      BasePlugin: BasePlugin
    });
    pluginName = loader.pluginName;
    enabled = (config.enableUnlistedPlugins && (config.enabledPlugins[pluginName] != null) === false) || config.enabledPlugins[pluginName] === true;
    if (docpad.loadedPlugins[pluginName] != null) {
      docpad.loadedPlugins[pluginName].setConfig();
      return _next();
    }
    docpad.slowPlugins[pluginName] = true;
    if (!enabled) {
      docpad.log('debug', util.format(locale.pluginSkipped, pluginName));
      return next();
    } else {
      docpad.log('debug', util.format(locale.pluginLoading, pluginName));
      loader.exists(function(err, exists) {
        if (err || !exists) {
          return next(err);
        }
        return loader.unsupported(function(err, unsupported) {
          if (err) {
            return next(err);
          }
          if (unsupported) {
            if ((unsupported === 'version-docpad' || unsupported === 'version-plugin') && config.skipUnsupportedPlugins === false) {
              docpad.log('warn', util.format(locale.pluginContinued, pluginName));
            } else {
              if (unsupported === 'type') {
                docpad.log('debug', util.format(locale.pluginSkippedDueTo, pluginName, unsupported));
              } else {
                docpad.log('warn', util.format(locale.pluginSkippedDueTo, pluginName, unsupported));
              }
              return next();
            }
          }
          return loader.load(function(err) {
            if (err) {
              return next(err);
            }
            return loader.create({}, function(err, pluginInstance) {
              if (err) {
                return next(err);
              }
              docpad.loadedPlugins[loader.pluginName] = pluginInstance;
              docpad.log('debug', util.format(locale.pluginLoaded, pluginName));
              return next();
            });
          });
        });
      });
    }
    return this;
  };


  /**
  	 * Load plugins from a directory path
  	 * @private
  	 * @method loadPluginsIn
  	 * @param {String} pluginsPath
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.loadPluginsIn = function(pluginsPath, next) {
    var docpad, locale;
    docpad = this;
    locale = this.getLocale();
    docpad.log('debug', util.format(locale.pluginsLoadingFor, pluginsPath));
    this.scandir({
      path: pluginsPath,
      fileAction: false,
      dirAction: function(fileFullPath, fileRelativePath, nextFile) {
        var pluginName;
        pluginName = pathUtil.basename(fileFullPath);
        if (fileFullPath === pluginsPath) {
          return nextFile(null, false);
        }
        return docpad.loadPlugin(fileFullPath, function(err) {
          if (err) {
            docpad.warn(util.format(locale.pluginFailedToLoad, pluginName, fileFullPath), err);
          }
          return nextFile(null, true);
        });
      },
      next: function(err) {
        docpad.log('debug', util.format(locale.pluginsLoadedFor, pluginsPath));
        return next(err);
      }
    });
    return this;
  };


  /**
  	 * Compare current DocPad version to the latest
  	 * and print out the result to the console.
  	 * Used at startup.
  	 * @private
  	 * @method compareVersion
   */

  DocPad.prototype.compareVersion = function() {
    var config, docpad, locale;
    docpad = this;
    config = this.getConfig();
    locale = this.getLocale();
    if (config.offline || !config.checkVersion) {
      return this;
    }
    balUtil.packageCompare({
      local: this.packagePath,
      remote: config.helperUrl + 'latest',
      newVersionCallback: function(details) {
        var currentVersion, isLocalInstallation, latestVersion, message, messageFilled, upgradeUrl;
        isLocalInstallation = docpadUtil.isLocalDocPadExecutable();
        message = (isLocalInstallation ? locale.versionOutdatedLocal : locale.versionOutdatedGlobal);
        currentVersion = 'v' + details.local.version;
        latestVersion = 'v' + details.remote.version;
        upgradeUrl = details.local.upgradeUrl || details.remote.installUrl || details.remote.homepage;
        messageFilled = util.format(message, currentVersion, latestVersion, upgradeUrl);
        docpad.notify(latestVersion, {
          title: locale.versionOutdatedNotification
        });
        return docpad.log('notice', messageFilled);
      }
    });
    return this;
  };


  /**
  	 * Get DocPad's exchange data
  	 * Requires internet access
  	 * next(err,exchange)
  	 * @private
  	 * @method getExchange
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.exchange docpad.exchange
   */

  DocPad.prototype.getExchange = function(next) {
    var config, docpad, exchangeUrl, locale;
    docpad = this;
    config = this.getConfig();
    locale = this.getLocale();
    if (typeChecker.isEmptyObject(docpad.exchange) === false) {
      return next(null, docpad.exchange);
    }
    if (config.offline) {
      return next(null, null);
    }
    docpad.log('info', locale.exchangeUpdate + ' ' + locale.pleaseWait);
    exchangeUrl = config.helperUrl + '?method=exchange&version=' + this.version;
    docpad.loadConfigUrl(exchangeUrl, function(err, parsedData) {
      if (err) {
        locale = docpad.getLocale();
        docpad.warn(locale.exchangeError, err);
        return next();
      }
      docpad.log('info', locale.exchangeUpdated);
      docpad.exchange = parsedData;
      return next(null, parsedData);
    });
    return this;
  };


  /**
  	 * Contextualize files.
  	 * Contextualizing is the process of adding layouts and
  	 * awareness of other documents to our document. The
  	 * contextualizeBefore and contextualizeAfter events
  	 * are emitted here.
  	 * @private
  	 * @method contextualizeFiles
  	 * @param {Object} [opts={}]
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.contextualizeFiles = function(opts, next) {
    var collection, config, docpad, locale, ref2, ref3, slowFilesObject, slowFilesTimer, templateData;
    if (opts == null) {
      opts = {};
    }
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    collection = opts.collection, templateData = opts.templateData;
    docpad = this;
    config = this.getConfig();
    locale = this.getLocale();
    slowFilesObject = {};
    slowFilesTimer = null;
    if ((ref3 = opts.progress) != null) {
      ref3.step("contextualizeFiles (preparing)").total(1).setTick(0);
    }
    docpad.log('debug', util.format(locale.contextualizingFiles, collection.length));
    docpad.emitSerial('contextualizeBefore', {
      collection: collection,
      templateData: templateData
    }, function(err) {
      var ref4, tasks;
      if (err) {
        return next(err);
      }
      tasks = new docpad.TaskGroup("contextualizeFiles tasks", {
        concurrency: 0,
        next: function(err) {
          var ref4;
          clearInterval(slowFilesTimer);
          slowFilesTimer = null;
          if (err) {
            return next(err);
          }
          if ((ref4 = opts.progress) != null) {
            ref4.step("contextualizeFiles (postparing)").total(1).setTick(0);
          }
          return docpad.emitSerial('contextualizeAfter', {
            collection: collection
          }, function(err) {
            if (err) {
              return next(err);
            }
            docpad.log('debug', util.format(locale.contextualizedFiles, collection.length));
            return next();
          });
        }
      });
      if ((ref4 = opts.progress) != null) {
        ref4.step('contextualizeFiles').total(collection.length).setTick(0);
      }
      collection.forEach(function(file, index) {
        var filePath;
        filePath = file.getFilePath();
        slowFilesObject[file.id] = file.get('relativePath') || file.id;
        return tasks.addTask("conextualizing: " + filePath, function(complete) {
          return file.action('contextualize', function(err) {
            var ref5;
            delete slowFilesObject[file.id];
            if ((ref5 = opts.progress) != null) {
              ref5.tick();
            }
            return complete(err);
          });
        });
      });
      slowFilesTimer = setInterval(function() {
        var key, slowFilesArray, value;
        slowFilesArray = (function() {
          var results;
          results = [];
          for (key in slowFilesObject) {
            if (!hasProp.call(slowFilesObject, key)) continue;
            value = slowFilesObject[key];
            results.push(value || key);
          }
          return results;
        })();
        return docpad.log('info', util.format(locale.slowFiles, 'contextualizeFiles') + ' \n' + slowFilesArray.join('\n'));
      }, config.slowFilesDelay);
      return tasks.run();
    });
    return this;
  };


  /**
  	 * Render the DocPad project's files.
  	 * The renderCollectionBefore, renderCollectionAfter,
  	 * renderBefore, renderAfter events are all emitted here.
  	 * @private
  	 * @method renderFiles
  	 * @param {Object} [opts={}]
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.renderFiles = function(opts, next) {
    var collection, config, docpad, locale, ref2, ref3, renderCollection, renderFile, renderPasses, slowFilesObject, slowFilesTimer, templateData;
    if (opts == null) {
      opts = {};
    }
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    collection = opts.collection, templateData = opts.templateData, renderPasses = opts.renderPasses;
    docpad = this;
    config = this.getConfig();
    locale = this.getLocale();
    slowFilesObject = {};
    slowFilesTimer = null;
    if ((ref3 = opts.progress) != null) {
      ref3.step("renderFiles (preparing)").total(1).setTick(0);
    }
    docpad.log('debug', util.format(locale.renderingFiles, collection.length));
    renderFile = function(file, next) {
      if (file.get('render') === false || !file.get('relativePath')) {
        file.attributes.rtime = new Date();
        next(null, file.getOutContent(), file);
      } else {
        file.action('render', {
          templateData: templateData
        }, next);
      }
      return file;
    };
    renderCollection = function(collectionToRender, arg, next) {
      var renderPass;
      renderPass = arg.renderPass;
      return docpad.emitSerial('renderCollectionBefore', {
        collection: collectionToRender,
        renderPass: renderPass
      }, function(err) {
        var ref4, subTasks;
        if (err) {
          return next(err);
        }
        subTasks = new docpad.TaskGroup("renderCollection: " + collectionToRender.options.name, {
          concurrency: 0,
          next: function(err) {
            if (err) {
              return next(err);
            }
            return docpad.emitSerial('renderCollectionAfter', {
              collection: collectionToRender,
              renderPass: renderPass
            }, next);
          }
        });
        if ((ref4 = opts.progress) != null) {
          ref4.step("renderFiles (pass " + renderPass + ")").total(collectionToRender.length).setTick(0);
        }
        collectionToRender.forEach(function(file) {
          var filePath;
          filePath = file.getFilePath();
          slowFilesObject[file.id] = file.get('relativePath');
          return subTasks.addTask("rendering: " + filePath, function(complete) {
            return renderFile(file, function(err) {
              var ref5;
              delete slowFilesObject[file.id] || file.id;
              if ((ref5 = opts.progress) != null) {
                ref5.tick();
              }
              return complete(err);
            });
          });
        });
        subTasks.run();
        return collectionToRender;
      });
    };
    docpad.emitSerial('renderBefore', {
      collection: collection,
      templateData: templateData
    }, function(err) {
      var i, initialCollection, results, subsequentCollection, tasks;
      if (err) {
        return next(err);
      }
      tasks = new docpad.TaskGroup("renderCollection: renderBefore tasks", {
        next: function(err) {
          var ref4;
          clearInterval(slowFilesTimer);
          slowFilesTimer = null;
          if (err) {
            return next(err);
          }
          if ((ref4 = opts.progress) != null) {
            ref4.step("renderFiles (postparing)").total(1).setTick(0);
          }
          return docpad.emitSerial('renderAfter', {
            collection: collection
          }, function(err) {
            if (err) {
              return next(err);
            }
            docpad.log('debug', util.format(locale.renderedFiles, collection.length));
            return next();
          });
        }
      });
      initialCollection = collection.findAll({
        'referencesOthers': false
      });
      subsequentCollection = null;
      tasks.addTask("rendering the initial collection", function(complete) {
        return renderCollection(initialCollection, {
          renderPass: 1
        }, function(err) {
          if (err) {
            return complete(err);
          }
          subsequentCollection = collection.findAll({
            'referencesOthers': true
          });
          return renderCollection(subsequentCollection, {
            renderPass: 2
          }, complete);
        });
      });
      if (renderPasses > 1) {
        (function() {
          results = [];
          for (var i = 3; 3 <= renderPasses ? i <= renderPasses : i >= renderPasses; 3 <= renderPasses ? i++ : i--){ results.push(i); }
          return results;
        }).apply(this).forEach(function(renderPass) {
          return tasks.addTask("rendering the subsequent collection index " + renderPass, function(complete) {
            return renderCollection(subsequentCollection, {
              renderPass: renderPass
            }, complete);
          });
        });
      }
      slowFilesTimer = setInterval(function() {
        var key, slowFilesArray, value;
        slowFilesArray = (function() {
          var results1;
          results1 = [];
          for (key in slowFilesObject) {
            if (!hasProp.call(slowFilesObject, key)) continue;
            value = slowFilesObject[key];
            results1.push(value || key);
          }
          return results1;
        })();
        return docpad.log('info', util.format(locale.slowFiles, 'renderFiles') + ' \n' + slowFilesArray.join('\n'));
      }, config.slowFilesDelay);
      return tasks.run();
    });
    return this;
  };


  /**
  	 * Write rendered files to the DocPad out directory.
  	 * The writeBefore and writeAfter events are emitted here.
  	 * @private
  	 * @method writeFiles
  	 * @param {Object} [opts={}]
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.writeFiles = function(opts, next) {
    var collection, config, docpad, locale, ref2, ref3, slowFilesObject, slowFilesTimer, templateData;
    if (opts == null) {
      opts = {};
    }
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    collection = opts.collection, templateData = opts.templateData;
    docpad = this;
    config = this.getConfig();
    locale = this.getLocale();
    slowFilesObject = {};
    slowFilesTimer = null;
    if ((ref3 = opts.progress) != null) {
      ref3.step("writeFiles (preparing)").total(1).setTick(0);
    }
    docpad.log('debug', util.format(locale.writingFiles, collection.length));
    docpad.emitSerial('writeBefore', {
      collection: collection,
      templateData: templateData
    }, function(err) {
      var ref4, tasks;
      if (err) {
        return next(err);
      }
      tasks = new docpad.TaskGroup("writeFiles tasks", {
        concurrency: 0,
        next: function(err) {
          var ref4;
          clearInterval(slowFilesTimer);
          slowFilesTimer = null;
          if (err) {
            return next(err);
          }
          if ((ref4 = opts.progress) != null) {
            ref4.step("writeFiles (postparing)").total(1).setTick(0);
          }
          return docpad.emitSerial('writeAfter', {
            collection: collection
          }, function(err) {
            if (err) {
              return next(err);
            }
            return next();
          });
        }
      });
      if ((ref4 = opts.progress) != null) {
        ref4.step('writeFiles').total(collection.length).setTick(0);
      }
      collection.forEach(function(file, index) {
        var filePath;
        filePath = file.getFilePath();
        return tasks.addTask("writing the file: " + filePath, function(complete) {
          var fileTasks;
          slowFilesObject[file.id] = file.get('relativePath');
          fileTasks = new docpad.TaskGroup("tasks for file write: " + filePath, {
            concurrency: 0,
            next: function(err) {
              var ref5;
              delete slowFilesObject[file.id];
              if ((ref5 = opts.progress) != null) {
                ref5.tick();
              }
              return complete(err);
            }
          });
          if (file.get('write') !== false && file.get('dynamic') !== true && file.get('outPath')) {
            fileTasks.addTask("write out", function(complete) {
              return file.action('write', complete);
            });
          }
          if (file.get('writeSource') === true && file.get('fullPath')) {
            fileTasks.addTask("write source", function(complete) {
              return file.action('writeSource', complete);
            });
          }
          return fileTasks.run();
        });
      });
      slowFilesTimer = setInterval(function() {
        var key, slowFilesArray, value;
        slowFilesArray = (function() {
          var results;
          results = [];
          for (key in slowFilesObject) {
            if (!hasProp.call(slowFilesObject, key)) continue;
            value = slowFilesObject[key];
            results.push(value || key);
          }
          return results;
        })();
        return docpad.log('info', util.format(locale.slowFiles, 'writeFiles') + ' \n' + slowFilesArray.join('\n'));
      }, config.slowFilesDelay);
      return tasks.run();
    });
    return this;
  };


  /**
  	 * Has DocPad's generation process started?
  	 * @private
  	 * @property {Boolean} generateStarted
   */

  DocPad.prototype.generateStarted = null;


  /**
  	 * Has DocPad's generation process ended?
  	 * @private
  	 * @property {Boolean} generateEnded
   */

  DocPad.prototype.generateEnded = null;


  /**
  	 * Is DocPad currently generating?
  	 * @private
  	 * @property {Boolean} generating
   */

  DocPad.prototype.generating = false;


  /**
  	 * Has DocPad done at least one generation?
  	 * True once the first generation has occured.
  	 * @private
  	 * @property {Object} generated
   */

  DocPad.prototype.generated = false;


  /**
  	 * Create the console progress bar.
  	 * Progress only shown if the DocPad config 'progress'
  	 * option is true, the DocPad config 'prompts' option is true
  	 * and the log level is 6 (default)
  	 * @private
  	 * @method createProgress
  	 * @return {Object} the progress object
   */

  DocPad.prototype.createProgress = function() {
    var config, docpad, progress;
    docpad = this;
    config = docpad.getConfig();
    progress = null;
    if (config.progress && config.prompts && this.getLogLevel() === 6) {
      progress = require('progressbar').create();
      this.getLoggers().console.unpipe(process.stdout);
      this.getLogger().once('log', progress.logListener != null ? progress.logListener : progress.logListener = function(data) {
        if (data.levelNumber <= 5) {
          return docpad.destroyProgress(progress);
        }
      });
    }
    return progress;
  };


  /**
  	 * Destructor. Destroy the progress object
  	 * @private
  	 * @method destroyProgress
  	 * @param {Object} progress
  	 * @return {Object} the progress object
   */

  DocPad.prototype.destroyProgress = function(progress) {
    if (progress) {
      progress.finish();
      this.getLoggers().console.unpipe(process.stdout).pipe(process.stdout);
    }
    return progress;
  };


  /**
  	 * Destructor. Destroy the regeneration timer.
  	 * @private
  	 * @method destroyRegenerateTimer
   */

  DocPad.prototype.destroyRegenerateTimer = function() {
    var docpad;
    docpad = this;
    if (docpad.regenerateTimer) {
      clearTimeout(docpad.regenerateTimer);
      docpad.regenerateTimer = null;
    }
    return this;
  };


  /**
  	 * Create the regeneration timer
  	 * @private
  	 * @method createRegenerateTimer
   */

  DocPad.prototype.createRegenerateTimer = function() {
    var config, docpad, locale;
    docpad = this;
    locale = docpad.getLocale();
    config = docpad.getConfig();
    if (config.regenerateEvery) {
      docpad.regenerateTimer = setTimeout(function() {
        docpad.log('info', locale.renderInterval);
        return docpad.action('generate', config.regenerateEveryOptions);
      }, config.regenerateEvery);
    }
    return this;
  };


  /**
  	 * Set off DocPad's generation process.
  	 * The generated, populateCollectionsBefore, populateCollections, populateCollections
  	 * generateBefore and generateAfter events are emitted here
  	 * @method generate
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.generate = function(opts, next) {
    var addGroup, addTask, config, database, docpad, lastGenerateStarted, locale, ref2, ref3, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = docpad.getConfig();
    locale = docpad.getLocale();
    database = docpad.getDatabase();
    if (((ref3 = opts.collection) != null ? ref3.length : void 0) === 0) {
      return next();
    }
    lastGenerateStarted = docpad.generateStarted;
    docpad.generateStarted = new Date();
    docpad.generateEnded = null;
    docpad.generating = true;
    if (database.models.length) {
      docpad.databaseTempCache = new FilesCollection(database.models);
    }
    if (opts.progress == null) {
      opts.progress = docpad.createProgress();
    }
    opts.templateData = docpad.getTemplateData(opts.templateData || {});
    opts.renderPasses || (opts.renderPasses = config.renderPasses);
    docpad.destroyRegenerateTimer();
    if (!docpad.hasPlugins()) {
      docpad.log('notice', locale.renderNoPlugins);
    }
    docpad.log('info', locale.renderGenerating);
    docpad.notify((new Date()).toLocaleTimeString(), {
      title: locale.renderGeneratingNotification
    });
    tasks = new this.TaskGroup("generate tasks", {
      progress: opts.progress
    }).done(function(err) {
      var howMany, ref4, seconds;
      docpad.generating = false;
      docpad.generateEnded = new Date();
      docpad.databaseTempCache = null;
      docpad.createRegenerateTimer();
      if (opts.progress) {
        docpad.destroyProgress(opts.progress);
        opts.progress = null;
      }
      if (err) {
        return next(err);
      }
      seconds = (docpad.generateEnded - docpad.generateStarted) / 1000;
      howMany = (((ref4 = opts.collection) != null ? ref4.length : void 0) || 0) + "/" + database.length;
      docpad.log('info', util.format(locale.renderGenerated, howMany, seconds));
      docpad.notify((new Date()).toLocaleTimeString(), {
        title: locale.renderGeneratedNotification
      });
      if (opts.initial === true) {
        docpad.generated = true;
        return docpad.emitSerial('generated', opts, next);
      } else if (docpad.generated === false) {
        return next(new Error('DocPad is in an invalid state, please report this on the github issue tracker. Reference 3360'));
      } else {
        return next();
      }
    });
    addGroup = tasks.addGroup.bind(tasks);
    addTask = tasks.addTask.bind(tasks);
    addTask('Reset our collections', function(complete) {
      if (!(opts.reset === true || docpad.generated === false)) {
        return complete();
      }
      return docpad.resetCollections(opts, complete);
    });
    addTask('Figure out options', function() {
      if (opts.cache == null) {
        opts.cache = config.databaseCache;
      }
      if (opts.initial == null) {
        opts.initial = !docpad.generated;
      }
      if (opts.reset == null) {
        opts.reset = opts.initial;
      }
      if (opts.populate == null) {
        opts.populate = opts.reset;
      }
      if (opts.reload == null) {
        opts.reload = opts.reset;
      }
      if (opts.partial == null) {
        opts.partial = !opts.reset;
      }
      return docpad.log('debug', 'Generate options:', pick(opts, ['cache', 'initial', 'reset', 'populate', 'reload', 'partial', 'renderPasses']));
    });
    addTask('check source directory exists', function(complete) {
      if (opts.initial !== true) {
        return complete();
      }
      return safefs.exists(config.srcPath, function(exists) {
        var err;
        if (!exists) {
          err = new Error(locale.renderNonexistant);
          return complete(err);
        }
        return complete();
      });
    });
    addGroup('fetch data to render', function(addGroup, addTask) {
      var ref4;
      if (opts.populate === true) {
        addTask('populateCollectionsBefore', function(complete) {
          return docpad.emitSerial('populateCollectionsBefore', opts, complete);
        });
        if (opts.initial === true && ((ref4 = opts.cache) === true || ref4 === 'read')) {
          addTask('import data from cache', function(complete) {
            return safefs.exists(config.databaseCachePath, function(exists) {
              if (exists === false) {
                return complete();
              }
              return safefs.readFile(config.databaseCachePath, function(err, data) {
                var addedModels, databaseData;
                if (err) {
                  return complete(err);
                }
                databaseData = JSON.parse(data.toString());
                opts.cache = true;
                opts.initial = true;
                opts.reset = false;
                opts.populate = true;
                opts.reload = true;
                opts.partial = true;
                lastGenerateStarted = new Date(databaseData.generateStarted);
                addedModels = docpad.addModels(databaseData.models);
                docpad.log('info', util.format(locale.databaseCacheRead, database.length, databaseData.models.length));
                return complete();
              });
            });
          });
        }
        if (opts.reload === true) {
          addGroup('import data from file system', function(addGroup, addTask) {
            config.documentsPaths.forEach(function(documentsPath) {
              return addTask('import documents', function(complete) {
                return docpad.parseDirectory({
                  modelType: 'document',
                  collection: database,
                  path: documentsPath,
                  next: complete
                });
              });
            });
            config.filesPaths.forEach(function(filesPath) {
              return addTask('import files', function(complete) {
                return docpad.parseDirectory({
                  modelType: 'file',
                  collection: database,
                  path: filesPath,
                  next: complete
                });
              });
            });
            return config.layoutsPaths.forEach(function(layoutsPath) {
              return addTask('import layouts', function(complete) {
                return docpad.parseDirectory({
                  modelType: 'document',
                  collection: database,
                  path: layoutsPath,
                  next: complete
                });
              });
            });
          });
        }
        return addTask('populateCollections', function(complete) {
          return docpad.emitSerial('populateCollections', opts, complete);
        });
      }
    });
    addGroup('determine files to render', function(addGroup, addTask) {
      if (opts.partial === false) {
        return addTask('Add all database models to render queue', function() {
          return opts.collection != null ? opts.collection : opts.collection = new FilesCollection().add(docpad.getCollection('generate').models);
        });
      } else {
        return addTask('Add only changed models to render queue', function() {
          var changedQuery;
          changedQuery = {
            $or: {
              mtime: {
                $gte: lastGenerateStarted
              },
              $and: {
                wtime: null,
                write: true
              }
            }
          };
          return opts.collection != null ? opts.collection : opts.collection = new FilesCollection().add(docpad.getCollection('generate').findAll(changedQuery).models);
        });
      }
    });
    addTask('generateBefore', function(complete) {
      if (opts.collection.length === 0) {
        tasks.clear();
        return complete();
      } else {
        return docpad.emitSerial('generateBefore', opts, complete);
      }
    });
    addTask('prepare files', function(complete) {
      var addLayoutChildren, allStandalone, model, standalones;
      docpad.log('debug', 'Files to generate at', lastGenerateStarted, '\n', (function() {
        var i, len, ref4, results;
        ref4 = opts.collection.models;
        results = [];
        for (i = 0, len = ref4.length; i < len; i++) {
          model = ref4[i];
          results.push({
            id: model.id,
            path: model.getFilePath(),
            mtime: model.get('mtime'),
            wtime: model.get('wtime'),
            dynamic: model.get('dynamic'),
            ignored: model.get('ignored'),
            write: model.get('write')
          });
        }
        return results;
      })());
      standalones = opts.collection.pluck('standalone');
      allStandalone = standalones.indexOf(false) === -1;
      if (allStandalone === false) {
        opts.collection.add(docpad.getCollection('referencesOthers').models);
      }
      addLayoutChildren = function(collection) {
        return collection.forEach(function(file) {
          var layoutChildrenCollection, layoutChildrenQuery;
          if (file.get('isLayout') === true) {
            layoutChildrenQuery = {
              layoutRelativePath: file.get('relativePath')
            };
            layoutChildrenCollection = docpad.getCollection('hasLayout').findAll(layoutChildrenQuery);
            docpad.log('debug', 'Layout children to generate at', lastGenerateStarted, '\n', (function() {
              var i, len, ref4, results;
              ref4 = layoutChildrenCollection.models;
              results = [];
              for (i = 0, len = ref4.length; i < len; i++) {
                model = ref4[i];
                results.push({
                  id: model.id,
                  path: model.getFilePath(),
                  mtime: model.get('mtime'),
                  wtime: model.get('wtime'),
                  write: model.get('write')
                });
              }
              return results;
            })(), '\n', layoutChildrenQuery);
            addLayoutChildren(layoutChildrenCollection);
            return opts.collection.add(layoutChildrenCollection.models);
          }
        });
      };
      addLayoutChildren(opts.collection);
      opts.collection.reset(opts.collection.reject(function(file) {
        return file.get('render') === false && file.get('write') === false;
      }));
      docpad.log('debug', 'Files to generate at', lastGenerateStarted, '\n', (function() {
        var i, len, ref4, results;
        ref4 = opts.collection.models;
        results = [];
        for (i = 0, len = ref4.length; i < len; i++) {
          model = ref4[i];
          results.push({
            id: model.id,
            path: model.getFilePath(),
            mtime: model.get('mtime'),
            wtime: model.get('wtime'),
            dynamic: model.get('dynamic'),
            ignored: model.get('ignored'),
            write: model.get('write')
          });
        }
        return results;
      })());
      return complete();
    });
    addGroup('process file', function(addGroup, addTask) {
      addTask('contextualizeFiles', {
        args: [opts]
      }, docpad.contextualizeFiles.bind(docpad));
      addTask('renderFiles', {
        args: [opts]
      }, docpad.renderFiles.bind(docpad));
      return addTask('writeFiles', {
        args: [opts]
      }, docpad.writeFiles.bind(docpad));
    });
    addTask('generateAfter', function(complete) {
      return docpad.emitSerial('generateAfter', opts, complete);
    });
    addTask('Write the database cache', function(complete) {
      var databaseData, databaseDataDump, model, ref4;
      if ((ref4 = opts.cache) !== true && ref4 !== 'write') {
        return complete();
      }
      databaseData = {
        generateStarted: docpad.generateStarted,
        generateEnded: docpad.generateEnded,
        models: (function() {
          var i, len, ref5, results;
          ref5 = database.models;
          results = [];
          for (i = 0, len = ref5.length; i < len; i++) {
            model = ref5[i];
            results.push(model.getAttributes());
          }
          return results;
        })()
      };
      databaseDataDump = JSON.stringify(databaseData, null, '  ');
      docpad.log('info', util.format(locale.databaseCacheWrite, databaseData.models.length));
      return safefs.writeFile(config.databaseCachePath, databaseDataDump, complete);
    });
    tasks.run();
    return this;
  };


  /**
  	 * Load a document
  	 * @private
  	 * @method loadDocument
  	 * @param {Object} document
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.document
   */

  DocPad.prototype.loadDocument = function(document, opts, next) {
    var ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    document.action('load contextualize', opts, next);
    return this;
  };


  /**
  	 * Load and render a document
  	 * @method loadAndRenderDocument
  	 * @param {Object} document
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.document
   */

  DocPad.prototype.loadAndRenderDocument = function(document, opts, next) {
    var docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    docpad.loadDocument(document, opts, function(err) {
      if (err) {
        return next(err);
      }
      return docpad.renderDocument(document, opts, next);
    });
    return this;
  };


  /**
  	 * Render a document
  	 * @method renderDocument
  	 * @param {Object} document
  	 * @param {Object} opts
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @param {Object} next.result
  	 * @param {Object} next.document
   */

  DocPad.prototype.renderDocument = function(document, opts, next) {
    var clone, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    clone = document.clone().action('render', opts, function(err) {
      var result;
      result = clone.getOutContent();
      return next(err, result, document);
    });
    return this;
  };


  /**
  	 * Render a document at a file path
  	 * next(err,result)
  	 * @method renderPath
  	 * @param {String} path
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.result the rendered document
   */

  DocPad.prototype.renderPath = function(path, opts, next) {
    var attributes, document, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    attributes = extendr.extend({
      fullPath: path
    }, opts.attributes);
    document = this.createDocument(attributes);
    this.loadAndRenderDocument(document, opts, next);
    return this;
  };


  /**
  	 * Render the passed content data as a
  	 * document. Required option, filename
  	 * (opts.filename)
  	 * next(err,result)
  	 * @method renderData
  	 * @param {String} content
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.result the rendered document
   */

  DocPad.prototype.renderData = function(content, opts, next) {
    var attributes, document, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    attributes = extendr.extend({
      filename: opts.filename,
      data: content
    }, opts.attributes);
    document = this.createDocument(attributes);
    this.loadAndRenderDocument(document, opts, next);
    return this;
  };


  /**
  	 * Render the passed text data as a
  	 * document. Required option, filename
  	 * (opts.filename)
  	 * next(err,result)
  	 * @private
  	 * @method renderText
  	 * @param {String} text
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Object} next.result the rendered content
  	 * @param {Object} next.document the rendered document model
   */

  DocPad.prototype.renderText = function(text, opts, next) {
    var attributes, clone, document, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    if (opts.actions == null) {
      opts.actions = ['renderExtensions', 'renderDocument'];
    }
    attributes = extendr.extend({
      filename: opts.filename,
      data: text,
      body: text,
      content: text
    }, opts.attributes);
    document = this.createDocument(attributes);
    clone = document.clone().action('normalize contextualize render', opts, function(err) {
      var result;
      result = clone.getOutContent();
      return next(err, result, document);
    });
    return this;
  };


  /**
  	 * Render action
  	 * next(err,document,result)
  	 * @method render
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.render = function(opts, next) {
    var err, locale, path, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    locale = this.getLocale();
    if (opts.document) {
      this.renderDocument(opts.document, opts, next);
    } else if (opts.data) {
      this.renderData(opts.data, opts, next);
    } else if (opts.text) {
      this.renderText(opts.text, opts, next);
    } else {
      path = opts.path || opts.fullPath || opts.filename || null;
      if (path) {
        this.renderPath(path, opts, next);
      } else {
        err = new Error(locale.renderInvalidOptions);
        return next(err);
      }
    }
    return this;
  };


  /**
  	 * Array of file watchers
  	 * @private
  	 * @property {Array} watchers
   */

  DocPad.prototype.watchers = null;


  /**
  	 * Destructor. Destroy the watchers used
  	 * by DocPad
  	 * @private
  	 * @method destroyWatchers
   */

  DocPad.prototype.destroyWatchers = function() {
    var docpad, i, len, ref2, watcher;
    docpad = this;
    if (docpad.watchers) {
      ref2 = docpad.watchers;
      for (i = 0, len = ref2.length; i < len; i++) {
        watcher = ref2[i];
        watcher.close();
      }
      docpad.watchers = [];
    }
    return this;
  };


  /**
  	 * Start up file watchers used by DocPad
  	 * @private
  	 * @method watch
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.watch = function(opts, next) {
    var changeHandler, config, database, docpad, locale, performGenerate, queueRegeneration, ref2, regenerateTimer, restartWatchers;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    locale = this.getLocale();
    database = this.getDatabase();
    if (this.watchers == null) {
      this.watchers = [];
    }
    restartWatchers = function(next) {
      var regeneratePaths, reloadPaths, srcPath, tasks;
      docpad.destroyWatchers();
      tasks = new docpad.TaskGroup("watch tasks", {
        concurrency: 0,
        next: next
      });
      reloadPaths = union(config.reloadPaths, config.configPaths);
      tasks.addTask("watch reload paths", function(complete) {
        return docpad.watchdir({
          paths: reloadPaths,
          listeners: {
            'log': docpad.log,
            'error': docpad.error,
            'change': function() {
              docpad.log('info', util.format(locale.watchReloadChange, new Date().toLocaleTimeString()));
              return docpad.action('load', function(err) {
                if (err) {
                  return docpad.fatal(err);
                }
                return performGenerate({
                  reset: true
                });
              });
            }
          },
          next: function(err, _watchers) {
            var i, len, watcher;
            if (err) {
              docpad.warn("Watching the reload paths has failed:\n" + docpad.inspector(reloadPaths), err);
              return complete();
            }
            for (i = 0, len = _watchers.length; i < len; i++) {
              watcher = _watchers[i];
              docpad.watchers.push(watcher);
            }
            return complete();
          }
        });
      });
      regeneratePaths = config.regeneratePaths;
      tasks.addTask("watch regenerate paths", function(complete) {
        return docpad.watchdir({
          paths: regeneratePaths,
          listeners: {
            'log': docpad.log,
            'error': docpad.error,
            'change': function() {
              return performGenerate({
                reset: true
              });
            }
          },
          next: function(err, _watchers) {
            var i, len, watcher;
            if (err) {
              docpad.warn("Watching the regenerate paths has failed:\n" + docpad.inspector(regeneratePaths), err);
              return complete();
            }
            for (i = 0, len = _watchers.length; i < len; i++) {
              watcher = _watchers[i];
              docpad.watchers.push(watcher);
            }
            return complete();
          }
        });
      });
      srcPath = config.srcPath;
      tasks.addTask("watch the source path", function(complete) {
        return docpad.watchdir({
          path: srcPath,
          listeners: {
            'log': docpad.log,
            'error': docpad.error,
            'change': changeHandler
          },
          next: function(err, watcher) {
            if (err) {
              docpad.warn("Watching the src path has failed: " + srcPath, err);
              return complete();
            }
            docpad.watchers.push(watcher);
            return complete();
          }
        });
      });
      tasks.run();
      return this;
    };
    regenerateTimer = null;
    queueRegeneration = function() {
      if (regenerateTimer) {
        clearTimeout(regenerateTimer);
        regenerateTimer = null;
      }
      return regenerateTimer = setTimeout(performGenerate, config.regenerateDelay);
    };
    performGenerate = function(opts) {
      if (opts == null) {
        opts = {};
      }
      docpad.log(util.format(locale.watchRegenerating, new Date().toLocaleTimeString()));
      return docpad.action('generate', opts, function(err) {
        if (err) {
          docpad.error(err);
        }
        return docpad.log(util.format(locale.watchRegenerated, new Date().toLocaleTimeString()));
      });
    };
    changeHandler = function(changeType, filePath, fileCurrentStat, filePreviousStat) {
      var err, file, fileEitherStat, isDirectory, isIgnored;
      fileEitherStat = fileCurrentStat || filePreviousStat;
      if (!fileEitherStat) {
        err = new Error("DocPad has encountered an invalid state while detecting changes for your files.\nSo the DocPad team can fix this right away, please provide any information you can to:\nhttps://github.com/bevry/docpad/issues/792");
        return docpad.error(err);
      }
      docpad.log('info', util.format(locale.watchChange, new Date().toLocaleTimeString()), changeType, filePath);
      isIgnored = docpad.isIgnoredPath(filePath);
      if (isIgnored) {
        docpad.log('debug', util.format(locale.watchIgnoredChange, new Date().toLocaleTimeString()), filePath);
        return;
      }
      isDirectory = fileEitherStat.isDirectory();
      if (isDirectory) {
        docpad.log('debug', util.format(locale.watchDirectoryChange, new Date().toLocaleTimeString()), filePath);
        return;
      }
      if (fileCurrentStat != null) {
        fileCurrentStat.mtime = new Date();
      }
      file = docpad.addModel({
        fullPath: filePath,
        stat: fileCurrentStat
      });
      if (changeType === 'update') {
        file.setStat(fileCurrentStat);
      }
      if (changeType === 'delete') {
        database.remove(file);
        return file.action('delete', function(err) {
          if (err) {
            return docpad.error(err);
          }
          return queueRegeneration();
        });
      } else if (changeType === 'create' || changeType === 'update') {
        return file.action('load', function(err) {
          if (err) {
            return docpad.error(err);
          }
          return queueRegeneration();
        });
      }
    };
    docpad.log(locale.watchStart);
    restartWatchers(function(err) {
      if (err) {
        return next(err);
      }
      docpad.log(locale.watchStarted);
      return next();
    });
    return this;
  };


  /**
  	 * Run an action
  	 * @method run
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.run = function(opts, next) {
    var config, docpad, locale, ref2, rootPath, run, srcPath;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    locale = this.getLocale();
    config = this.getConfig();
    srcPath = config.srcPath, rootPath = config.rootPath;
    run = function(complete) {
      return balUtil.flow({
        object: docpad,
        action: 'server generate watch',
        args: [opts],
        next: complete
      });
    };
    safefs.exists(srcPath, function(exists) {
      if (exists) {
        return run(next);
      }
      return safefs.readdir(rootPath, function(err, files) {
        if (err) {
          return next(err);
        }
        if (files.length) {
          docpad.warn(util.format(locale.skeletonNonexistant, rootPath));
          return next();
        } else {
          return docpad.skeleton(opts, function(err) {
            if (err) {
              return next(err);
            }
            if (opts.global === true || docpad.getConfig().global === true) {
              return run(next);
            }
            docpad.log('notice', locale.startLocal);
            return docpad.destroy(function(err) {
              if (err) {
                return next(err);
              }
              return docpadUtil.startLocalDocPadExecutable(next);
            });
          });
        }
      });
    });
    return this;
  };


  /**
  	 * Initialize the skeleton install process.
  	 * @private
  	 * @method initInstall
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.initInstall = function(opts, next) {
    var config, docpad, ref2, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    tasks = new this.TaskGroup("initInstall tasks", {
      concurrency: 0,
      next: next
    });
    tasks.addTask("node modules", function(complete) {
      var path;
      path = pathUtil.join(config.rootPath, 'node_modules');
      return safefs.ensurePath(path, complete);
    });
    tasks.addTask("package", function(complete) {
      var path;
      path = pathUtil.join(config.rootPath, 'package.json');
      return safefs.exists(path, function(exists) {
        var data;
        if (exists) {
          return complete();
        }
        data = JSON.stringify({
          name: 'no-skeleton.docpad',
          version: '0.1.0',
          description: 'New DocPad project without using a skeleton',
          dependencies: {
            docpad: '~' + docpad.getVersion()
          },
          main: 'node_modules/.bin/docpad-server',
          scripts: {
            start: 'node_modules/.bin/docpad-server'
          }
        }, null, '  ');
        return safefs.writeFile(path, data, complete);
      });
    });
    tasks.run();
    return this;
  };


  /**
  	 * Uninstall a plugin.
  	 * @private
  	 * @method uninstall
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.uninstall = function(opts, next) {
    var config, docpad, ref2, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    tasks = new this.TaskGroup("uninstall tasks", {
      next: next
    });
    if (opts.plugin) {
      tasks.addTask("uninstall the plugin: " + opts.plugin, function(complete) {
        var plugin, plugins;
        plugins = (function() {
          var i, len, ref3, results;
          ref3 = opts.plugin.split(/[,\s]+/);
          results = [];
          for (i = 0, len = ref3.length; i < len; i++) {
            plugin = ref3[i];
            if (plugin.indexOf('docpad-plugin-') !== 0) {
              plugin = "docpad-plugin-" + plugin;
            }
            results.push(plugin);
          }
          return results;
        })();
        return docpad.uninstallNodeModule(plugins, {
          stdio: 'inherit',
          next: complete
        });
      });
    }
    tasks.addTask("re-load configuration", function(complete) {
      return docpad.load(complete);
    });
    tasks.run();
    return this;
  };


  /**
  	 * Install a plugin
  	 * @private
  	 * @method install
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.install = function(opts, next) {
    var config, docpad, ref2, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    tasks = new this.TaskGroup("install tasks", {
      next: next
    });
    tasks.addTask("init the installation", function(complete) {
      return docpad.initInstall(opts, complete);
    });
    if (opts.plugin) {
      tasks.addTask("install the plugin: " + opts.plugin, function(complete) {
        var plugin, plugins;
        plugins = (function() {
          var i, len, ref3, results;
          ref3 = opts.plugin.split(/[,\s]+/);
          results = [];
          for (i = 0, len = ref3.length; i < len; i++) {
            plugin = ref3[i];
            if (plugin.indexOf('docpad-plugin-') !== 0) {
              plugin = "docpad-plugin-" + plugin;
            }
            if (plugin.indexOf('@') === -1) {
              plugin += '@' + docpad.pluginVersion;
            }
            results.push(plugin);
          }
          return results;
        })();
        return docpad.installNodeModule(plugins, {
          stdio: 'inherit',
          next: complete
        });
      });
    }
    tasks.addTask("re-initialize the website's modules", function(complete) {
      return docpad.initNodeModules({
        stdio: 'inherit',
        next: complete
      });
    });
    tasks.addTask("fix node package versions", function(complete) {
      return docpad.fixNodePackageVersions(complete);
    });
    tasks.addTask("re-load the configuration", function(complete) {
      return docpad.load(complete);
    });
    tasks.run();
    return this;
  };


  /**
  	 * Update global NPM and DocPad
  	 * @private
  	 * @method upgrade
  	 * @param {Object} opts
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @return {Object} description
   */

  DocPad.prototype.upgrade = function(opts, next) {
    this.installNodeModule('npm docpad@6', {
      global: true,
      stdio: 'inherit',
      next: next
    });
    return this;
  };


  /**
  	 * Update the local DocPad and plugin dependencies
  	 * @private
  	 * @method update
  	 * @param {Object} opts
  	 * @param {Object} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.update = function(opts, next) {
    var config, dependencies, devDependencies, docpad, ref2, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    tasks = new this.TaskGroup("update tasks", {
      next: next
    });
    tasks.addTask("init the install", function(complete) {
      return docpad.initInstall(opts, complete);
    });
    dependencies = [];
    eachr(docpad.websitePackageConfig.dependencies, function(version, name) {
      if (/^docpad-plugin-/.test(name) === false || /:\/\//.test(version) === true) {
        return;
      }
      return dependencies.push(name + '@' + docpad.pluginVersion);
    });
    if (dependencies.length !== 0) {
      tasks.addTask("update plugins that are dependencies", function(complete) {
        return docpad.installNodeModule('docpad@6 ' + dependencies, {
          stdio: 'inherit',
          next: complete
        });
      });
    }
    devDependencies = [];
    eachr(docpad.websitePackageConfig.devDependencies, function(version, name) {
      if (/^docpad-plugin-/.test(name) === false) {
        return;
      }
      return devDependencies.push(name + '@' + docpad.pluginVersion);
    });
    if (devDependencies.length !== 0) {
      tasks.addTask("update plugins that are dev dependencies", function(complete) {
        return docpad.installNodeModule(devDependencies, {
          save: '--save-dev',
          stdio: 'inherit',
          next: complete
        });
      });
    }
    tasks.addTask("fix node package versions", function(complete) {
      return docpad.fixNodePackageVersions(complete);
    });
    tasks.addTask("re-initialize the rest of the website's modules", function(complete) {
      return docpad.initNodeModules({
        stdio: 'inherit',
        next: complete
      });
    });
    tasks.run();
    return this;
  };


  /**
  	 * DocPad cleanup tasks.
  	 * @private
  	 * @method clean
  	 * @param {Object} opts
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @return {Object} description
   */

  DocPad.prototype.clean = function(opts, next) {
    var config, docpad, locale, ref2, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = docpad.getConfig();
    locale = this.getLocale();
    docpad.log('info', locale.renderCleaning);
    tasks = new this.TaskGroup("clean tasks", {
      concurrency: 0
    }, {
      next: function(err) {
        if (err) {
          return next(err);
        }
        docpad.log('info', locale.renderCleaned);
        return next();
      }
    });
    tasks.addTask('reset the collecitons', function(complete) {
      return docpad.resetCollections(opts, complete);
    });
    tasks.addTask('delete out path', function(complete) {
      if (config.rootPath.indexOf(config.outPath) !== -1) {
        return complete();
      }
      return rimraf(config.outPath, complete);
    });
    tasks.addTask('delete database cache file', function(complete) {
      return safefs.unlink(config.databaseCachePath, complete);
    });
    tasks.run();
    return this;
  };


  /**
  	 * Initialize a Skeleton into to a Directory
  	 * @private
  	 * @method initSkeleton
  	 * @param {Object} skeletonModel
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.initSkeleton = function(skeletonModel, opts, next) {
    var config, docpad, ref2, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.getConfig();
    if (opts.destinationPath == null) {
      opts.destinationPath = config.rootPath;
    }
    tasks = new this.TaskGroup("initSkeleton tasks", {
      next: next
    });
    tasks.addTask("ensure the path we are writing to exists", function(complete) {
      return safefs.ensurePath(opts.destinationPath, complete);
    });
    if ((skeletonModel != null) && skeletonModel.id !== 'none') {
      tasks.addTask("clone out the git repo", function(complete) {
        return docpad.initGitRepo({
          cwd: opts.destinationPath,
          url: skeletonModel.get('repo'),
          branch: skeletonModel.get('branch'),
          remote: 'skeleton',
          stdio: 'inherit',
          next: complete
        });
      });
    } else {
      tasks.addTask("ensure src path exists", function(complete) {
        return safefs.ensurePath(config.srcPath, complete);
      });
      tasks.addGroup("initialize the website directory files", function() {
        this.setConfig({
          concurrency: 0
        });
        this.addTask("README.md", function(complete) {
          var path;
          path = pathUtil.join(config.rootPath, 'README.md');
          return safefs.exists(path, function(exists) {
            var data;
            if (exists) {
              return complete();
            }
            data = "# Your [DocPad](http://docpad.org) Project\n\n## License\nCopyright &copy; " + ((new Date()).getFullYear()) + "+ All rights reserved.";
            return safefs.writeFile(path, data, complete);
          });
        });
        this.addTask("docpad.coffee configuration file", function(complete) {
          return docpad.getConfigPath(function(err, path) {
            var data;
            if (err || path) {
              return complete(err);
            }
            path = pathUtil.join(config.rootPath, 'docpad.coffee');
            data = "# DocPad Configuration File\n# http://docpad.org/docs/config\n\n# Define the DocPad Configuration\ndocpadConfig = {\n	# ...\n}\n\n# Export the DocPad Configuration\nmodule.exports = docpadConfig";
            return safefs.writeFile(path, data, complete);
          });
        });
        this.addTask("documents directory", function(complete) {
          return safefs.ensurePath(config.documentsPaths[0], complete);
        });
        this.addTask("layouts directory", function(complete) {
          return safefs.ensurePath(config.layoutsPaths[0], complete);
        });
        return this.addTask("files directory", function(complete) {
          return safefs.ensurePath(config.filesPaths[0], complete);
        });
      });
    }
    tasks.run();
    return this;
  };


  /**
  	 * Install a Skeleton into a Directory
  	 * @private
  	 * @method installSkeleton
  	 * @param {Object} skeletonModel
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.installSkeleton = function(skeletonModel, opts, next) {
    var docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    if (opts.destinationPath == null) {
      opts.destinationPath = this.getConfig().rootPath;
    }
    docpad.initSkeleton(skeletonModel, opts, function(err) {
      if (err) {
        return next(err);
      }
      return docpad.install(opts, next);
    });
    return this;
  };


  /**
  	 * Use a Skeleton
  	 * @private
  	 * @method useSkeleton
  	 * @param {Object} skeletonModel
  	 * @param {Object} opts
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @return {Object} description
   */

  DocPad.prototype.useSkeleton = function(skeletonModel, opts, next) {
    var docpad, locale, ref2, skeletonId, skeletonName;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    locale = this.getLocale();
    if (opts.destinationPath == null) {
      opts.destinationPath = this.getConfig().rootPath;
    }
    skeletonId = (skeletonModel != null ? skeletonModel.id : void 0) || 'none';
    skeletonName = (skeletonModel != null ? skeletonModel.get('name') : void 0) || locale.skeletonNoneName;
    docpad.track('skeleton-use', {
      skeletonId: skeletonId
    });
    docpad.log('info', util.format(locale.skeletonInstall, skeletonName, opts.destinationPath) + ' ' + locale.pleaseWait);
    docpad.installSkeleton(skeletonModel, opts, function(err) {
      if (err) {
        return next(err);
      }
      docpad.log('info', locale.skeletonInstalled);
      return next(err);
    });
    return this;
  };


  /**
  	 * Select a Skeleton
  	 * @private
  	 * @method selectSkeleton
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
  	 * @param {Error} next.skeletonModel
   */

  DocPad.prototype.selectSkeleton = function(opts, next) {
    var docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    if (opts.selectSkeletonCallback == null) {
      opts.selectSkeletonCallback = null;
    }
    docpad.track('skeleton-ask');
    docpad.getSkeletons(function(err, skeletonsCollection) {
      if (err) {
        return next(err);
      }
      return opts.selectSkeletonCallback(skeletonsCollection, next);
    });
    return this;
  };


  /**
  	 * Skeleton Empty?
  	 * @private
  	 * @method skeletonEmpty
  	 * @param {Object} path
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.skeletonEmpty = function(path, next) {
    var locale;
    locale = this.getLocale();
    if (path == null) {
      path = this.getConfig().rootPath;
    }
    safefs.exists(pathUtil.join(path, 'package.json'), function(exists) {
      var err;
      if (exists) {
        err = new Error(locale.skeletonExists);
        return next(err);
      }
      return next();
    });
    return this;
  };


  /**
  	 * Initialize the project directory
  	 * with the basic skeleton.
  	 * @private
  	 * @method skeleton
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.skeleton = function(opts, next) {
    var docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    if (opts.selectSkeletonCallback == null) {
      opts.selectSkeletonCallback = null;
    }
    this.skeletonEmpty(null, function(err) {
      if (err) {
        return next(err);
      }
      return docpad.selectSkeleton(opts, function(err, skeletonModel) {
        if (err) {
          return next(err);
        }
        return docpad.useSkeleton(skeletonModel, next);
      });
    });
    return this;
  };


  /**
  	 * Initialize the project directory
  	 * with the basic skeleton.
  	 * @private
  	 * @method init
  	 * @param {Object} opts
  	 * @param {Object} next
  	 * @param {Error} next.err
  	 * @return {Object} description
   */

  DocPad.prototype.init = function(opts, next) {
    var docpad, ref2;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    this.skeletonEmpty(null, function(err) {
      if (err) {
        return next(err);
      }
      return docpad.useSkeleton(null, next);
    });
    return this;
  };


  /**
  	 * Serve a document
  	 * @private
  	 * @method serveDocument
  	 * @param {Object} opts
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.serveDocument = function(opts, next) {
    var charset, collection, config, content, contentType, ctime, docpad, document, dynamic, encoding, err, etag, mtime, ref2, req, res, stat, templateData;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    document = opts.document, err = opts.err, req = opts.req, res = opts.res;
    docpad = this;
    config = this.getConfig();
    if (!document) {
      if (opts.statusCode != null) {
        return res.send(opts.statusCode);
      } else {
        return next();
      }
    }
    if (res.setHeaderIfMissing == null) {
      res.setHeaderIfMissing = function(name, value) {
        if (!res.getHeader(name)) {
          return res.setHeader(name, value);
        }
      };
    }
    encoding = document.get('encoding');
    if (encoding === 'utf8' || encoding === 'utf-8') {
      charset = 'utf-8';
    }
    contentType = document.get('outContentType') || document.get('contentType');
    res.setHeaderIfMissing('Content-Type', contentType + (charset ? "; charset=" + charset : ''));
    if (config.maxAge) {
      res.setHeaderIfMissing('Cache-Control', "public, max-age=" + config.maxAge);
    }
    dynamic = document.get('dynamic');
    if (dynamic) {
      collection = new FilesCollection([document], {
        name: 'dynamic collection'
      });
      templateData = extendr.extend({}, req.templateData || {}, {
        req: req,
        err: err
      });
      docpad.action('generate', {
        collection: collection,
        templateData: templateData
      }, function(err) {
        var content;
        content = document.getOutContent();
        if (err) {
          docpad.error(err);
          return next(err);
        } else {
          if (opts.statusCode != null) {
            return res.send(opts.statusCode, content);
          } else {
            return res.send(content);
          }
        }
      });
    } else {
      ctime = document.get('date');
      mtime = document.get('wtime');
      stat = document.getStat();
      if (mtime && stat) {
        etag = stat.size + '-' + Number(mtime);
      }
      if (etag) {
        res.setHeaderIfMissing('ETag', '"' + etag + '"');
      }
      if ((ctime != null ? ctime.toUTCString : void 0) != null) {
        res.setHeaderIfMissing('Date', ctime.toUTCString());
      }
      if ((mtime != null ? mtime.toUTCString : void 0) != null) {
        res.setHeaderIfMissing('Last-Modified', mtime.toUTCString());
      }
      if (etag && etag === (req.get('If-None-Match') || '').replace(/^"|"$/g, '')) {
        res.send(304);
      } else {
        content = document.getOutContent();
        if (content) {
          if (opts.statusCode != null) {
            res.send(opts.statusCode, content);
          } else {
            res.send(content);
          }
        } else {
          if (opts.statusCode != null) {
            res.send(opts.statusCode);
          } else {
            next();
          }
        }
      }
    }
    return this;
  };


  /**
  	 * Server Middleware: Header
  	 * @private
  	 * @method serverMiddlewareHeader
  	 * @param {Object} req
  	 * @param {Object} res
  	 * @param {Object} next
   */

  DocPad.prototype.serverMiddlewareHeader = function(req, res, next) {
    var docpad, tools;
    docpad = this;
    tools = res.get('X-Powered-By').split(/[,\s]+/g);
    tools.push("DocPad v" + (docpad.getVersion()));
    tools = tools.join(', ');
    res.set('X-Powered-By', tools);
    next();
    return this;
  };


  /**
  	 * Server Middleware: Router
  	 * @private
  	 * @method serverMiddlewareRouter
  	 * @param {Object} req
  	 * @param {Object} res
  	 * @param {Function} next
  	 * @param {Error} next.err
   */

  DocPad.prototype.serverMiddlewareRouter = function(req, res, next) {
    var docpad;
    docpad = this;
    docpad.getFileByRoute(req.url, function(err, file) {
      var cleanUrl, url;
      if (err || (file != null) === false) {
        return next(err);
      }
      url = file.get('url');
      cleanUrl = docpad.getUrlPathname(req.url);
      if ((url !== cleanUrl) && (url !== req.url)) {
        return res.redirect(301, url);
      }
      return docpad.serveDocument({
        document: file,
        req: req,
        res: res,
        next: next
      });
    });
    return this;
  };


  /**
  	 * Server Middleware: 404
  	 * @private
  	 * @method serverMiddleware404
  	 * @param {Object} req
  	 * @param {Object} res
  	 * @param {Object} next
   */

  DocPad.prototype.serverMiddleware404 = function(req, res, next) {
    var database, docpad, document;
    docpad = this;
    database = docpad.getDatabaseSafe();
    docpad.log('notice', "404 Not Found:", req.url);
    if (!database) {
      return res.send(500);
    }
    document = database.findOne({
      relativeOutPath: '404.html'
    });
    docpad.serveDocument({
      document: document,
      req: req,
      res: res,
      next: next,
      statusCode: 404
    });
    return this;
  };


  /**
  	 * Server Middleware: 500
  	 * @private
  	 * @method serverMiddleware500
  	 * @param {Object} err
  	 * @param {Object} req
  	 * @param {Object} res
  	 * @param {Function} next
   */

  DocPad.prototype.serverMiddleware500 = function(err, req, res, next) {
    var database, docpad, document;
    docpad = this;
    database = docpad.getDatabaseSafe();
    if (!database) {
      return res.send(500);
    }
    document = database.findOne({
      relativeOutPath: '500.html'
    });
    docpad.serveDocument({
      document: document,
      err: err,
      req: req,
      res: res,
      next: next,
      statusCode: 500
    });
    return this;
  };


  /**
  	 * Configure and start up the DocPad web server.
  	 * Http and express server is created, extended with
  	 * middleware, started up and begins listening.
  	 * The events serverBefore, serverExtend and
  	 * serverAfter emitted here.
  	 * @private
  	 * @method server
  	 * @param {Object} opts
  	 * @param {Function} next
   */

  DocPad.prototype.server = function(opts, next) {
    var config, docpad, express, hostname, http, locale, port, ref2, ref3, ref4, ref5, servers, tasks;
    ref2 = extractOptsAndCallback(opts, next), opts = ref2[0], next = ref2[1];
    docpad = this;
    config = this.config;
    locale = this.getLocale();
    port = this.getPort();
    hostname = this.getHostname();
    http = require('http');
    express = require('express');
    servers = this.getServer(true);
    if (opts.serverExpress == null) {
      opts.serverExpress = servers.serverExpress;
    }
    if (opts.serverHttp == null) {
      opts.serverHttp = servers.serverHttp;
    }
    if (opts.middlewareBodyParser == null) {
      opts.middlewareBodyParser = (ref3 = config.middlewareBodyParser) != null ? ref3 : config.middlewareStandard;
    }
    if (opts.middlewareMethodOverride == null) {
      opts.middlewareMethodOverride = (ref4 = config.middlewareMethodOverride) != null ? ref4 : config.middlewareStandard;
    }
    if (opts.middlewareExpressRouter == null) {
      opts.middlewareExpressRouter = (ref5 = config.middlewareExpressRouter) != null ? ref5 : config.middlewareStandard;
    }
    if (opts.middleware404 == null) {
      opts.middleware404 = config.middleware404;
    }
    if (opts.middleware500 == null) {
      opts.middleware500 = config.middleware500;
    }
    tasks = new this.TaskGroup("server tasks", {
      next: next
    });
    tasks.addTask("emit serverBefore", function(complete) {
      return docpad.emitSerial('serverBefore', complete);
    });
    if (!opts.serverExpress || !opts.serverHttp) {
      tasks.addTask("create server", function() {
        opts.serverExpress || (opts.serverExpress = express());
        opts.serverHttp || (opts.serverHttp = http.createServer(opts.serverExpress));
        return docpad.setServer(opts);
      });
    }
    if (config.extendServer === true) {
      tasks.addTask("extend the server", function(complete) {
        if (opts.middlewareBodyParser !== false) {
          opts.serverExpress.use(express.urlencoded());
          opts.serverExpress.use(express.json());
        }
        if (opts.middlewareMethodOverride !== false) {
          if (typeChecker.isString(opts.middlewareMethodOverride)) {
            opts.serverExpress.use(require('method-override')(opts.middlewareMethodOverride));
          } else {
            opts.serverExpress.use(require('method-override')());
          }
        }
        return docpad.emitSerial('serverExtend', {
          server: opts.serverExpress,
          express: opts.serverExpress,
          serverHttp: opts.serverHttp,
          serverExpress: opts.serverExpress
        }, function(err) {
          if (err) {
            return next(err);
          }
          opts.serverExpress.use(docpad.serverMiddlewareHeader);
          if (opts.middlewareExpressRouter !== false) {
            opts.serverExpress.use(opts.serverExpress.router);
          }
          opts.serverExpress.use(docpad.serverMiddlewareRouter);
          if (config.maxAge) {
            opts.serverExpress.use(express["static"](config.outPath, {
              maxAge: config.maxAge
            }));
          } else {
            opts.serverExpress.use(express["static"](config.outPath));
          }
          if (opts.middleware404 !== false) {
            opts.serverExpress.use(docpad.serverMiddleware404);
          }
          if (opts.middleware500 !== false) {
            opts.serverExpress.use(docpad.serverMiddleware500);
          }
          return complete();
        });
      });
    }
    tasks.addTask("start the server", function(complete) {
      opts.serverHttp.once('error', function(err) {
        if (err.message.indexOf('EADDRINUSE') !== -1) {
          err = new Error(util.format(locale.serverInUse, port));
        }
        return complete(err);
      });
      docpad.log('debug', util.format(locale.serverStart, hostname, port));
      return opts.serverHttp.listen(port, hostname, function() {
        var address, serverUrl, simpleServerUrl;
        address = opts.serverHttp.address();
        serverUrl = docpad.getServerUrl({
          hostname: address.hostname,
          port: address.port
        });
        simpleServerUrl = docpad.getSimpleServerUrl({
          hostname: address.hostname,
          port: address.port
        });
        docpad.log('info', util.format(locale.serverStarted, serverUrl));
        if (serverUrl !== simpleServerUrl) {
          docpad.log('info', util.format(locale.serverBrowse, simpleServerUrl));
        }
        return complete();
      });
    });
    tasks.addTask("emit serverAfter", function(complete) {
      return docpad.emitSerial('serverAfter', {
        server: opts.serverExpress,
        express: opts.serverExpress,
        serverHttp: opts.serverHttp,
        serverExpress: opts.serverExpress
      }, complete);
    });
    tasks.run();
    return this;
  };

  return DocPad;

})(EventEmitterGrouped);

module.exports = DocPad;
