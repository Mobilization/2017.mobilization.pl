// Generated by CoffeeScript 1.10.0
var CSON, DocumentModel, FileModel, TaskGroup, YAML, docpadUtil, eachr, extendr, extractOptsAndCallback, pathUtil, util,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

util = require('util');

pathUtil = require('path');

docpadUtil = require('../util');

CSON = require('cson');

extendr = require('extendr');

eachr = require('eachr');

TaskGroup = require('taskgroup').TaskGroup;

extractOptsAndCallback = require('extract-opts');

FileModel = require('./file');

YAML = null;


/**
 * The DocumentModel class is DocPad's representation
 * of a website or project's content files. This can be
 * individual web pages or blog posts etc. Generally, this
 * is not other website files such as css files, images, or scripts -
 * unless there is a requirement to have DocPad do transformation on
 * these files.
 * Extends the DocPad FileModel class
 * https://github.com/docpad/docpad/blob/master/src/lib/models/file.coffee
 * DocumentModel primarily handles the rendering and parsing of document files.
 * This includes merging the document with layouts and managing the rendering
 * from one file extension to another. The class inherits many of the file
 * specific operations and DocPad specific attributes from the FileModel class.
 * However, it also overrides some parsing and file output operations contained
 * in the FileModel class.
 *
 * Typically we do not need to create DocumentModels ourselves as DocPad handles
 * all of that. Most of the time when we encounter DocumentModels is when
 * querying DocPad's document collections either in the docpad.coffee file or
 * from within a template.
 *
 * 	indexDoc = @getCollection('documents').findOne({relativeOutPath: 'index.html'})
 *
 * A plugin, however, may need to create a DocumentModel depending on its requirements.
 * In such a case it is wise to use the built in DocPad methods to do so, in particular
 * docpad.createModel
 *
 * 	#check to see if the document alread exists ie its an update
 * 	docModel = @docpad.getCollection('posts').findOne({slug: 'some-slug'})
 *
 * 	#if so, load the existing document ready for regeneration
 * 	if docModel
 * 		docModel.load()
 * 	else
 * 		#if document doesn't already exist, create it and add to database
 * 		docModel = @docpad.createModel({fullPath:'file/path/to/somewhere'})
 * 		docModel.load()
 * 		@docpad.getDatabase().add(docModel)
 *
 * @class DocumentModel
 * @constructor
 * @extends FileModel
 */

DocumentModel = (function(superClass) {
  extend(DocumentModel, superClass);

  function DocumentModel() {
    return DocumentModel.__super__.constructor.apply(this, arguments);
  }


  /**
  	 * The document model class.
  	 * @private
  	 * @property {Object} klass
   */

  DocumentModel.prototype.klass = DocumentModel;


  /**
  	 * String name of the model type.
  	 * In this case, 'document'.
  	 * @private
  	 * @property {String} type
   */

  DocumentModel.prototype.type = 'document';


  /**
  	 * The default attributes for any document model.
  	 * @private
  	 * @property {Object}
   */

  DocumentModel.prototype.defaults = extendr.extend({}, FileModel.prototype.defaults, {
    referencesOthers: false,
    header: null,
    parser: null,
    body: null,
    rendered: false,
    contentRendered: null,
    contentRenderedWithoutLayouts: null,
    render: true,
    renderSingleExtensions: false
  });


  /**
  	 * Get the file content for output. This
  	 * will be the text content AFTER it has
  	 * been through the rendering process. If
  	 * this has been called before the rendering
  	 * process, then the raw text content will be returned,
  	 * or, if early enough in the process, the file buffer object.
  	 * @method getOutContent
  	 * @return {String or Object}
   */

  DocumentModel.prototype.getOutContent = function() {
    var content;
    content = this.get('contentRendered') || this.getContent();
    return content;
  };


  /**
  	 * Set flag to indicate if the document
  	 * contains references to other documents.
  	 * Used in the rendering process to decide
  	 * on whether to render this document when
  	 * another document is updated.
  	 * @method referencesOthers
  	 * @param {Boolean} [flag=true]
   */

  DocumentModel.prototype.referencesOthers = function(flag) {
    if (flag == null) {
      flag = true;
    }
    this.set({
      referencesOthers: flag
    });
    return this;
  };


  /**
  	 * Parse our buffer and extract meaningful data from it.
  	 * next(err).
  	 * @method parse
  	 * @param {Object} [opts={}]
  	 * @param {Object} next callback
   */

  DocumentModel.prototype.parse = function(opts, next) {
    var buffer, filePath, locale, ref;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    buffer = this.getBuffer();
    locale = this.getLocale();
    filePath = this.getFilePath();
    DocumentModel.__super__.parse.call(this, opts, (function(_this) {
      return function() {
        var body, content, csonOptions, err, error, header, i, j, key, len, len1, match, meta, metaDataChanges, metaParseResult, parser, ref1, ref2, ref3, ref4, regex, seperator;
        meta = _this.getMeta();
        metaDataChanges = {};
        parser = header = body = content = null;
        content = _this.get('content').replace(/\r\n?/gm, '\n');
        regex = /^\s*[^\n]*?(([^\s\d\w])\2{2,})(?:\x20*([a-z]+))?([\s\S]*?)[^\n]*?\1[^\n]*/;
        match = regex.exec(content);
        if (match) {
          seperator = match[1];
          parser = match[3] || 'yaml';
          header = match[4].trim();
          body = content.substring(match[0].length).trim();
          try {
            switch (parser) {
              case 'cson':
              case 'json':
              case 'coffee':
              case 'coffeescript':
              case 'coffee-script':
              case 'js':
              case 'javascript':
                switch (parser) {
                  case 'coffee':
                  case 'coffeescript':
                  case 'coffee-script':
                    parser = 'coffeescript';
                    break;
                  case 'js':
                  case 'javascript':
                    parser = 'javascript';
                }
                csonOptions = {
                  format: parser,
                  json: true,
                  cson: true,
                  coffeescript: true,
                  javascript: true
                };
                metaParseResult = CSON.parseString(header, csonOptions);
                if (metaParseResult instanceof Error) {
                  metaParseResult.context = "Failed to parse " + parser + " meta header for the file: " + filePath;
                  return next(metaParseResult);
                }
                extendr.extend(metaDataChanges, metaParseResult);
                break;
              case 'yaml':
                if (!YAML) {
                  YAML = require('yamljs');
                }
                metaParseResult = YAML.parse(header.replace(/\t/g, '    '));
                extendr.extend(metaDataChanges, metaParseResult);
                break;
              default:
                err = new Error(util.format(locale.documentMissingParserError, parser, filePath));
                return next(err);
            }
          } catch (error) {
            err = error;
            err.context = util.format(locale.documentParserError, parser, filePath);
            return next(err);
          }
        } else {
          body = content;
        }
        if (metaDataChanges.encoding && metaDataChanges.encoding !== _this.get('encoding')) {
          _this.set({
            encoding: metaDataChanges.encoding
          });
          opts.reencode = true;
          return _this.parse(opts, next);
        }
        body = body.replace(/^\n+/, '');
        _this.set({
          source: content,
          content: body,
          header: header,
          body: body,
          parser: parser,
          name: _this.get('name') || _this.get('title') || _this.get('basename')
        });
        if (metaDataChanges.date) {
          metaDataChanges.date = new Date(metaDataChanges.date);
        }
        ref1 = ['ignore', 'skip', 'draft'];
        for (i = 0, len = ref1.length; i < len; i++) {
          key = ref1[i];
          if (metaDataChanges[key] != null) {
            metaDataChanges.ignored = (ref2 = metaDataChanges[key]) != null ? ref2 : false;
            delete metaDataChanges[key];
          }
        }
        ref3 = ['published'];
        for (j = 0, len1 = ref3.length; j < len1; j++) {
          key = ref3[j];
          if (metaDataChanges[key] != null) {
            metaDataChanges.ignored = !((ref4 = metaDataChanges[key]) != null ? ref4 : false);
            delete metaDataChanges[key];
          }
        }
        if (metaDataChanges.urls) {
          _this.addUrl(metaDataChanges.urls);
        }
        if (metaDataChanges.url) {
          _this.setUrl(metaDataChanges.url);
        }
        if (metaDataChanges.id != null) {
          _this.log('warn', util.format(locale.documentIdChangeError, filePath));
          delete metaDataChanges.id;
        }
        _this.setMeta(metaDataChanges);
        return next();
      };
    })(this));
    return this;
  };


  /**
  	 * Normalize any parsing we have done, because if a value has
  	 * updates it may have consequences on another value.
  	 * This will ensure everything is okay.
  	 * next(err)
  	 * @method normalize
  	 * @param {Object} [opts={}]
  	 * @param {Object} next callback
   */

  DocumentModel.prototype.normalize = function(opts, next) {
    var changes, extensions, filename, meta, outExtension, ref;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    changes = {};
    meta = this.getMeta();
    outExtension = opts.outExtension || meta.get('outExtension') || null;
    filename = opts.filename || this.get('filename') || null;
    extensions = this.getExtensions({
      filename: filename
    }) || null;
    if (!outExtension) {
      changes.outExtension = outExtension = extensions[0] || null;
    }
    DocumentModel.__super__.normalize.call(this, extendr.extend(opts, changes), next);
    return this;
  };


  /**
  	 * Contextualize the data. In other words,
  	 * put our data into the perspective of the bigger picture of the data.
  	 * For instance, generate the url for it's rendered equivalant.
  	 * next(err)
  	 * @method contextualize
  	 * @param {Object} [opts={}]
  	 * @param {Object} next callback
   */

  DocumentModel.prototype.contextualize = function(opts, next) {
    var ref;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    this.getEve((function(_this) {
      return function(err, eve) {
        var changes, extensions, meta, outExtension, outFilename, outPath;
        if (err) {
          return next(err);
        }
        changes = {};
        meta = _this.getMeta();
        outFilename = opts.outFilename || meta.get('outFilename') || null;
        outPath = opts.outPath || meta.get('outPath') || null;
        outExtension = opts.outExtension || meta.get('outExtension') || null;
        extensions = _this.getExtensions({
          filename: outFilename
        }) || null;
        if (!outExtension) {
          if (!outFilename && !outPath) {
            if (eve != null) {
              changes.outExtension = outExtension = eve.get('outExtension') || extensions[0] || null;
            } else {
              changes.outExtension = extensions[0] || null;
            }
          }
        }
        return _this.normalize(extendr.extend(opts, changes), next);
      };
    })(this));
    return this;
  };


  /**
  	 * Checks if the file has a layout.
  	 * @method hasLayout
  	 * @return {Boolean}
   */

  DocumentModel.prototype.hasLayout = function() {
    return this.get('layout') != null;
  };


  /**
  	 * Get the layout object that this file references (if any).
  	 * We update the layoutRelativePath as it is
  	 * used for finding what documents are used by a
  	 * layout for when a layout changes.
  	 * next(err, layout)
  	 * @method getLayout
  	 * @param {Function} next callback
   */

  DocumentModel.prototype.getLayout = function(next) {
    var file, layoutSelector;
    file = this;
    layoutSelector = this.get('layout');
    if (!layoutSelector) {
      return next(null, null);
    }
    this.emit('getLayout', {
      selector: layoutSelector
    }, function(err, opts) {
      var layout;
      layout = opts.layout;
      if (err) {
        file.set({
          'layoutRelativePath': null
        });
        return next(err);
      } else if (!layout) {
        file.set({
          'layoutRelativePath': null
        });
        return next();
      } else {
        file.set({
          'layoutRelativePath': layout.get('relativePath')
        });
        return next(null, layout);
      }
    });
    return this;
  };


  /**
  	 * Get the most ancestoral (root) layout we
  	 * have - ie, the very top one. Often this
  	 * will be the base or default layout for
  	 * a project. The layout where the head and other
  	 * html on all pages is defined. In some projects,
  	 * however, there may be more than one root layout
  	 * so we can't assume there will always only be one.
  	 * This is used by the contextualize method to determine
  	 * the output extension of the document. In other words
  	 * the document's final output extension is determined by
  	 * the root layout.
  	 * next(err,layout)
  	 * @method getEve
  	 * @param {Function} next
   */

  DocumentModel.prototype.getEve = function(next) {
    if (this.hasLayout()) {
      this.getLayout(function(err, layout) {
        if (err) {
          return next(err, null);
        } else if (layout) {
          return layout.getEve(next);
        } else {
          return next(null, null);
        }
      });
    } else {
      next(null, this);
    }
    return this;
  };


  /**
  	 * Renders one extension to another depending
  	 * on the document model's extensions property.
  	 * Triggers the render event for each extension conversion.
  	 * This is the point where the various templating systems listen
  	 * for their extension and perform their conversions.
  	 * Common extension conversion is from md to html.
  	 * So the document source file maybe index.md.html.
  	 * This will be a markdown file to be converted to HTML.
  	 * However, documents can be rendered through more than
  	 * one conversion. Index.html.md.eco will be rendered from
  	 * eco to md and then from md to html. Two conversions.
  	 * next(err,result)
  	 * @private
  	 * @method renderExtensions
  	 * @param {Object} opts
  	 * @param {Function} next callback
   */

  DocumentModel.prototype.renderExtensions = function(opts, next) {
    var content, extension, extensions, extensionsReversed, file, filePath, filename, i, len, locale, ref, renderSingleExtensions, result, tasks, templateData;
    file = this;
    locale = this.getLocale();
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    content = opts.content, templateData = opts.templateData, renderSingleExtensions = opts.renderSingleExtensions;
    extensions = this.get('extensions');
    filename = this.get('filename');
    filePath = this.getFilePath();
    if (content == null) {
      content = this.get('body');
    }
    if (templateData == null) {
      templateData = {};
    }
    if (renderSingleExtensions == null) {
      renderSingleExtensions = this.get('renderSingleExtensions');
    }
    result = content;
    extensionsReversed = [];
    if (extensions.length === 0 && filename) {
      extensionsReversed.push(filename);
    }
    for (i = 0, len = extensions.length; i < len; i++) {
      extension = extensions[i];
      extensionsReversed.unshift(extension);
    }
    if (renderSingleExtensions && extensionsReversed.length === 1) {
      if (renderSingleExtensions !== 'auto' || filename.replace(/^\./, '') === extensionsReversed[0]) {
        extensionsReversed.push(null);
      }
    }
    if (extensionsReversed.length <= 1) {
      return next(null, result);
    }
    tasks = new this.TaskGroup("renderExtensions: " + filePath, {
      next: function(err) {
        return next(err, result);
      }
    });
    eachr(extensionsReversed.slice(1), function(extension, index) {
      return tasks.addTask("renderExtension: " + filePath + " [" + extensionsReversed[index] + " => " + extension + "]", function(complete) {
        var eventData;
        eventData = {
          inExtension: extensionsReversed[index],
          outExtension: extension,
          templateData: templateData,
          file: file,
          content: result
        };
        return file.trigger('render', eventData, function(err) {
          if (err) {
            return complete(err);
          }
          if (result && (result === eventData.content)) {
            file.log('warn', util.format(locale.documentRenderExtensionNoChange, eventData.inExtension, eventData.outExtension, filePath));
            return complete();
          }
          result = eventData.content;
          return complete();
        });
      });
    });
    tasks.run();
    return this;
  };


  /**
  	 * Triggers the renderDocument event after
  	 * all extensions have been rendered. Listeners
  	 * can use this event to perform transformations
  	 * on the already rendered content.
  	 * @private
  	 * @method renderDocument
  	 * @param {Object} opts
  	 * @param {Function} next callback
   */

  DocumentModel.prototype.renderDocument = function(opts, next) {
    var content, eventData, extension, file, ref, templateData;
    file = this;
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    content = opts.content, templateData = opts.templateData;
    extension = this.get('extensions')[0];
    if (content == null) {
      content = this.get('body');
    }
    if (templateData == null) {
      templateData = {};
    }
    eventData = {
      extension: extension,
      templateData: templateData,
      file: file,
      content: content
    };
    file.trigger('renderDocument', eventData, function(err) {
      return next(err, eventData.content);
    });
    return this;
  };


  /**
  	 * Render and merge layout content. Merge
  	 * layout metadata with document metadata.
  	 * Return the resulting merged content to
  	 * the callback result parameter.
  	 * next(err,result)
  	 * @private
  	 * @method renderLayouts
  	 * @param {Object} opts
  	 * @param {Function} next callback
   */

  DocumentModel.prototype.renderLayouts = function(opts, next) {
    var content, file, filePath, locale, ref, templateData;
    file = this;
    locale = this.getLocale();
    filePath = this.getFilePath();
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    content = opts.content, templateData = opts.templateData;
    if (content == null) {
      content = this.get('body');
    }
    if (templateData == null) {
      templateData = {};
    }
    return file.getLayout(function(err, layout) {
      var layoutSelector;
      if (err) {
        return next(err, content);
      }
      if (layout) {
        templateData.content = content;
        return layout.clone().action('render', {
          templateData: templateData
        }, function(err, result) {
          return next(err, result);
        });
      } else if (file.hasLayout()) {
        layoutSelector = file.get('layout');
        err = new Error(util.format(locale.documentMissingLayoutError, layoutSelector, filePath));
        return next(err, content);
      } else {
        return next(null, content);
      }
    });
  };


  /**
  	 * Triggers the render process for this document.
  	 * Calls the renderExtensions, renderDocument and
  	 * renderLayouts methods in sequence. This is the
  	 * method you want to call if you want to trigger
  	 * the rendering of a document manually.
  	 *
  	 * The rendered content is returned as the result
  	 * parameter to the passed callback and the DocumentModel
  	 * instance is returned in the document parameter.
  	 * next(err,result,document)
  	 * @method render
  	 * @param {Object} [opts={}]
  	 * @param {Function} next callback
   */

  DocumentModel.prototype.render = function(opts, next) {
    var base, base1, contentRenderedWithoutLayouts, err, file, filePath, key, locale, ref, ref1, relativePath, tasks, value;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    file = this;
    locale = this.getLocale();
    contentRenderedWithoutLayouts = null;
    filePath = this.getFilePath();
    relativePath = file.get('relativePath');
    opts = extendr.clone(opts || {});
    if (opts.actions == null) {
      opts.actions = ['renderExtensions', 'renderDocument', 'renderLayouts'];
    }
    if (opts.apply != null) {
      err = new Error(locale.documentApplyError);
      return next(err);
    }
    if (opts.content == null) {
      opts.content = file.get('body');
    }
    opts.templateData = extendr.clone(opts.templateData || {});
    if ((base = opts.templateData).document == null) {
      base.document = file.toJSON();
    }
    if ((base1 = opts.templateData).documentModel == null) {
      base1.documentModel = file;
    }
    ref1 = opts.templateData;
    for (key in ref1) {
      if (!hasProp.call(ref1, key)) continue;
      value = ref1[key];
      if ((value != null ? value.bind : void 0) === Function.prototype.bind) {
        opts.templateData[key] = value.bind(opts.templateData);
      }
    }
    file.log('debug', util.format(locale.documentRender, filePath));
    tasks = new this.TaskGroup("render tasks for: " + relativePath, {
      next: function(err) {
        var contentRendered, rendered;
        if (err) {
          err.context = util.format(locale.documentRenderError, filePath);
          return next(err, opts.content, file);
        }
        contentRendered = opts.content;
        if (contentRenderedWithoutLayouts == null) {
          contentRenderedWithoutLayouts = contentRendered;
        }
        rendered = true;
        file.set({
          contentRendered: contentRendered,
          contentRenderedWithoutLayouts: contentRenderedWithoutLayouts,
          rendered: rendered
        });
        file.log('debug', util.format(locale.documentRendered, filePath));
        file.attributes.rtime = new Date();
        return next(null, opts.content, file);
      }
    });
    if (indexOf.call(opts.actions, 'renderExtensions') >= 0) {
      tasks.addTask("renderExtensions: " + relativePath, function(complete) {
        return file.renderExtensions(opts, function(err, result) {
          if (err) {
            return complete(err);
          }
          opts.content = result;
          return complete();
        });
      });
    }
    if (indexOf.call(opts.actions, 'renderDocument') >= 0) {
      tasks.addTask("renderDocument: " + relativePath, function(complete) {
        return file.renderDocument(opts, function(err, result) {
          if (err) {
            return complete(err);
          }
          opts.content = result;
          contentRenderedWithoutLayouts = result;
          return complete();
        });
      });
    }
    if (indexOf.call(opts.actions, 'renderLayouts') >= 0) {
      tasks.addTask("renderLayouts: " + relativePath, function(complete) {
        return file.renderLayouts(opts, function(err, result) {
          if (err) {
            return complete(err);
          }
          opts.content = result;
          return complete();
        });
      });
    }
    tasks.run();
    return this;
  };


  /**
  	 * Write the source file. Optionally pass
  	 * the opts parameter to modify or set the file's
  	 * path, content or type.
  	 * next(err)
  	 * @method writeSource
  	 * @param {Object} [opts]
  	 * @param {Object} next callback
   */

  DocumentModel.prototype.writeSource = function(opts, next) {
    var body, content, file, filePath, header, metaData, parser, ref, seperator, source;
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    file = this;
    filePath = this.getFilePath();
    if (opts.content == null) {
      opts.content = (this.getContent() || '').toString('');
    }
    metaData = this.getMeta().toJSON(true);
    delete metaData.writeSource;
    content = body = opts.content.replace(/^\s+/, '');
    header = CSON.stringify(metaData);
    if (header instanceof Error) {
      header.context = "Failed to write CSON meta header for the file: " + filePath;
      return next(header);
    }
    if (!header || header === '{}') {
      source = body;
    } else {
      parser = 'cson';
      seperator = '###';
      source = seperator + " " + parser + "\n" + header + "\n" + seperator + "\n\n" + body;
    }
    opts.content = source;
    DocumentModel.__super__.writeSource.call(this, opts, next);
    return this;
  };

  return DocumentModel;

})(FileModel);

module.exports = DocumentModel;
