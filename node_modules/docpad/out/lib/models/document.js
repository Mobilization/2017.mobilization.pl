// Generated by CoffeeScript 1.9.1
(function() {
  var CSON, DocumentModel, FileModel, TaskGroup, YAML, docpadUtil, eachr, extendr, extractOptsAndCallback, pathUtil, util,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  util = require('util');

  pathUtil = require('path');

  docpadUtil = require('../util');

  CSON = require('cson');

  extendr = require('extendr');

  eachr = require('eachr');

  TaskGroup = require('taskgroup').TaskGroup;

  extractOptsAndCallback = require('extract-opts');

  FileModel = require('./file');

  YAML = null;

  DocumentModel = (function(superClass) {
    extend(DocumentModel, superClass);

    function DocumentModel() {
      return DocumentModel.__super__.constructor.apply(this, arguments);
    }

    DocumentModel.prototype.klass = DocumentModel;

    DocumentModel.prototype.type = 'document';

    DocumentModel.prototype.defaults = extendr.extend({}, FileModel.prototype.defaults, {
      referencesOthers: false,
      header: null,
      parser: null,
      body: null,
      rendered: false,
      contentRendered: null,
      contentRenderedWithoutLayouts: null,
      render: true,
      renderSingleExtensions: false
    });

    DocumentModel.prototype.getOutContent = function() {
      var content;
      content = this.get('contentRendered') || this.getContent();
      return content;
    };

    DocumentModel.prototype.referencesOthers = function(flag) {
      if (flag == null) {
        flag = true;
      }
      this.set({
        referencesOthers: flag
      });
      return this;
    };

    DocumentModel.prototype.parse = function(opts, next) {
      var buffer, filePath, locale, ref;
      if (opts == null) {
        opts = {};
      }
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      buffer = this.getBuffer();
      locale = this.getLocale();
      filePath = this.getFilePath();
      DocumentModel.__super__.parse.call(this, opts, (function(_this) {
        return function() {
          var body, content, csonOptions, err, header, i, j, key, len, len1, match, meta, metaDataChanges, metaParseResult, parser, ref1, ref2, ref3, ref4, regex, seperator;
          meta = _this.getMeta();
          metaDataChanges = {};
          parser = header = body = content = null;
          content = _this.get('content').replace(/\r\n?/gm, '\n');
          regex = /^\s*[^\n]*?(([^\s\d\w])\2{2,})(?:\x20*([a-z]+))?([\s\S]*?)[^\n]*?\1[^\n]*/;
          match = regex.exec(content);
          if (match) {
            seperator = match[1];
            parser = match[3] || 'yaml';
            header = match[4].trim();
            body = content.substring(match[0].length).trim();
            try {
              switch (parser) {
                case 'cson':
                case 'json':
                case 'coffee':
                case 'coffeescript':
                case 'coffee-script':
                case 'js':
                case 'javascript':
                  switch (parser) {
                    case 'coffee':
                    case 'coffeescript':
                    case 'coffee-script':
                      parser = 'coffeescript';
                      break;
                    case 'js':
                    case 'javascript':
                      parser = 'javascript';
                  }
                  csonOptions = {
                    format: parser,
                    json: true,
                    cson: true,
                    coffeescript: true,
                    javascript: true
                  };
                  metaParseResult = CSON.parseString(header, csonOptions);
                  if (metaParseResult instanceof Error) {
                    metaParseResult.context = "Failed to parse " + parser + " meta header for the file: " + filePath;
                    return next(metaParseResult);
                  }
                  extendr.extend(metaDataChanges, metaParseResult);
                  break;
                case 'yaml':
                  if (!YAML) {
                    YAML = require('yamljs');
                  }
                  metaParseResult = YAML.parse(header.replace(/\t/g, '    '));
                  extendr.extend(metaDataChanges, metaParseResult);
                  break;
                default:
                  err = new Error(util.format(locale.documentMissingParserError, parser, filePath));
                  return next(err);
              }
            } catch (_error) {
              err = _error;
              err.context = util.format(locale.documentParserError, parser, filePath);
              return next(err);
            }
          } else {
            body = content;
          }
          if (metaDataChanges.encoding && metaDataChanges.encoding !== _this.get('encoding')) {
            _this.set({
              encoding: metaDataChanges.encoding
            });
            opts.reencode = true;
            return _this.parse(opts, next);
          }
          body = body.replace(/^\n+/, '');
          _this.set({
            source: content,
            content: body,
            header: header,
            body: body,
            parser: parser,
            name: _this.get('name') || _this.get('title') || _this.get('basename')
          });
          if (metaDataChanges.date) {
            metaDataChanges.date = new Date(metaDataChanges.date);
          }
          ref1 = ['ignore', 'skip', 'draft'];
          for (i = 0, len = ref1.length; i < len; i++) {
            key = ref1[i];
            if (metaDataChanges[key] != null) {
              metaDataChanges.ignored = (ref2 = metaDataChanges[key]) != null ? ref2 : false;
              delete metaDataChanges[key];
            }
          }
          ref3 = ['published'];
          for (j = 0, len1 = ref3.length; j < len1; j++) {
            key = ref3[j];
            if (metaDataChanges[key] != null) {
              metaDataChanges.ignored = !((ref4 = metaDataChanges[key]) != null ? ref4 : false);
              delete metaDataChanges[key];
            }
          }
          if (metaDataChanges.urls) {
            _this.addUrl(metaDataChanges.urls);
          }
          if (metaDataChanges.url) {
            _this.setUrl(metaDataChanges.url);
          }
          if (metaDataChanges.id != null) {
            _this.log('warn', util.format(locale.documentIdChangeError, filePath));
            delete metaDataChanges.id;
          }
          _this.setMeta(metaDataChanges);
          return next();
        };
      })(this));
      return this;
    };

    DocumentModel.prototype.normalize = function(opts, next) {
      var changes, extensions, filename, meta, outExtension, ref;
      if (opts == null) {
        opts = {};
      }
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      changes = {};
      meta = this.getMeta();
      outExtension = opts.outExtension || meta.get('outExtension') || null;
      filename = opts.filename || this.get('filename') || null;
      extensions = this.getExtensions({
        filename: filename
      }) || null;
      if (!outExtension) {
        changes.outExtension = outExtension = extensions[0] || null;
      }
      DocumentModel.__super__.normalize.call(this, extendr.extend(opts, changes), next);
      return this;
    };

    DocumentModel.prototype.contextualize = function(opts, next) {
      var ref;
      if (opts == null) {
        opts = {};
      }
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      this.getEve((function(_this) {
        return function(err, eve) {
          var changes, extensions, meta, outExtension, outFilename, outPath;
          if (err) {
            return next(err);
          }
          changes = {};
          meta = _this.getMeta();
          outFilename = opts.outFilename || meta.get('outFilename') || null;
          outPath = opts.outPath || meta.get('outPath') || null;
          outExtension = opts.outExtension || meta.get('outExtension') || null;
          extensions = _this.getExtensions({
            filename: outFilename
          }) || null;
          if (!outExtension) {
            if (!outFilename && !outPath) {
              if (eve != null) {
                changes.outExtension = outExtension = eve.get('outExtension') || extensions[0] || null;
              } else {
                changes.outExtension = extensions[0] || null;
              }
            }
          }
          return _this.normalize(extendr.extend(opts, changes), next);
        };
      })(this));
      return this;
    };

    DocumentModel.prototype.hasLayout = function() {
      return this.get('layout') != null;
    };

    DocumentModel.prototype.getLayout = function(next) {
      var file, layoutSelector;
      file = this;
      layoutSelector = this.get('layout');
      if (!layoutSelector) {
        return next(null, null);
      }
      this.emit('getLayout', {
        selector: layoutSelector
      }, function(err, opts) {
        var layout;
        layout = opts.layout;
        if (err) {
          file.set({
            'layoutRelativePath': null
          });
          return next(err);
        } else if (!layout) {
          file.set({
            'layoutRelativePath': null
          });
          return next();
        } else {
          file.set({
            'layoutRelativePath': layout.get('relativePath')
          });
          return next(null, layout);
        }
      });
      return this;
    };

    DocumentModel.prototype.getEve = function(next) {
      if (this.hasLayout()) {
        this.getLayout(function(err, layout) {
          if (err) {
            return next(err, null);
          } else if (layout) {
            return layout.getEve(next);
          } else {
            return next(null, null);
          }
        });
      } else {
        next(null, this);
      }
      return this;
    };

    DocumentModel.prototype.renderExtensions = function(opts, next) {
      var content, extension, extensions, extensionsReversed, file, filePath, filename, i, len, locale, ref, renderSingleExtensions, result, tasks, templateData;
      file = this;
      locale = this.getLocale();
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      content = opts.content, templateData = opts.templateData, renderSingleExtensions = opts.renderSingleExtensions;
      extensions = this.get('extensions');
      filename = this.get('filename');
      filePath = this.getFilePath();
      if (content == null) {
        content = this.get('body');
      }
      if (templateData == null) {
        templateData = {};
      }
      if (renderSingleExtensions == null) {
        renderSingleExtensions = this.get('renderSingleExtensions');
      }
      result = content;
      extensionsReversed = [];
      if (extensions.length === 0 && filename) {
        extensionsReversed.push(filename);
      }
      for (i = 0, len = extensions.length; i < len; i++) {
        extension = extensions[i];
        extensionsReversed.unshift(extension);
      }
      if (renderSingleExtensions && extensionsReversed.length === 1) {
        if (renderSingleExtensions !== 'auto' || filename.replace(/^\./, '') === extensionsReversed[0]) {
          extensionsReversed.push(null);
        }
      }
      if (extensionsReversed.length <= 1) {
        return next(null, result);
      }
      tasks = new this.TaskGroup("renderExtensions: " + filePath, {
        next: function(err) {
          return next(err, result);
        }
      });
      eachr(extensionsReversed.slice(1), function(extension, index) {
        return tasks.addTask("renderExtension: " + filePath + " [" + extensionsReversed[index] + " => " + extension + "]", function(complete) {
          var eventData;
          eventData = {
            inExtension: extensionsReversed[index],
            outExtension: extension,
            templateData: templateData,
            file: file,
            content: result
          };
          return file.trigger('render', eventData, function(err) {
            if (err) {
              return complete(err);
            }
            if (result && (result === eventData.content)) {
              file.log('warn', util.format(locale.documentRenderExtensionNoChange, eventData.inExtension, eventData.outExtension, filePath));
              return complete();
            }
            result = eventData.content;
            return complete();
          });
        });
      });
      tasks.run();
      return this;
    };

    DocumentModel.prototype.renderDocument = function(opts, next) {
      var content, eventData, extension, file, ref, templateData;
      file = this;
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      content = opts.content, templateData = opts.templateData;
      extension = this.get('extensions')[0];
      if (content == null) {
        content = this.get('body');
      }
      if (templateData == null) {
        templateData = {};
      }
      eventData = {
        extension: extension,
        templateData: templateData,
        file: file,
        content: content
      };
      file.trigger('renderDocument', eventData, function(err) {
        return next(err, eventData.content);
      });
      return this;
    };

    DocumentModel.prototype.renderLayouts = function(opts, next) {
      var content, file, filePath, locale, ref, templateData;
      file = this;
      locale = this.getLocale();
      filePath = this.getFilePath();
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      content = opts.content, templateData = opts.templateData;
      if (content == null) {
        content = this.get('body');
      }
      if (templateData == null) {
        templateData = {};
      }
      return file.getLayout(function(err, layout) {
        var layoutSelector;
        if (err) {
          return next(err, content);
        }
        if (layout) {
          templateData.content = content;
          return layout.clone().action('render', {
            templateData: templateData
          }, function(err, result) {
            return next(err, result);
          });
        } else if (file.hasLayout()) {
          layoutSelector = file.get('layout');
          err = new Error(util.format(locale.documentMissingLayoutError, layoutSelector, filePath));
          return next(err, content);
        } else {
          return next(null, content);
        }
      });
    };

    DocumentModel.prototype.render = function(opts, next) {
      var base, base1, contentRenderedWithoutLayouts, err, file, filePath, key, locale, ref, ref1, relativePath, tasks, value;
      if (opts == null) {
        opts = {};
      }
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      file = this;
      locale = this.getLocale();
      contentRenderedWithoutLayouts = null;
      filePath = this.getFilePath();
      relativePath = file.get('relativePath');
      opts = extendr.clone(opts || {});
      if (opts.actions == null) {
        opts.actions = ['renderExtensions', 'renderDocument', 'renderLayouts'];
      }
      if (opts.apply != null) {
        err = new Error(locale.documentApplyError);
        return next(err);
      }
      if (opts.content == null) {
        opts.content = file.get('body');
      }
      opts.templateData = extendr.clone(opts.templateData || {});
      if ((base = opts.templateData).document == null) {
        base.document = file.toJSON();
      }
      if ((base1 = opts.templateData).documentModel == null) {
        base1.documentModel = file;
      }
      ref1 = opts.templateData;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        value = ref1[key];
        if ((value != null ? value.bind : void 0) === Function.prototype.bind) {
          opts.templateData[key] = value.bind(opts.templateData);
        }
      }
      file.log('debug', util.format(locale.documentRender, filePath));
      tasks = new this.TaskGroup("render tasks for: " + relativePath, {
        next: function(err) {
          var contentRendered, rendered;
          if (err) {
            err.context = util.format(locale.documentRenderError, filePath);
            return next(err, opts.content, file);
          }
          contentRendered = opts.content;
          if (contentRenderedWithoutLayouts == null) {
            contentRenderedWithoutLayouts = contentRendered;
          }
          rendered = true;
          file.set({
            contentRendered: contentRendered,
            contentRenderedWithoutLayouts: contentRenderedWithoutLayouts,
            rendered: rendered
          });
          file.log('debug', util.format(locale.documentRendered, filePath));
          file.attributes.rtime = new Date();
          return next(null, opts.content, file);
        }
      });
      if (indexOf.call(opts.actions, 'renderExtensions') >= 0) {
        tasks.addTask("renderExtensions: " + relativePath, function(complete) {
          return file.renderExtensions(opts, function(err, result) {
            if (err) {
              return complete(err);
            }
            opts.content = result;
            return complete();
          });
        });
      }
      if (indexOf.call(opts.actions, 'renderDocument') >= 0) {
        tasks.addTask("renderDocument: " + relativePath, function(complete) {
          return file.renderDocument(opts, function(err, result) {
            if (err) {
              return complete(err);
            }
            opts.content = result;
            contentRenderedWithoutLayouts = result;
            return complete();
          });
        });
      }
      if (indexOf.call(opts.actions, 'renderLayouts') >= 0) {
        tasks.addTask("renderLayouts: " + relativePath, function(complete) {
          return file.renderLayouts(opts, function(err, result) {
            if (err) {
              return complete(err);
            }
            opts.content = result;
            return complete();
          });
        });
      }
      tasks.run();
      return this;
    };

    DocumentModel.prototype.writeSource = function(opts, next) {
      var body, content, file, filePath, header, metaData, parser, ref, seperator, source;
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      file = this;
      filePath = this.getFilePath();
      if (opts.content == null) {
        opts.content = (this.getContent() || '').toString('');
      }
      metaData = this.getMeta().toJSON(true);
      delete metaData.writeSource;
      content = body = opts.content.replace(/^\s+/, '');
      header = CSON.stringify(metaData);
      if (header instanceof Error) {
        header.context = "Failed to write CSON meta header for the file: " + filePath;
        return next(header);
      }
      if (!header || header === '{}') {
        source = body;
      } else {
        parser = 'cson';
        seperator = '###';
        source = seperator + " " + parser + "\n" + header + "\n" + seperator + "\n\n" + body;
      }
      opts.content = source;
      DocumentModel.__super__.writeSource.call(this, opts, next);
      return this;
    };

    return DocumentModel;

  })(FileModel);

  module.exports = DocumentModel;

}).call(this);
