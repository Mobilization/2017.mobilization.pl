// Generated by CoffeeScript 1.10.0
var FileModel, Model, TaskGroup, docpadUtil, encodingUtil, extendr, extractOptsAndCallback, isTextOrBinary, jschardet, mime, pathUtil, safefs, typeChecker, util,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

util = require('util');

pathUtil = require('path');

isTextOrBinary = require('istextorbinary');

typeChecker = require('typechecker');

TaskGroup = require('taskgroup').TaskGroup;

safefs = require('safefs');

mime = require('mime');

extendr = require('extendr');

extractOptsAndCallback = require('extract-opts');

jschardet = null;

encodingUtil = null;

Model = require('../base').Model;

docpadUtil = require('../util');


/**
 * The FileModel class is DocPad's representation
 * of a file in the file system.
 * Extends the DocPad Model class
 * https://github.com/docpad/docpad/blob/master/src/lib/base.coffee#L49.
 * FileModel manages the loading
 * of a file and parsing both the content and the metadata (if any).
 * Once loaded, the content, metadata and file stat (file info)
 * properties of the FileModel are populated, as well
 * as a number of DocPad specific attributes and properties.
 * Typically we do not need to create FileModels ourselves as
 * DocPad handles all of that. But it is possible that a plugin
 * may need to manually create FileModels for some reason.
 *
 *	attrs =
 *		fullPath: 'file/path/to/somewhere'
 *	opts = {}
 *	#we only really need the path to the source file to create
 *	#a new file model
 *	model = new FileModel(attrs, opts)
 *
 * The FileModel forms the base class for the DocPad DocumentModel class.
 * @class FileModel
 * @constructor
 * @extends Model
 */

FileModel = (function(superClass) {
  extend(FileModel, superClass);

  function FileModel() {
    this.action = bind(this.action, this);
    return FileModel.__super__.constructor.apply(this, arguments);
  }


  /**
  	 * The file model class. This should
  	 * be overridden in any descending classes.
  	 * @private
  	 * @property {Object} klass
   */

  FileModel.prototype.klass = FileModel;


  /**
  	 * String name of the model type.
  	 * In this case, 'file'. This should
  	 * be overridden in any descending classes.
  	 * @private
  	 * @property {String} type
   */

  FileModel.prototype.type = 'file';


  /**
  	 * Task Group Class
  	 * @private
  	 * @property {Object} TaskGroup
   */

  FileModel.prototype.TaskGroup = null;


  /**
  	 * The out directory path to put the relative path.
  	 * @property {String} rootOutDirPath
   */

  FileModel.prototype.rootOutDirPath = null;


  /**
  	 * Whether or not we should detect encoding
  	 * @property {Boolean} detectEncoding
   */

  FileModel.prototype.detectEncoding = false;


  /**
  	 * Node.js file stat object.
  	 * https://nodejs.org/api/fs.html#fs_class_fs_stats.
  	 * Basically, information about a file, including file
  	 * dates and size.
  	 * @property {Object} stat
   */

  FileModel.prototype.stat = null;


  /**
  	 * File buffer. Node.js Buffer object.
  	 * https://nodejs.org/api/buffer.html#buffer_class_buffer.
  	 * Provides methods for dealing with binary data directly.
  	 * @property {Object} buffer
   */

  FileModel.prototype.buffer = null;


  /**
  	 * Buffer time.
  	 * @property {Object} bufferTime
   */

  FileModel.prototype.bufferTime = null;


  /**
  	 * The parsed file meta data (header).
  	 * Is a Model instance.
  	 * @private
  	 * @property {Object} meta
   */

  FileModel.prototype.meta = null;


  /**
  	 * Locale information for the file
  	 * @private
  	 * @property {Object} locale
   */

  FileModel.prototype.locale = null;


  /**
  	 * Get the file's locale information
  	 * @method getLocale
  	 * @return {Object} the locale
   */

  FileModel.prototype.getLocale = function() {
    return this.locale;
  };


  /**
  	 * Get Options. Returns an object containing
  	 * the properties detectEncoding, rootOutDirPath
  	 * locale, stat, buffer, meta and TaskGroup.
  	 * @private
  	 * @method getOptions
  	 * @return {Object}
   */

  FileModel.prototype.getOptions = function() {
    return {
      detectEncoding: this.detectEncoding,
      rootOutDirPath: this.rootOutDirPath,
      locale: this.locale,
      stat: this.stat,
      buffer: this.buffer,
      meta: this.meta,
      TaskGroup: this.TaskGroup
    };
  };


  /**
  	 * Checks whether the passed key is one
  	 * of the options.
  	 * @private
  	 * @method isOption
  	 * @param {String} key
  	 * @return {Boolean}
   */

  FileModel.prototype.isOption = function(key) {
    var names, result;
    names = ['detectEncoding', 'rootOutDirPath', 'locale', 'stat', 'data', 'buffer', 'meta', 'TaskGroup'];
    result = indexOf.call(names, key) >= 0;
    return result;
  };


  /**
  	 * Extract Options.
  	 * @private
  	 * @method extractOptions
  	 * @param {Object} attrs
  	 * @return {Object} the options object
   */

  FileModel.prototype.extractOptions = function(attrs) {
    var key, result, value;
    result = {};
    for (key in attrs) {
      if (!hasProp.call(attrs, key)) continue;
      value = attrs[key];
      if (this.isOption(key)) {
        result[key] = value;
        delete attrs[key];
      }
    }
    return result;
  };


  /**
  	 * Set the options for the file model.
  	 * Valid properties for the attrs parameter:
  	 * TaskGroup, detectEncoding, rootOutDirPath,
  	 * locale, stat, data, buffer, meta.
  	 * @method setOptions
  	 * @param {Object} [attrs={}]
   */

  FileModel.prototype.setOptions = function(attrs) {
    if (attrs == null) {
      attrs = {};
    }
    if (attrs.TaskGroup != null) {
      this.TaskGroup = attrs.TaskGroup;
      delete this.attributes.TaskGroup;
    }
    if (attrs.detectEncoding != null) {
      this.rootOutDirPath = attrs.detectEncoding;
      delete this.attributes.detectEncoding;
    }
    if (attrs.rootOutDirPath != null) {
      this.rootOutDirPath = attrs.rootOutDirPath;
      delete this.attributes.rootOutDirPath;
    }
    if (attrs.locale != null) {
      this.locale = attrs.locale;
      delete this.attributes.locale;
    }
    if (attrs.stat != null) {
      this.setStat(attrs.stat);
      delete this.attributes.stat;
    }
    if (attrs.data != null) {
      this.setBuffer(attrs.data);
      delete this.attributes.data;
    }
    if (attrs.buffer != null) {
      this.setBuffer(attrs.buffer);
      delete this.attributes.buffer;
    }
    if (attrs.meta != null) {
      this.setMeta(attrs.meta);
      delete this.attributes.meta;
    }
    return this;
  };


  /**
  	 * Clone the model and return the newly cloned model.
  	 * @method clone
  	 * @return {Object} cloned file model
   */

  FileModel.prototype.clone = function() {
    var attrs, clonedModel, opts;
    attrs = this.getAttributes();
    opts = this.getOptions();
    delete attrs.id;
    delete attrs.meta.id;
    delete opts.meta.id;
    delete opts.meta.attributes.id;
    clonedModel = new this.klass(attrs, opts);
    this.emit('clone', clonedModel);
    return clonedModel;
  };


  /**
  	 * The default attributes for any file model.
  	 * @private
  	 * @property {Object}
   */

  FileModel.prototype.defaults = {
    id: null,
    basename: null,
    outBasename: null,
    extension: null,
    outExtension: null,
    extensions: null,
    filename: null,
    fullPath: null,
    fullDirPath: null,
    outPath: null,
    outDirPath: null,
    outFilename: null,
    relativePath: null,
    relativeOutPath: null,
    relativeDirPath: null,
    relativeOutDirPath: null,
    relativeBase: null,
    relativeOutBase: null,
    contentType: null,
    outContentType: null,
    ctime: null,
    mtime: null,
    rtime: null,
    wtime: null,
    exists: null,
    encoding: null,
    source: null,
    content: null,
    tags: null,
    render: false,
    write: true,
    writeSource: false,
    dynamic: false,
    title: null,
    name: null,
    date: null,
    slug: null,
    url: null,
    urls: null,
    ignored: false,
    standalone: false
  };


  /**
  	 * File encoding helper
  	 * opts = {path, to, from, content}
  	 * @private
  	 * @method encode
  	 * @param {Object} opts
  	 * @return {Object} encoded result
   */

  FileModel.prototype.encode = function(opts) {
    var err, error, locale, result;
    locale = this.getLocale();
    result = opts.content;
    if (opts.to == null) {
      opts.to = 'utf8';
    }
    if (opts.from == null) {
      opts.from = 'utf8';
    }
    try {
      if (encodingUtil == null) {
        encodingUtil = require('encoding');
      }
    } catch (undefined) {}
    if (encodingUtil != null) {
      this.log('info', util.format(locale.fileEncode, opts.to, opts.from, opts.path));
      try {
        result = encodingUtil.convert(opts.content, opts.to, opts.from);
      } catch (error) {
        err = error;
        this.log('warn', util.format(locale.fileEncodeConvertError, opts.to, opts.from, opts.path));
      }
    } else {
      this.log('warn', util.format(locale.fileEncodeConvertError, opts.to, opts.from, opts.path));
    }
    return result;
  };


  /**
  	 * Set the file model's buffer.
  	 * Creates a new node.js buffer
  	 * object if a buffer object is
  	 * is not passed as the parameter
  	 * @method setBuffer
  	 * @param {Object} [buffer]
   */

  FileModel.prototype.setBuffer = function(buffer) {
    if (!Buffer.isBuffer(buffer)) {
      buffer = new Buffer(buffer);
    }
    this.bufferTime = this.get('mtime') || new Date();
    this.buffer = buffer;
    return this;
  };


  /**
  	 * Get the file model's buffer object.
  	 * Returns a node.js buffer object.
  	 * @method getBuffer
  	 * @return {Object} node.js buffer object
   */

  FileModel.prototype.getBuffer = function() {
    return this.buffer;
  };


  /**
  	 * Is Buffer Outdated
  	 * True if there is no buffer OR the buffer time is outdated
  	 * @method isBufferOutdated
  	 * @return {Boolean}
   */

  FileModel.prototype.isBufferOutdated = function() {
    return (this.buffer != null) === false || this.bufferTime < (this.get('mtime') || new Date());
  };


  /**
  	 * Set the node.js file stat.
  	 * @method setStat
  	 * @param {Object} stat
   */

  FileModel.prototype.setStat = function(stat) {
    this.stat = stat;
    this.set({
      ctime: new Date(stat.ctime),
      mtime: new Date(stat.mtime)
    });
    return this;
  };


  /**
  	 * Get the node.js file stat.
  	 * @method getStat
  	 * @return {Object} the file stat
   */

  FileModel.prototype.getStat = function() {
    return this.stat;
  };


  /**
  	 * Get the file model attributes.
  	 * By default the attributes will be
  	 * dereferenced from the file model.
  	 * To maintain a reference, pass false
  	 * as the parameter. The returned object
  	 * will NOT contain the file model's ID attribute.
  	 * @method getAttributes
  	 * @param {Object} [dereference=true]
  	 * @return {Object}
   */

  FileModel.prototype.getAttributes = function(dereference) {
    var attrs;
    if (dereference == null) {
      dereference = true;
    }
    attrs = this.toJSON(dereference);
    delete attrs.id;
    return attrs;
  };


  /**
  	 * Get the file model attributes.
  	 * By default the attributes will
  	 * maintain a reference to the file model.
  	 * To return a dereferenced object, pass true
  	 * as the parameter. The returned object
  	 * will contain the file model's ID attribute.
  	 * @method toJSON
  	 * @param {Object} [dereference=false]
  	 * @return {Object}
   */

  FileModel.prototype.toJSON = function(dereference) {
    var data;
    if (dereference == null) {
      dereference = false;
    }
    data = FileModel.__super__.toJSON.apply(this, arguments);
    data.meta = this.getMeta().toJSON();
    if (dereference === true) {
      data = extendr.dereference(data);
    }
    return data;
  };


  /**
  	 * Get the file model metadata object.
  	 * Optionally pass a list of metadata property
  	 * names corresponding to those properties that
  	 * you want returned.
  	 * @method getMeta
  	 * @param {Object} [args...]
  	 * @return {Object}
   */

  FileModel.prototype.getMeta = function() {
    var args, ref;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (this.meta === null) {
      this.meta = new Model();
    }
    if (args.length) {
      return (ref = this.meta).get.apply(ref, args);
    } else {
      return this.meta;
    }
  };


  /**
  	 * Assign attributes and options to the file model.
  	 * @method set
  	 * @param {Array} attrs the attributes to be applied
  	 * @param {Object} opts the options to be applied
   */

  FileModel.prototype.set = function(attrs, opts) {
    var newAttrs, options, ref;
    if (typeChecker.isString(attrs)) {
      newAttrs = {};
      newAttrs[attrs] = opts;
      return this.set(newAttrs, opts);
    }
    attrs = (ref = typeof attrs.toJSON === "function" ? attrs.toJSON() : void 0) != null ? ref : attrs;
    options = this.extractOptions(attrs);
    FileModel.__super__.set.call(this, attrs, opts);
    this.setOptions(options, opts);
    return this;
  };


  /**
  	 * Set defaults. Apply default attributes
  	 * and options to the file model
  	 * @method setDefaults
  	 * @param {Object} attrs the attributes to be applied
  	 * @param {Object} opts the options to be applied
   */

  FileModel.prototype.setDefaults = function(attrs, opts) {
    var options, ref;
    attrs = (ref = typeof attrs.toJSON === "function" ? attrs.toJSON() : void 0) != null ? ref : attrs;
    options = this.extractOptions(attrs);
    FileModel.__super__.setDefaults.call(this, attrs, opts);
    this.setOptions(options, opts);
    return this;
  };


  /**
  	 * Set the file model meta data,
  	 * attributes and options in one go.
  	 * @method setMeta
  	 * @param {Object} attrs the attributes to be applied
  	 * @param {Object} opts the options to be applied
   */

  FileModel.prototype.setMeta = function(attrs, opts) {
    var options, ref;
    attrs = (ref = typeof attrs.toJSON === "function" ? attrs.toJSON() : void 0) != null ? ref : attrs;
    options = this.extractOptions(attrs);
    this.getMeta().set(attrs, opts);
    this.set(attrs, opts);
    this.setOptions(options, opts);
    return this;
  };


  /**
  	 * Set the file model meta data defaults
  	 * @method setMetaDefaults
  	 * @param {Object} attrs the attributes to be applied
  	 * @param {Object} opts the options to be applied
   */

  FileModel.prototype.setMetaDefaults = function(attrs, opts) {
    var options, ref;
    attrs = (ref = typeof attrs.toJSON === "function" ? attrs.toJSON() : void 0) != null ? ref : attrs;
    options = this.extractOptions(attrs);
    this.getMeta().setDefaults(attrs, opts);
    this.setDefaults(attrs, opts);
    this.setOptions(options, opts);
    return this;
  };


  /**
  	 * Get the file name. Depending on the
  	 * parameters passed this will either be
  	 * the file model's filename property or,
  	 * the filename determined from the fullPath
  	 * or relativePath property. Valid values for
  	 * the opts parameter are: fullPath, relativePath
  	 * or filename. Format: {filename}
  	 * @method getFilename
  	 * @param {Object} [opts={}]
  	 * @return {String}
   */

  FileModel.prototype.getFilename = function(opts) {
    var filename, fullPath, relativePath, result;
    if (opts == null) {
      opts = {};
    }
    fullPath = opts.fullPath, relativePath = opts.relativePath, filename = opts.filename;
    result = filename != null ? filename : this.get('filename');
    if (!result) {
      result = (fullPath != null ? fullPath : this.get('fullPath')) || (relativePath != null ? relativePath : this.get('relativePath'));
      if (result) {
        result = pathUtil.basename(result);
      }
    }
    result || (result = null);
    return result;
  };


  /**
  	 * Get the file path. Depending on the
  	 * parameters passed this will either be
  	 * the file model's fullPath property, the
  	 * relativePath property or the filename property.
  	 * Valid values for the opts parameter are:
  	 * fullPath, relativePath
  	 * or filename. Format: {fullPath}
  	 * @method getFilePath
  	 * @param {Object} [opts={}]
  	 * @return {String}
   */

  FileModel.prototype.getFilePath = function(opts) {
    var filename, fullPath, relativePath, result;
    if (opts == null) {
      opts = {};
    }
    fullPath = opts.fullPath, relativePath = opts.relativePath, filename = opts.filename;
    result = (fullPath != null ? fullPath : this.get('fullPath')) || (relativePath != null ? relativePath : this.get('relativePath')) || (filename != null ? filename : this.get('filename')) || null;
    return result;
  };


  /**
  	 * Get file extensions. Depending on the
  	 * parameters passed this will either be
  	 * the file model's extensions property or
  	 * the extensions extracted from the file model's
  	 * filename property. The opts parameter is passed
  	 * in the format: {extensions,filename}.
  	 * @method getExtensions
  	 * @param {Object} opts
  	 * @return {Array} array of extension names
   */

  FileModel.prototype.getExtensions = function(arg) {
    var extensions, filename;
    extensions = arg.extensions, filename = arg.filename;
    extensions || (extensions = this.get('extensions') || null);
    if ((extensions || []).length === 0) {
      filename = this.getFilename({
        filename: filename
      });
      if (filename) {
        extensions = docpadUtil.getExtensions(filename);
      }
    }
    return extensions || null;
  };


  /**
  	 * Get the file content. This will be
  	 * the text content if loaded or the file buffer object.
  	 * @method getContent
  	 * @return {String or Object}
   */

  FileModel.prototype.getContent = function() {
    return this.get('content') || this.getBuffer();
  };


  /**
  	 * Get the file content for output.
  	 * @method getOutContent
  	 * @return {String or Object}
   */

  FileModel.prototype.getOutContent = function() {
    return this.getContent();
  };


  /**
  	 * Is this a text file? ie - not
  	 * a binary file.
  	 * @method isText
  	 * @return {Boolean}
   */

  FileModel.prototype.isText = function() {
    return this.get('encoding') !== 'binary';
  };


  /**
  	 * Is this a binary file?
  	 * @method isBinary
  	 * @return {Boolean}
   */

  FileModel.prototype.isBinary = function() {
    return this.get('encoding') === 'binary';
  };


  /**
  	 * Set the url for the file
  	 * @method setUrl
  	 * @param {String} url
   */

  FileModel.prototype.setUrl = function(url) {
    this.addUrl(url);
    this.set({
      url: url
    });
    return this;
  };


  /**
  	 * A file can have multiple urls.
  	 * This method adds either a single url
  	 * or an array of urls to the file model.
  	 * @method addUrl
  	 * @param {String or Array} url
   */

  FileModel.prototype.addUrl = function(url) {
    var existingUrl, found, i, j, len, len1, newUrl, urls;
    if (url instanceof Array) {
      for (i = 0, len = url.length; i < len; i++) {
        newUrl = url[i];
        this.addUrl(newUrl);
      }
    } else if (url) {
      found = false;
      urls = this.get('urls');
      for (j = 0, len1 = urls.length; j < len1; j++) {
        existingUrl = urls[j];
        if (existingUrl === url) {
          found = true;
          break;
        }
      }
      if (!found) {
        urls.push(url);
      }
      this.trigger('change:urls', this, urls, {});
      this.trigger('change', this, {});
    }
    return this;
  };


  /**
  	 * Removes a url from the file
  	 * model (files can have more than one url).
  	 * @method removeUrl
  	 * @param {Object} userUrl the url to be removed
   */

  FileModel.prototype.removeUrl = function(userUrl) {
    var i, index, len, url, urls;
    urls = this.get('urls');
    for (index = i = 0, len = urls.length; i < len; index = ++i) {
      url = urls[index];
      if (url === userUrl) {
        urls.splice(index, 1);
        break;
      }
    }
    return this;
  };


  /**
  	 * Get a file path.
  	 * If the relativePath parameter starts with `.` then we get the
  	 * path in relation to the document that is calling it.
  	 * Otherwise we just return it as normal
  	 * @method getPath
  	 * @param {String} relativePath
  	 * @param {String} parentPath
  	 * @return {String}
   */

  FileModel.prototype.getPath = function(relativePath, parentPath) {
    var path, relativeDirPath;
    if (/^\./.test(relativePath)) {
      relativeDirPath = this.get('relativeDirPath');
      path = pathUtil.join(relativeDirPath, relativePath);
    } else {
      if (parentPath) {
        path = pathUtil.join(parentPath, relativePath);
      } else {
        path = relativePath;
      }
    }
    return path;
  };


  /**
  	 * The action runner instance bound to DocPad
  	 * @private
  	 * @property {Object} actionRunnerInstance
   */

  FileModel.prototype.actionRunnerInstance = null;


  /**
  	 * Get the action runner instance bound to DocPad
  	 * @method getActionRunner
  	 * @return {Object}
   */

  FileModel.prototype.getActionRunner = function() {
    return this.actionRunnerInstance;
  };


  /**
  	 * Apply an action with the supplied arguments.
  	 * @method action
  	 * @param {Object} args...
   */

  FileModel.prototype.action = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return docpadUtil.action.apply(this, args);
  };


  /**
  	 * Initialize the file model with the passed
  	 * attributes and options. Emits the init event.
  	 * @method initialize
  	 * @param {Object} attrs the file model attributes
  	 * @param {Object} [opts={}] the file model options
   */

  FileModel.prototype.initialize = function(attrs, opts) {
    var base, base1, base2, base3, base4, file, now;
    if (opts == null) {
      opts = {};
    }
    file = this;
    if (this.attributes == null) {
      this.attributes = {};
    }
    if ((base = this.attributes).extensions == null) {
      base.extensions = [];
    }
    if ((base1 = this.attributes).urls == null) {
      base1.urls = [];
    }
    now = new Date();
    if ((base2 = this.attributes).ctime == null) {
      base2.ctime = now;
    }
    if ((base3 = this.attributes).mtime == null) {
      base3.mtime = now;
    }
    if (this.id == null) {
      this.id = (base4 = this.attributes).id != null ? base4.id : base4.id = this.cid;
    }
    this.setOptions(opts);
    if ((this.rootOutDirPath != null) === false || (this.locale != null) === false) {
      throw new Error("Use docpad.createModel to create the file or document model");
    }
    this.actionRunnerInstance = new this.TaskGroup("file action runner").whenDone(function(err) {
      if (err) {
        return file.emit('error', err);
      }
    });
    this.emit('init');
    return this;
  };


  /**
  	 * Load the file from the file system.
  	 * If the fullPath exists, load the file.
  	 * If it doesn't, then parse and normalize the file.
  	 * Optionally pass file options as a parameter.
  	 * @method load
  	 * @param {Object} [opts={}]
  	 * @param {Function} next callback
   */

  FileModel.prototype.load = function(opts, next) {
    var file, filePath, fullPath, ref, tasks;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    file = this;
    if (opts.exists == null) {
      opts.exists = null;
    }
    fullPath = this.get('fullPath');
    filePath = this.getFilePath({
      fullPath: fullPath
    });
    if (opts.exists != null) {
      file.set({
        exists: opts.exists
      });
    }
    if (opts.stat != null) {
      file.setStat(opts.stat);
    }
    if (opts.buffer != null) {
      file.setBuffer(opts.buffer);
    }
    tasks = new this.TaskGroup("load tasks for file: " + filePath, {
      next: next
    }).on('item.run', function(item) {
      return file.log("debug", (item.getConfig().name) + ": " + file.type + ": " + filePath);
    });
    tasks.addTask("Detect the file", function(complete) {
      if (fullPath && opts.exists === null) {
        return safefs.exists(fullPath, function(exists) {
          opts.exists = exists;
          file.set({
            exists: opts.exists
          });
          return complete();
        });
      } else {
        return complete();
      }
    });
    tasks.addTask("Stat the file and cache the result", function(complete) {
      if (fullPath && opts.exists && (opts.stat != null) === false) {
        return safefs.stat(fullPath, function(err, fileStat) {
          if (err) {
            return complete(err);
          }
          file.setStat(fileStat);
          return complete();
        });
      } else {
        return complete();
      }
    });
    tasks.addTask("Read the file and cache the result", function(complete) {
      if (fullPath && opts.exists && (opts.buffer != null) === false && file.isBufferOutdated()) {
        return safefs.readFile(fullPath, function(err, buffer) {
          if (err) {
            return complete(err);
          }
          file.setBuffer(buffer);
          return complete();
        });
      } else {
        return complete();
      }
    });
    tasks.addTask("Load -> Parse", function(complete) {
      return file.parse(complete);
    });
    tasks.addTask("Parse -> Normalize", function(complete) {
      return file.normalize(complete);
    });
    tasks.addTask("Normalize -> Contextualize", function(complete) {
      return file.contextualize(complete);
    });
    tasks.run();
    return this;
  };


  /**
  	 * Parse our buffer and extract meaningful data from it.
  	 * next(err).
  	 * @method parse
  	 * @param {Object} [opts={}]
  	 * @param {Object} next callback
   */

  FileModel.prototype.parse = function(opts, next) {
    var buffer, changes, content, encoding, isText, ref, ref1, relativePath, source;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    buffer = this.getBuffer();
    relativePath = this.get('relativePath');
    encoding = opts.encoding || this.get('encoding') || null;
    changes = {};
    if (buffer && (encoding != null) === false || opts.reencode === true) {
      isText = isTextOrBinary.isTextSync(relativePath, buffer);
      if (isText === true) {
        if (this.detectEncoding) {
          if (jschardet == null) {
            jschardet = require('jschardet');
          }
          if (encoding == null) {
            encoding = (ref1 = jschardet.detect(buffer)) != null ? ref1.encoding : void 0;
          }
        }
        encoding || (encoding = 'utf8');
        if (docpadUtil.isStandardEncoding(encoding) === false) {
          buffer = this.encode({
            path: relativePath,
            to: 'utf8',
            from: encoding,
            content: buffer
          });
        }
        changes.encoding = encoding;
      } else {
        encoding = changes.encoding = 'binary';
      }
    }
    if (encoding === 'binary') {
      content = source = '';
      changes.content = content;
      changes.source = source;
    } else {
      if ((encoding != null) === false) {
        encoding = changes.encoding = 'utf8';
      }
      source = (buffer != null ? buffer.toString('utf8') : void 0) || '';
      content = source;
      changes.content = content;
      changes.source = source;
    }
    this.set(changes);
    next();
    return this;
  };


  /**
  	 * Normalize any parsing we have done, because if a value has
  	 * updates it may have consequences on another value.
  	 * This will ensure everything is okay.
  	 * next(err)
  	 * @method normalize
  	 * @param {Object} [opts={}]
  	 * @param {Object} next callback
   */

  FileModel.prototype.normalize = function(opts, next) {
    var _defaultUrl, basename, changes, contentType, ctime, date, err, extension, extensions, filename, fullDirPath, fullPath, locale, meta, mtime, name, outBasename, outContentType, outDirPath, outExtension, outFilename, outPath, ref, relativeBase, relativeDirPath, relativeOutBase, relativeOutDirPath, relativeOutPath, relativePath, rtime, slug, tags, url, wtime;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    changes = {};
    meta = this.getMeta();
    locale = this.getLocale();
    filename = opts.filename || this.get('filename') || null;
    relativePath = opts.relativePath || this.get('relativePath') || null;
    fullPath = opts.fullPath || this.get('fullPath') || null;
    mtime = opts.mtime || this.get('mtime') || null;
    tags = opts.tags || meta.get('tags') || null;
    date = opts.date || meta.get('date') || null;
    name = opts.name || meta.get('name') || null;
    slug = opts.slug || meta.get('slug') || null;
    url = opts.url || meta.get('url') || null;
    contentType = opts.contentType || meta.get('contentType') || null;
    outContentType = opts.outContentType || meta.get('outContentType') || null;
    outFilename = opts.outFilename || meta.get('outFilename') || null;
    outExtension = opts.outExtension || meta.get('outExtension') || null;
    outPath = opts.outPath || meta.get('outPath') || null;
    extensions = null;
    extension = null;
    basename = null;
    outBasename = null;
    relativeOutPath = null;
    relativeDirPath = null;
    relativeOutDirPath = null;
    relativeBase = null;
    relativeOutBase = null;
    outDirPath = null;
    fullDirPath = null;
    changes.filename = filename = this.getFilename({
      filename: filename,
      relativePath: relativePath,
      fullPath: fullPath
    });
    if (!filename) {
      err = new Error(locale.filenameMissingError);
      return next(err);
    }
    if (!relativePath && filename) {
      changes.relativePath = relativePath = filename;
    }
    changes.basename = basename = docpadUtil.getBasename(filename);
    changes.extensions = extensions = this.getExtensions({
      filename: filename
    });
    changes.extension = extension = docpadUtil.getExtension(extensions);
    if (fullPath) {
      changes.fullDirPath = fullDirPath = docpadUtil.getDirPath(fullPath);
    }
    changes.relativeDirPath = relativeDirPath = docpadUtil.getDirPath(relativePath);
    changes.relativeBase = relativeBase = relativeDirPath ? pathUtil.join(relativeDirPath, basename) : basename;
    if (!contentType) {
      changes.contentType = contentType = mime.lookup(fullPath || relativePath);
    }
    if (tags && typeChecker.isArray(tags) === false) {
      changes.tags = tags = String(tags).split(/[\s,]+/);
    }
    if (!date) {
      changes.date = date = mtime || this.get('date') || new Date();
    }
    if (!outFilename && !outPath) {
      changes.outFilename = outFilename = docpadUtil.getOutFilename(basename, outExtension || extensions.join('.'));
    }
    if (!outPath) {
      changes.outPath = outPath = this.rootOutDirPath ? pathUtil.resolve(this.rootOutDirPath, relativeDirPath, outFilename) : null;
    }
    if (outPath) {
      changes.outFilename = outFilename = docpadUtil.getFilename(outPath);
    }
    changes.outDirPath = outDirPath = outPath ? docpadUtil.getDirPath(outPath) : null;
    changes.outBasename = outBasename = docpadUtil.getBasename(outFilename);
    changes.outExtension = outExtension = docpadUtil.getExtension(outFilename);
    changes.relativeOutPath = relativeOutPath = outPath ? outPath.replace(this.rootOutDirPath, '').replace(/^[\/\\]/, '') : pathUtil.join(relativeDirPath, outFilename);
    changes.relativeOutDirPath = relativeOutDirPath = docpadUtil.getDirPath(relativeOutPath);
    changes.relativeOutBase = relativeOutBase = pathUtil.join(relativeOutDirPath, outBasename);
    if (!name) {
      changes.name = name = outFilename;
    }
    _defaultUrl = docpadUtil.getUrl(relativeOutPath);
    if (url) {
      this.setUrl(url);
      this.addUrl(_defaultUrl);
    } else {
      this.setUrl(_defaultUrl);
    }
    if (!outContentType && contentType) {
      changes.outContentType = outContentType = mime.lookup(outPath || relativeOutPath) || contentType;
    }
    if (!slug) {
      changes.slug = slug = docpadUtil.getSlug(relativeOutBase);
    }
    if (typeof wtime === 'string') {
      changes.wtime = wtime = new Date(wtime);
    }
    if (typeof rtime === 'string') {
      changes.rtime = rtime = new Date(rtime);
    }
    if (typeof ctime === 'string') {
      changes.ctime = ctime = new Date(ctime);
    }
    if (typeof mtime === 'string') {
      changes.mtime = mtime = new Date(mtime);
    }
    if (typeof date === 'string') {
      changes.date = date = new Date(date);
    }
    this.set(changes);
    next();
    return this;
  };


  /**
  	 * Contextualize the data. In other words,
  	 * put our data into the perspective of the bigger picture of the data.
  	 * For instance, generate the url for it's rendered equivalant.
  	 * next(err)
  	 * @method contextualize
  	 * @param {Object} [opts={}]
  	 * @param {Object} next callback
   */

  FileModel.prototype.contextualize = function(opts, next) {
    var ref;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    next();
    return this;
  };


  /**
  	 * Render this file. The file model output content is
  	 * returned to the passed callback in the
  	 * result (2nd) parameter. The file model itself is returned
  	 * in the callback's document (3rd) parameter.
  	 * next(err,result,document)
  	 * @method render
  	 * @param {Object} [opts={}]
  	 * @param {Object} next callback
   */

  FileModel.prototype.render = function(opts, next) {
    var file, ref;
    if (opts == null) {
      opts = {};
    }
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    file = this;
    file.attributes.rtime = new Date();
    next(null, file.getOutContent(), file);
    return this;
  };


  /**
  	 * Write the out file. The out file
  	 * may be different from the input file.
  	 * Often the input file is transformed in some way
  	 * and saved as another file format. A common example
  	 * is transforming a markdown input file to a HTML
  	 * output file.
  	 * next(err)
  	 * @method write
  	 * @param {Object} opts
  	 * @param {Function} next callback
   */

  FileModel.prototype.write = function(opts, next) {
    var file, locale, ref, ref1;
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    file = this;
    locale = this.getLocale();
    opts.path || (opts.path = file.get('outPath'));
    opts.encoding || (opts.encoding = file.get('encoding') || 'utf8');
    opts.content || (opts.content = file.getOutContent());
    opts.type || (opts.type = 'out file');
    if (!opts.path) {
      next();
      return this;
    }
    if ((ref1 = opts.encoding.toLowerCase()) !== 'ascii' && ref1 !== 'utf8' && ref1 !== 'utf-8' && ref1 !== 'binary') {
      opts.content = this.encode({
        path: opts.path,
        to: opts.encoding,
        from: 'utf8',
        content: opts.content
      });
    }
    file.log('debug', util.format(locale.fileWrite, opts.type, opts.path, opts.encoding));
    safefs.writeFile(opts.path, opts.content, function(err) {
      if (err) {
        return next(err);
      }
      if (opts.type === 'out file') {
        file.attributes.wtime = new Date();
      }
      file.log('debug', util.format(locale.fileWrote, opts.type, opts.path, opts.encoding));
      return next();
    });
    return this;
  };


  /**
  	 * Write the source file. Optionally pass
  	 * the opts parameter to modify or set the file's
  	 * path, content or type.
  	 * next(err)
  	 * @method writeSource
  	 * @param {Object} [opts]
  	 * @param {Object} next callback
   */

  FileModel.prototype.writeSource = function(opts, next) {
    var file, ref;
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    file = this;
    opts.path || (opts.path = file.get('fullPath'));
    opts.content || (opts.content = (file.getContent() || '').toString(''));
    opts.type || (opts.type = 'source file');
    this.write(opts, next);
    return this;
  };


  /**
  	 * Delete the out file, perhaps ahead of regeneration.
  	 * Optionally pass the opts parameter to set the file path or type.
  	 * next(err)
  	 * @method delete
  	 * @param {Object} [opts]
  	 * @param {Object} next callback
   */

  FileModel.prototype['delete'] = function(opts, next) {
    var file, locale, ref;
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    file = this;
    locale = this.getLocale();
    opts.path || (opts.path = file.get('outPath'));
    opts.type || (opts.type = 'out file');
    if (!opts.path) {
      next();
      return this;
    }
    file.log('debug', util.format(locale.fileDelete, opts.type, opts.path));
    safefs.exists(opts.path, function(exists) {
      if (!exists) {
        return next();
      }
      return safefs.unlink(opts.path, function(err) {
        if (err) {
          return next(err);
        }
        file.log('debug', util.format(locale.fileDeleted, opts.type, opts.path));
        return next();
      });
    });
    return this;
  };


  /**
  	 * Delete the source file.
  	 * Optionally pass the opts parameter to set the file path or type.
  	 * next(err)
  	 * @method deleteSource
  	 * @param {Object} [opts]
  	 * @param {Object} next callback
   */

  FileModel.prototype.deleteSource = function(opts, next) {
    var file, ref;
    ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
    file = this;
    opts.path || (opts.path = file.get('fullPath'));
    opts.type || (opts.type = 'source file');
    this["delete"](opts, next);
    return this;
  };

  return FileModel;

})(Model);

module.exports = FileModel;
