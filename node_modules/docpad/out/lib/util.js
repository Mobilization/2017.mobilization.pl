// Generated by CoffeeScript 1.10.0
var TaskGroup, compact, docpadUtil, extractOptsAndCallback, pathUtil, ref, uniq, util,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

pathUtil = require('path');

util = require('util');

ref = require('underscore'), uniq = ref.uniq, compact = ref.compact;

extractOptsAndCallback = require('extract-opts');

TaskGroup = require('taskgroup').TaskGroup;


/**
 * The DocPad Util Class.
 * Collection of DocPad utility methods
 * @class docpadUtil
 * @constructor
 * @static
 */

module.exports = docpadUtil = {

  /**
  	 * Write to stderr
  	 * @private
  	 * @method writeStderr
  	 * @param {String} data
   */
  writeStderr: function(data) {
    var err, error;
    try {
      return process.stderr.write(data);
    } catch (error) {
      err = error;
      return process.stdout.write(data);
    }
  },

  /**
  	 * Write an error
  	 * @private
  	 * @method writeError
  	 * @param {Object} err
   */
  writeError: function(err) {
    var ref1;
    return docpadUtil.writeStderr(((ref1 = err.stack) != null ? typeof ref1.toString === "function" ? ref1.toString() : void 0 : void 0) || err.message || err);
  },

  /**
  	 * Wait. Wrapper for setTimeout
  	 * @private
  	 * @method wait
  	 * @param {Number} time
  	 * @param {function} fn
   */
  wait: function(time, fn) {
    return setTimeout(fn, time);
  },

  /**
  	 * Get Default Log Level
  	 * @private
  	 * @method getDefaultLogLevel
  	 * @return {Number} default log level
   */
  getDefaultLogLevel: function() {
    if (docpadUtil.isTravis() || (indexOf.call(process.argv, '-d') >= 0)) {
      return 7;
    } else {
      return 5;
    }
  },

  /**
  	 * Are we executing on Travis
  	 * @private
  	 * @method isTravis
  	 * @return {String} The travis node version
   */
  isTravis: function() {
    return process.env.TRAVIS_NODE_VERSION != null;
  },

  /**
  	 * Is this TTY
  	 * @private
  	 * @method isTTY
  	 * @return {Boolean}
   */
  isTTY: function() {
    var ref1, ref2;
    return ((ref1 = process.stdout) != null ? ref1.isTTY : void 0) === true && ((ref2 = process.stderr) != null ? ref2.isTTY : void 0) === true;
  },

  /**
  	 * Is Standadlone
  	 * @private
  	 * @method isStandalone
  	 * @return {Object}
   */
  isStandalone: function() {
    return /docpad$/.test(process.argv[1] || '');
  },

  /**
  	 * Is user
  	 * @private
  	 * @method isUser
  	 * @return {Boolean}
   */
  isUser: function() {
    return docpadUtil.isStandalone() && docpadUtil.isTTY() && docpadUtil.isTravis() === false;
  },

  /**
  	 * Wrapper for the node.js method util.inspect
  	 * @method inspect
  	 * @param {Object} obj
  	 * @param {Object} opts
  	 * @return {String}
   */
  inspect: function(obj, opts) {
    if (opts == null) {
      opts = {};
    }
    if (docpadUtil.isTTY()) {
      if (opts.colors == null) {
        opts.colors = indexOf.call(process.argv, '--no-colors') < 0;
      }
    } else {
      opts.colors = false;
    }
    return util.inspect(obj, opts);
  },

  /**
  	 * Are we using standard encoding?
  	 * @private
  	 * @method isStandardEncoding
  	 * @param {String} encoding
  	 * @return {Boolean}
   */
  isStandardEncoding: function(encoding) {
    var ref1;
    return (ref1 = encoding.toLowerCase()) === 'ascii' || ref1 === 'utf8' || ref1 === 'utf-8';
  },

  /**
  	 * Get Local DocPad Installation Executable - ie
  	 * not the global installation
  	 * @private
  	 * @method getLocalDocPadExecutable
  	 * @return {String} the path to the local DocPad executable
   */
  getLocalDocPadExecutable: function() {
    return pathUtil.join(process.cwd(), 'node_modules', 'docpad', 'bin', 'docpad');
  },

  /**
  	 * Is Local DocPad Installation
  	 * @private
  	 * @method isLocalDocPadExecutable
  	 * @return {Boolean}
   */
  isLocalDocPadExecutable: function() {
    var ref1;
    return ref1 = docpadUtil.getLocalDocPadExecutable(), indexOf.call(process.argv, ref1) >= 0;
  },

  /**
  	 * Does the local DocPad Installation Exist?
  	 * @private
  	 * @method getLocalDocPadExecutableExistance
  	 * @return {Boolean}
   */
  getLocalDocPadExecutableExistance: function() {
    return require('safefs').existsSync(docpadUtil.getLocalDocPadExecutable()) === true;
  },

  /**
  	 * Spawn Local DocPad Executable
  	 * @private
  	 * @method startLocalDocPadExecutable
  	 * @param {Function} next
  	 * @return {Object} don't know what
   */
  startLocalDocPadExecutable: function(next) {
    var args, command;
    args = process.argv.slice(2);
    command = ['node', docpadUtil.getLocalDocPadExecutable()].concat(args);
    return require('safeps').spawn(command, {
      stdio: 'inherit'
    }, function(err) {
      var message;
      if (err) {
        if (next) {
          return next(err);
        } else {
          message = 'An error occured within the child DocPad instance: ' + err.message + '\n';
          return docpadUtil.writeStderr(message);
        }
      } else {
        return typeof next === "function" ? next() : void 0;
      }
    });
  },

  /**
  	 * get a filename without the extension
  	 * @method getBasename
  	 * @param {String} filename
  	 * @return {String} base name
   */
  getBasename: function(filename) {
    var basename;
    if (filename[0] === '.') {
      basename = filename.replace(/^(\.[^\.]+)\..*$/, '$1');
    } else {
      basename = filename.replace(/\..*$/, '');
    }
    return basename;
  },

  /**
  	 * Get the extensions of a filename
  	 * @method getExtensions
  	 * @param {String} filename
  	 * @return {Array} array of string
   */
  getExtensions: function(filename) {
    var extensions;
    extensions = filename.split(/\./g).slice(1);
    return extensions;
  },

  /**
  	 * Get the extension from a bunch of extensions
  	 * @method getExtension
  	 * @param {Array} extensions
  	 * @return {String} the extension
   */
  getExtension: function(extensions) {
    var extension;
    if (!require('typechecker').isArray(extensions)) {
      extensions = docpadUtil.getExtensions(extensions);
    }
    if (extensions.length !== 0) {
      extension = extensions.slice(-1)[0] || null;
    } else {
      extension = null;
    }
    return extension;
  },

  /**
  	 * Get the directory path.
  	 * Wrapper around the node.js path.dirname method
  	 * @method getDirPath
  	 * @param {String} path
  	 * @return {String}
   */
  getDirPath: function(path) {
    return pathUtil.dirname(path) || '';
  },

  /**
  	 * Get the file name.
  	 * Wrapper around the node.js path.basename method
  	 * @method getFilename
  	 * @param {String} path
  	 * @return {String}
   */
  getFilename: function(path) {
    return pathUtil.basename(path);
  },

  /**
  	 * Get the DocPad out file name
  	 * @method getOutFilename
  	 * @param {String} basename
  	 * @param {String} extension
  	 * @return {String}
   */
  getOutFilename: function(basename, extension) {
    if (basename === '.' + extension) {
      return basename;
    } else {
      return basename + (extension ? '.' + extension : '');
    }
  },

  /**
  	 * Get the URL
  	 * @method getUrl
  	 * @param {String} relativePath
  	 * @return {String}
   */
  getUrl: function(relativePath) {
    return '/' + relativePath.replace(/[\\]/g, '/');
  },

  /**
  	 * Get the post slug from the URL
  	 * @method getSlug
  	 * @param {String} relativeBase
  	 * @return {String} the slug
   */
  getSlug: function(relativeBase) {
    return require('bal-util').generateSlugSync(relativeBase);
  },

  /**
  	 * Perform an action
  	 * next(err,...), ... = any special arguments from the action
  	 * this should be it's own npm module
  	 * as we also use the concept of actions in a few other packages.
  	 * Important concept in DocPad.
  	 * @method action
  	 * @param {Object} action
  	 * @param {Object} opts
  	 * @param {Function} next
   */
  action: function(action, opts, next) {
    var actionMethod, actionTaskOrGroup, actions, err, i, len, locale, me, ref1, ref2, ref3, run, runner, runnerTask, task;
    ref1 = extractOptsAndCallback(opts, next), opts = ref1[0], next = ref1[1];
    me = this;
    locale = me.getLocale();
    run = (ref2 = opts.run) != null ? ref2 : true;
    runner = (ref3 = opts.runner) != null ? ref3 : me.getActionRunner();
    if (Array.isArray(action)) {
      actions = action;
    } else {
      actions = action.split(/[,\s]+/g);
    }
    actions = uniq(compact(actions));
    if (actions.length === 0) {
      err = new Error(locale.actionEmpty);
      return next(err);
      me;
    }
    if (actions.length > 1) {
      actionTaskOrGroup = runner.createGroup('actions bundle: ' + actions.join(' '));
      for (i = 0, len = actions.length; i < len; i++) {
        action = actions[i];
        actionMethod = me[action].bind(me);
        if (!actionMethod) {
          err = new Error(util.format(locale.actionNonexistant, action));
          return next(err);
          me;
        }
        task = actionTaskOrGroup.createTask(action, actionMethod, {
          args: [opts]
        });
        actionTaskOrGroup.addTask(task);
      }
    } else {
      action = actions[0];
      actionMethod = me[action].bind(me);
      if (!actionMethod) {
        err = new Error(util.format(locale.actionNonexistant, action));
        return next(err);
        me;
      }
      actionTaskOrGroup = runner.createTask(action, actionMethod, {
        args: [opts]
      });
    }
    runnerTask = runner.createTask("runner task for action: " + action, function(continueWithRunner) {
      actionTaskOrGroup.done(function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        if (next) {
          next.apply(null, args);
          args[0] = null;
        }
        return continueWithRunner.apply(null, args);
      });
      return actionTaskOrGroup.run();
    });
    runner.addTask(runnerTask);
    if (run === true) {
      runner.run();
    }
    return me;
  }
};
