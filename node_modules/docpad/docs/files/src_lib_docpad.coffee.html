<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\lib\docpad.coffee</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/BasePlugin.html">BasePlugin</a></li>
                                <li><a href="../classes/Collection.html">Collection</a></li>
                                <li><a href="../classes/Docpad.html">Docpad</a></li>
                                <li><a href="../classes/docpadUtil.html">docpadUtil</a></li>
                                <li><a href="../classes/DocumentModel.html">DocumentModel</a></li>
                                <li><a href="../classes/ElementsCollection.html">ElementsCollection</a></li>
                                <li><a href="../classes/Events.html">Events</a></li>
                                <li><a href="../classes/FileModel.html">FileModel</a></li>
                                <li><a href="../classes/FilesCollection.html">FilesCollection</a></li>
                                <li><a href="../classes/MetaCollection.html">MetaCollection</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/PluginLoader.html">PluginLoader</a></li>
                                <li><a href="../classes/PluginTester.html">PluginTester</a></li>
                                <li><a href="../classes/QueryCollection.html">QueryCollection</a></li>
                                <li><a href="../classes/ScriptCollection.html">ScriptCollection</a></li>
                                <li><a href="../classes/ServerTester.html">ServerTester</a></li>
                                <li><a href="../classes/StylesCollection.html">StylesCollection</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\lib\docpad.coffee</h1>

<div class="file">
    <pre class="code prettyprint linenums">
##*
# The central module for DocPad
# @module DocPad
##

# =====================================
# This block *must* come first

# Important
pathUtil = require(&#x27;path&#x27;)
lazyRequire = require(&#x27;lazy-require&#x27;)
corePath = pathUtil.resolve(__dirname, &#x27;..&#x27;, &#x27;..&#x27;)

# Profile
if (&#x27;--profile&#x27; in process.argv)
	# Debug
	debugger

	# Nodetime
	if process.env.DOCPAD_PROFILER.indexOf(&#x27;nodetime&#x27;) isnt -1
		throw new Error(&#x27;NODETIME_KEY environment variable is undefined&#x27;)  unless process.env.NODETIME_KEY
		console.log &#x27;Loading profiling tool: nodetime&#x27;
		require(&#x27;lazy-require&#x27;).sync &#x27;nodetime&#x27;, {cwd:corePath}, (err,nodetime) -&gt;
			if err
				console.log &#x27;Failed to load profiling tool: nodetime&#x27;
				console.log err.stack or err
			else
				nodetime.profile({
					accountKey: process.env.NODETIME_KEY
					appName: &#x27;DocPad&#x27;
				})
				console.log &#x27;Profiling with nodetime with account key:&#x27;, process.env.NODETIME_KEY

	# Webkit Devtools
	if process.env.DOCPAD_PROFILER.indexOf(&#x27;webkit-devtools-agent&#x27;) isnt -1
		console.log &#x27;Loading profiling tool: webkit-devtools-agent&#x27;
		require(&#x27;lazy-require&#x27;).sync &#x27;webkit-devtools-agent&#x27;, {cwd:corePath}, (err, agent) -&gt;
			if err
				console.log &#x27;Failed to load profiling tool: webkit-devtools-agent&#x27;
				console.log err.stack or err
			else
				agent.start()
				console.log &quot;Profiling with webkit-devtools-agent on pid #{process.pid} at http://127.0.0.1:9999/&quot;

	# V8 Profiler
	if process.env.DOCPAD_PROFILER.indexOf(&#x27;v8-profiler&#x27;) isnt -1
		console.log &#x27;Loading profiling tool: v8-profiler&#x27;
		require(&#x27;lazy-require&#x27;).sync &#x27;v8-profiler-helper&#x27;, {cwd:corePath}, (err, profiler) -&gt;
			if err
				console.log &#x27;Failed to load profiling tool: v8-profiler&#x27;
				console.log err.stack or err
			else
				profiler.startProfile(&#x27;docpad-profile&#x27;)
				console.log &quot;Profiling with v8-profiler&quot;
			process.on &#x27;exit&#x27;, -&gt;
				profiler.stopProfile(&#x27;docpad-profile&#x27;)


# =====================================
# Requires

# Standard Library
util     = require(&#x27;util&#x27;)

# External
queryEngine = require(&#x27;query-engine&#x27;)
{uniq, union, pick} = require(&#x27;underscore&#x27;)
CSON = require(&#x27;cson&#x27;)
balUtil = require(&#x27;bal-util&#x27;)
scandir = require(&#x27;scandirectory&#x27;)
extendr = require(&#x27;extendr&#x27;)
eachr = require(&#x27;eachr&#x27;)
typeChecker = require(&#x27;typechecker&#x27;)
ambi = require(&#x27;ambi&#x27;)
{TaskGroup} = require(&#x27;taskgroup&#x27;)
safefs = require(&#x27;safefs&#x27;)
safeps = require(&#x27;safeps&#x27;)
ignorefs = require(&#x27;ignorefs&#x27;)
rimraf = require(&#x27;rimraf&#x27;)
superAgent = require(&#x27;superagent&#x27;)
extractOptsAndCallback = require(&#x27;extract-opts&#x27;)
{EventEmitterGrouped} = require(&#x27;event-emitter-grouped&#x27;)

# Base
{Events,Model,Collection,QueryCollection} = require(&#x27;./base&#x27;)

# Utils
docpadUtil = require(&#x27;./util&#x27;)

# Models
FileModel = require(&#x27;./models/file&#x27;)
DocumentModel = require(&#x27;./models/document&#x27;)

# Collections
FilesCollection = require(&#x27;./collections/files&#x27;)
ElementsCollection = require(&#x27;./collections/elements&#x27;)
MetaCollection = require(&#x27;./collections/meta&#x27;)
ScriptsCollection = require(&#x27;./collections/scripts&#x27;)
StylesCollection = require(&#x27;./collections/styles&#x27;)

# Plugins
PluginLoader = require(&#x27;./plugin-loader&#x27;)
BasePlugin = require(&#x27;./plugin&#x27;)


# ---------------------------------
# Helpers

setImmediate = global?.setImmediate or process.nextTick  # node 0.8 b/c


# ---------------------------------
# Variables

isUser = docpadUtil.isUser()


###*
# Contains methods for managing the DocPad application.
# This includes managing a DocPad projects files and
# documents, watching directories, emitting events and
# managing the node.js/express.js web server.
# Extends https://github.com/bevry/event-emitter-grouped
#
# The class is instantiated in the docpad-server.js file
# which is the entry point for a DocPad application.
#
# 	new DocPad(docpadConfig, function(err, docpad) {
# 		if (err) {
# 			return docpadUtil.writeError(err);
# 		}
# 		return docpad.action(action, function(err) {
# 			if (err) {
# 				return docpadUtil.writeError(err);
# 			}
# 			return console.log(&#x27;OK&#x27;);
# 		});
# 	});
#
# @class Docpad
# @constructor
# @extends EventEmitterGrouped
###
class DocPad extends EventEmitterGrouped
	# Libraries
	# Here for legacy API reasons
	#@DocPad: DocPad
	#@Backbone: require(&#x27;backbone&#x27;)
	#@queryEngine: queryEngine

	# Allow for &#x60;DocPad.create()&#x60; as an alias for &#x60;new DocPad()&#x60;
	# Allow for &#x60;DocPad.createInstance()&#x60; as an alias for &#x60;new DocPad()&#x60; (legacy alias)
	@create: (args...) -&gt; return new @(args...)
	@createInstance: (args...) -&gt; return new @(args...)

	# Require a local DocPad file
	# Before v6.73.0 this allowed requiring of files inside src/lib, as well as files inside src
	# Now it only allows requiring of files inside src/lib as that makes more sense
	@require: (relativePath) -&gt;
		# Absolute the path
		absolutePath = pathUtil.normalize(pathUtil.join(__dirname, relativePath))

		# Check if we are actually a local docpad file
		if absolutePath.replace(__dirname, &#x27;&#x27;) is absolutePath
			throw new Error(&quot;docpad.require is limited to local docpad files only: #{relativePath}&quot;)

		# Require the path
		return require(absolutePath)


	# =================================
	# Variables

	# ---------------------------------
	# Modules

	# ---------------------------------
	# Base

	###*
	# Events class
	# https://github.com/docpad/docpad/blob/master/src/lib/base.coffee
	# @property {Object} Events
	###
	Events: Events
	###*
	# Model class
	# Extension of the Backbone Model class
	# http://backbonejs.org/#Model
	# https://github.com/docpad/docpad/blob/master/src/lib/base.coffee
	# @property {Object} Model
	###
	Model: Model

	###*
	# Collection class
	# Extension of the Backbone Collection class
	# https://github.com/docpad/docpad/blob/master/src/lib/base.coffee
	# http://backbonejs.org/#Collection
	# @property {Object} Collection
	###
	Collection: Collection

	###*
	# QueryCollection class
	# Extension of the Query Engine QueryCollection class
	# https://github.com/docpad/docpad/blob/master/src/lib/base.coffee
	# https://github.com/bevry/query-engine/blob/master/src/documents/lib/query-engine.js.coffee
	# @property {Object} QueryCollection
	###
	QueryCollection: QueryCollection

	# ---------------------------------
	# Models

	###*
	# File Model class
	# Extension of the Model class
	# https://github.com/docpad/docpad/blob/master/src/lib/models/file.coffee
	# @property {Object} FileModel
	###
	FileModel: FileModel

	###*
	# Document Model class
	# Extension of the File Model class
	# https://github.com/docpad/docpad/blob/master/src/lib/models/document.coffee
	# @property {Object} DocumentModel
	###
	DocumentModel: DocumentModel

	# ---------------------------------
	# Collections

	###*
	# Collection of files in a DocPad project
	# Extension of the QueryCollection class
	# https://github.com/docpad/docpad/blob/master/src/lib/collections/files.coffee
	# @property {Object} FilesCollection
	###
	FilesCollection: FilesCollection

	###*
	# Collection of elements in a DocPad project
	# Extension of the Collection class
	# https://github.com/docpad/docpad/blob/master/src/lib/collections/elements.coffee
	# @property {Object} ElementsCollection
	###
	ElementsCollection: ElementsCollection

	###*
	# Collection of metadata in a DocPad project
	# Extension of the ElementsCollection class
	# https://github.com/docpad/docpad/blob/master/src/lib/collections/meta.coffee
	# @property {Object} MetaCollection
	###
	MetaCollection: MetaCollection

	###*
	# Collection of JS script files in a DocPad project
	# Extension of the ElementsCollection class
	# https://github.com/docpad/docpad/blob/master/src/lib/collections/scripts.coffee
	# @property {Object} ScriptsCollection
	###
	ScriptsCollection: ScriptsCollection

	###*
	# Collection of CSS style files in a DocPad project
	# Extension of the ElementsCollection class
	# https://github.com/docpad/docpad/blob/master/src/lib/collections/styles.coffee
	# @property {Object} StylesCollection
	###
	StylesCollection: StylesCollection

	###*
	# Plugin Loader class
	# https://github.com/docpad/docpad/blob/master/src/lib/plugin-loader.coffee
	# Loads the DocPad plugins from the file system into
	# a DocPad project
	# @property {Object} PluginLoader
	###
	PluginLoader: PluginLoader

	###*
	# Base class for all DocPad plugins
	# https://github.com/docpad/docpad/blob/master/src/lib/plugin.coffee
	# @property {Object} BasePlugin
	###
	BasePlugin: BasePlugin

	# ---------------------------------
	# DocPad

	###*
	# DocPad&#x27;s version number
	# @private
	# @property {Number} version
	###
	version: null

	###*
	# Get the DocPad version number
	# @method getVersion
	# @return {Number}
	###
	getVersion: -&gt;
		@version ?= require(@packagePath).version
		return @version

	###*
	# Get the DocPad version string
	# @method getVersionString
	# @return {String}
	###
	getVersionString: -&gt;
		if docpadUtil.isLocalDocPadExecutable()
			return util.format(@getLocale().versionLocal, @getVersion(), @corePath)
		else
			return util.format(@getLocale().versionGlobal, @getVersion(), @corePath)

	###*
	# The plugin version requirements
	# @property {String} pluginVersion
	###
	pluginVersion: &#x27;2&#x27;

	# Process getters
	###*
	# Get the process platform
	# @method getProcessPlatform
	# @return {Object}
	###
	getProcessPlatform: -&gt; process.platform

	###*
	# Get the process version string
	# @method getProcessVersion
	# @return {String}
	###
	getProcessVersion: -&gt; process.version.replace(/^v/,&#x27;&#x27;)

	###*
	# The express.js server instance bound to DocPad.
	# http://expressjs.com
	# @private
	# @property {Object} serverExpress
	###
	serverExpress: null

	###*
	# The Node.js http server instance bound to DocPad
	# https://nodejs.org/api/http.html
	# @private
	# @property {Object} serverHttp
	###
	serverHttp: null

	###*
	# Get the DocPad express.js server instance and, optionally,
	# the node.js https server instance
	# @method getServer
	# @param {Boolean} [both=false]
	# @return {Object}
	###
	getServer: (both=false) -&gt;
		{serverExpress,serverHttp} = @
		if both
			return {serverExpress, serverHttp}
		else
			return serverExpress

	###*
	# Set the express.js server and node.js http server
	# to bind to DocPad
	# @method setServer
	# @param {Object} servers
	###
	setServer: (servers) -&gt;
		# Apply
		if servers.serverExpress and servers.serverHttp
			@serverExpress = servers.serverExpress
			@serverHttp = servers.serverHttp

		# Cleanup
		delete @config.serverHttp
		delete @config.serverExpress
		delete @config.server

	###*
	# Destructor. Close and destroy the node.js http server
	# @private
	# @method destroyServer
	###
	destroyServer: -&gt;
		@serverHttp?.close()
		@serverHttp = null
		# @TODO figure out how to destroy the express server

	#
	###*
	# Internal property. The caterpillar logger instances bound to DocPad
	# @private
	# @property {Object} loggerInstances
	###
	loggerInstances: null

	###*
	# Get the caterpillar logger instance bound to DocPad
	# @method getLogger
	# @return {Object} caterpillar logger
	###
	getLogger: -&gt; @loggerInstances?.logger

	###*
	# Get all the caterpillar logger instances bound to DocPad
	# @method getLoggers
	# @return {Object} collection of caterpillar loggers
	###
	getLoggers: -&gt; @loggerInstances

	###*
	# Sets the caterpillar logger instances bound to DocPad
	# @method setLoggers
	# @param {Object} loggers
	# @return {Object} logger instances bound to DocPad
	###
	setLoggers: (loggers) -&gt;
		if @loggerInstances
			@warn @getLocale().loggersAlreadyDefined
		else
			@loggerInstances = loggers
			@loggerInstances.logger.setConfig(dry:true)
			@loggerInstances.console.setConfig(dry:false).pipe(process.stdout)
		return loggers

	###*
	# Destructor. Destroy the caterpillar logger instances bound to DocPad
	# @private
	# @method {Object} destroyLoggers
	###
	destroyLoggers: -&gt;
		if @loggerInstances
			for own key,value of @loggerInstances
				value.end()
		@

	###*
	# The action runner instance bound to docpad
	# @private
	# @property {Object} actionRunnerInstance
	###
	actionRunnerInstance: null

	###*
	# Get the action runner instance bound to docpad
	# @method getActionRunner
	# @return {Object} the action runner instance
	###
	getActionRunner: -&gt; @actionRunnerInstance

	###*
	# Apply the passed DocPad action arguments
	# @method {Object} action
	# @param {Object} args
	# @return {Object}
	###
	action: (args...) -&gt; docpadUtil.action.apply(@, args)


	###*
	# The error runner instance bound to DocPad
	# @property {Object} errorRunnerInstance
	###
	errorRunnerInstance: null

	###*
	# Get the error runner instance
	# @method {Object} getErrorRunner
	# @return {Object} the error runner instance
	###
	getErrorRunner: -&gt; @errorRunnerInstance

	###*
	# The track runner instance bound to DocPad
	# @private
	# @property {Object} trackRunnerInstance
	###
	trackRunnerInstance: null

	###*
	# Get the track runner instance
	# @method getTrackRunner
	# @return {Object} the track runner instance
	###
	getTrackRunner: -&gt; @trackRunnerInstance


	###*
	# Event Listing. String array of event names.
	# Whenever an event is created, it must be applied here to be available to plugins and configuration files
	# https://github.com/bevry/docpad/wiki/Events
	# @private
	# @property {Array} string array of event names
	###
	events: [
		&#x27;extendTemplateData&#x27;           # fired each load
		&#x27;extendCollections&#x27;            # fired each load
		&#x27;docpadLoaded&#x27;                 # fired multiple times, first time command line configuration hasn&#x27;t been applied yet
		&#x27;docpadReady&#x27;                  # fired only once
		&#x27;docpadDestroy&#x27;                # fired once on shutdown
		&#x27;consoleSetup&#x27;                 # fired once
		&#x27;generateBefore&#x27;
		&#x27;populateCollectionsBefore&#x27;
		&#x27;populateCollections&#x27;
		&#x27;contextualizeBefore&#x27;
		&#x27;contextualizeAfter&#x27;
		&#x27;renderBefore&#x27;
		&#x27;renderCollectionBefore&#x27;
		&#x27;render&#x27;                       # fired for each extension conversion
		&#x27;renderDocument&#x27;               # fired for each document render, including layouts and render passes
		&#x27;renderCollectionAfter&#x27;
		&#x27;renderAfter&#x27;
		&#x27;writeBefore&#x27;
		&#x27;writeAfter&#x27;
		&#x27;generateAfter&#x27;
		&#x27;generated&#x27;
		&#x27;serverBefore&#x27;
		&#x27;serverExtend&#x27;
		&#x27;serverAfter&#x27;
		&#x27;notify&#x27;
	]

	###*
	# Get the list of available events
	# @method getEvents
	# @return {Object} string array of event names
	###
	getEvents: -&gt;
		@events


	# ---------------------------------
	# Collections

	# Database collection

	###*
	# QueryEngine collection
	# @private
	# @property {Object} database
	###
	database: null

	###*
	# A FilesCollection of models updated
	# from the DocPad database after each regeneration.
	# @private
	# @property {Object} databaseTempCache FileCollection of models
	###
	databaseTempCache: null

	###*
	# Description for getDatabase
	# @method {Object} getDatabase
	###
	getDatabase: -&gt; @database

	###*
	# Safe method for retrieving the database by
	# either returning the database itself or the temporary
	# database cache
	# @method getDatabaseSafe
	# @return {Object}
	###
	getDatabaseSafe: -&gt; @databaseTempCache or @database

	###*
	# Destructor. Destroy the DocPad database
	# @private
	# @method destroyDatabase
	###
	destroyDatabase: -&gt;
		if @database?
			@database.destroy()
			@database = null
		if @databaseTempCache?
			@databaseTempCache.destroy()
			@databaseTempCache = null
		@

	###*
	# Files by url. Used to speed up fetching
	# @private
	# @property {Object} filesByUrl
	###
	filesByUrl: null

	###*
	# Files by Selector. Used to speed up fetching
	# @private
	# @property {Object} filesBySelector
	###
	filesBySelector: null

	###*
	# Files by Out Path. Used to speed up conflict detection. Do not use for anything else
	# @private
	# @property {Object} filesByOutPath
	###
	filesByOutPath: null

	###*
	# Blocks
	# @private
	# @property {Object} blocks
	###
	blocks: null
	### {
		# A collection of meta elements
		meta: null  # Elements Collection

		# A collection of script elements
		scripts: null  # Scripts Collection

		# Collection of style elements
		styles: null  # Styles Collection
	} ###

	###*
	# Get a block by block name. Optionally clone block.
	# @method getBlock
	# @param {String} name
	# @param {Object} [clone]
	# @return {Object} block
	###
	getBlock: (name,clone) -&gt;
		block = @blocks[name]
		if clone
			classname = name[0].toUpperCase()+name[1..]+&#x27;Collection&#x27;
			block = new @[classname](block.models)
		return block

	###*
	# Set a block by name and value
	# @method setBlock
	# @param {String} name
	# @param {Object} value
	###
	setBlock: (name,value) -&gt;
		if @blocks[name]?
			@blocks[name].destroy()
			if value
				@blocks[name] = value
			else
				delete @blocks[name]
		else
			@blocks[name] = value
		@

	###*
	# Get all blocks
	# @method getBlocks
	# @return {Object} collection of blocks
	###
	getBlocks: -&gt; @blocks

	###*
	# Set all blocks
	# @method setBlocks
	# @param {Object} blocks
	###
	setBlocks: (blocks) -&gt;
		for own name,value of blocks
			@setBlock(name,value)
		@

	###*
	# Apply the passed function to each block
	# @method eachBlock
	# @param {Function} fn
	###
	eachBlock: (fn) -&gt;
		eachr(@blocks, fn)
		@

	###*
	# Destructor. Destroy all blocks
	# @private
	# @method destroyBlocks
	###
	destroyBlocks: -&gt;
		if @blocks
			for own name,block of @blocks
				block.destroy()
				@blocks[name] = null
		@

	###*
	# The DocPad collections
	# @private
	# @property {Object} collections
	###
	collections: null

	###*
	# Get a collection by collection name or key.
	# This is often accessed within the docpad.coffee
	# file or a layout/page via @getCollection.
	# Because getCollection returns a docpad collection,
	# a call to this method is often chained with a
	# QueryEngine style query.
	#
	# 	@getCollection(&#x27;documents&#x27;).findAllLive({relativeOutDirPath: &#x27;posts&#x27;},[{date:-1}])
	#
	# @method getCollection
	# @param {String} value
	# @return {Object} collection
	###
	getCollection: (value) -&gt;
		if value
			if typeof value is &#x27;string&#x27;
				if value is &#x27;database&#x27;
					return @getDatabase()

				else
					for collection in @collections
						if value in [collection.options.name, collection.options.key]
							return collection

			else
				for collection in @collections
					if value is collection
						return collection

		return null

	###*
	# Destroy a collection by collection name or key
	# @method destroyCollection
	# @param {String} value
	# @return {Object} description
	###
	destroyCollection: (value) -&gt;
		if value
			if typeof value is &#x27;string&#x27; and value isnt &#x27;database&#x27;
				@collections = @collections.filter (collection) -&gt;
					if value in [collection.options.name, collection.options.key]
						collection?.destroy()
						return false
					else
						return true

			else if value isnt @getDatabase()
				@collections = @collections.filter (collection) -&gt;
					if value is collection
						collection?.destroy()
						return false
					else
						return true

		return null

	###*
	# Add a collection
	# @method addCollection
	# @param {Object} collection
	###
	addCollection: (collection) -&gt;
		if collection and collection not in [@getDatabase(), @getCollection(collection)]
			@collections.push(collection)
		@

	###*
	# Set a name for a collection.
	# A collection can have multiple names
	#
	# The partials plugin (https://github.com/docpad/docpad-plugin-partials)
	# creates a live collection and passes this to setCollection with
	# the name &#x27;partials&#x27;.
	#
	# 	# Add our partials collection
	#	docpad.setCollection(&#x27;partials&#x27;, database.createLiveChildCollection()
	#		.setQuery(&#x27;isPartial&#x27;, {
	#				$or:
	#					isPartial: true
	#					fullPath: $startsWith: config.partialsPath
	#		})
	#		.on(&#x27;add&#x27;, (model) -&gt;
	#			docpad.log(&#x27;debug&#x27;, util.format(locale.addingPartial, model.getFilePath()))
	#			model.setDefaults(
	#				isPartial: true
	#				render: false
	#				write: false
	#			)
	#		)
	#	)
	#
	#
	# @method setCollection
	# @param {String} name the name to give to the collection
	# @param {Object} collection a DocPad collection
	###
	setCollection: (name, collection) -&gt;
		if collection
			if name
				collection.options.name = name
				if @getCollection(name) isnt collection
					@destroyCollection(name)
			@addCollection(collection)
		else
			@destroyCollection(name)

	###*
	# Get the DocPad project&#x27;s collections
	# @method getCollections
	# @return {Object} the collections
	###
	getCollections: -&gt;
		return @collections

	###*
	# Set the DocPad project&#x27;s collections
	# @method setCollections
	###
	setCollections: (collections) -&gt;
		if Array.isArray(collections)
			for value in collections
				@addCollection(value)
		else
			for own name,value of collections
				@setCollection(name, value)
		@

	###*
	# Apply the passed function to each collection
	# @method eachCollection
	# @param {Function} fn
	###
	eachCollection: (fn) -&gt;
		fn(@getDatabase(), &#x27;database&#x27;)
		for collection,index in @collections
			fn(collection, collection.options.name or collection.options.key or index)
		@

	###*
	# Destructor. Destroy the DocPad project&#x27;s collections.
	# @private
	# @method destroyCollections
	###
	destroyCollections: -&gt;
		if @collections
			for collection in @collections
				collection.destroy()
			@collections = []
		@


	# ---------------------------------
	# Collection Helpers

	###*
	# Get all the files in the DocPad database (will use live collections)
	# @method getFiles
	# @param {Object} query
	# @param {Object} sorting
	# @param {Object} paging
	# @return {Object} collection
	###
	getFiles: (query,sorting,paging) -&gt;
		key = JSON.stringify({query, sorting, paging})
		collection = @getCollection(key)
		unless collection
			collection = @getDatabase().findAllLive(query, sorting, paging)
			collection.options.key = key
			@addCollection(collection)
		return collection


	###*
	# Get a single file based on a query
	# @method getFile
	# @param {Object} query
	# @param {Object} sorting
	# @param {Object} paging
	# @return {Object} a file
	###
	getFile: (query,sorting,paging) -&gt;
		file = @getDatabase().findOne(query, sorting, paging)
		return file

	###*
	# Get files at a path
	# @method getFilesAtPath
	# @param {String} path
	# @param {Object} sorting
	# @param {Object} paging
	# @return {Object} files
	###
	getFilesAtPath: (path,sorting,paging) -&gt;
		query = $or: [{relativePath: $startsWith: path}, {fullPath: $startsWith: path}]
		files = @getFiles(query, sorting, paging)
		return files

	###*
	# Get a file at a relative or absolute path or url
	# @method getFileAtPath
	# @param {String} path
	# @param {Object} sorting
	# @param {Object} paging
	# @return {Object} a file
	###
	getFileAtPath: (path,sorting,paging) -&gt;
		file = @getDatabase().fuzzyFindOne(path, sorting, paging)
		return file


	# TODO: Does this still work???
	###*
	# Get a file by its url
	# @method getFileByUrl
	# @param {String} url
	# @param {Object} [opts={}]
	# @return {Object} a file
	###
	getFileByUrl: (url,opts={}) -&gt;
		opts.collection ?= @getDatabase()
		file = opts.collection.get(@filesByUrl[url])
		return file


	###*
	# Get a file by its id
	# @method getFileById
	# @param {String} id
	# @param {Object} [opts={}]
	# @return {Object} a file
	###
	getFileById: (id,opts={}) -&gt;
		opts.collection ?= @getDatabase()
		file = opts.collection.get(id)
		return file


	###*
	# Remove the query string from a url
	# Pathname convention taken from document.location.pathname
	# @method getUrlPathname
	# @param {String} url
	# @return {String}
	###
	getUrlPathname: (url) -&gt;
		return url.replace(/\?.*/,&#x27;&#x27;)

	###*
	# Get a file by its route and return
	# it to the supplied callback.
	# @method getFileByRoute
	# @param {String} url
	# @param {Object} next
	# @param {Error} next.err
	# @param {String} next.file
	###
	getFileByRoute: (url,next) -&gt;
		# Prepare
		docpad = @

		# If we have not performed a generation yet then wait until the initial generation has completed
		if docpad.generated is false
			# Wait until generation has completed and recall ourselves
			docpad.once &#x27;generated&#x27;, -&gt;
				return docpad.getFileByRoute(url, next)

			# hain
			return @

		# @TODO the above causes a signifcant delay when importing external documents (like tumblr data) into the database
		# we need to figure out a better way of doing this
		# perhaps it is via &#x60;writeSource: once&#x60; for imported documents
		# or providing an option to disable this so it forward onto the static handler instead

		# Prepare
		database = docpad.getDatabaseSafe()

		# Fetch
		cleanUrl = docpad.getUrlPathname(url)
		file = docpad.getFileByUrl(url, {collection:database}) or docpad.getFileByUrl(cleanUrl, {collection:database})

		# Forward
		next(null, file)

		# Chain
		@


	# TODO: What on earth is a selector?
	###*
	# Get a file by its selector
	# @method getFileBySelector
	# @param {Object} selector
	# @param {Object} [opts={}]
	# @return {Object} a file
	###
	getFileBySelector: (selector,opts={}) -&gt;
		opts.collection ?= @getDatabase()
		file = opts.collection.get(@filesBySelector[selector])
		unless file
			file = opts.collection.fuzzyFindOne(selector)
			if file
				@filesBySelector[selector] = file.id
		return file


	# ---------------------------------
	# Skeletons


	###*
	# Skeletons Collection
	# @private
	# @property {Object} skeletonsCollection
	###
	skeletonsCollection: null

	###*
	# Get Skeletons
	# Get all the available skeletons with their details and
	# return this collection to the supplied callback.
	# @method getSkeletons
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.skeletonsCollection DocPad collection of skeletons
	# @return {Object} DocPad skeleton collection
	###
	getSkeletons: (next) -&gt;
		# Prepare
		docpad = @
		locale = @getLocale()

		# Check if we have cached locally
		if @skeletonsCollection?
			return next(null, @skeletonsCollection)

		# Fetch the skeletons from the exchange
		@skeletonsCollection = new Collection()
		@skeletonsCollection.comparator = queryEngine.generateComparator(position:1, name:1)
		@getExchange (err,exchange) -&gt;
			# Check
			return next(err)  if err

			# Prepare
			index = 0

			# If we have the exchange data, then add the skeletons from it
			if exchange
				eachr exchange.skeletons, (skeleton, skeletonKey) -&gt;
					skeleton.id ?= skeletonKey
					skeleton.name ?= skeletonKey
					skeleton.position ?= index
					docpad.skeletonsCollection.add(new Model(skeleton))
					++index

			# Add No Skeleton Option
			docpad.skeletonsCollection.add(new Model(
				id: &#x27;none&#x27;
				name: locale.skeletonNoneName
				description: locale.skeletonNoneDescription
				position: index
			))

			# Return Collection
			return next(null, docpad.skeletonsCollection)
		@


	# ---------------------------------
	# Plugins


	###*
	# Plugins that are loading really slow
	# @property {Object} slowPlugins
	###
	slowPlugins: null  # {}

	###*
	# Loaded plugins indexed by name
	# @property {Object} loadedPlugins
	###
	loadedPlugins: null  # {}

	###*
	# A listing of all the available extensions for DocPad
	# @property {Object} exchange
	###
	exchange: null  # {}

	# -----------------------------
	# Paths

	###*
	# The DocPad directory
	# @property {String} corePath
	###
	corePath: corePath

	###*
	# The DocPad library directory
	# @private
	# @property {String} libPath
	###
	libPath: __dirname

	###*
	# The main DocPad file
	# @property {String} mainPath
	###
	mainPath: pathUtil.resolve(__dirname, &#x27;docpad&#x27;)

	###*
	# The DocPad package.json path
	# @property {String} packagePath
	###
	packagePath: pathUtil.resolve(__dirname, &#x27;..&#x27;, &#x27;..&#x27;, &#x27;package.json&#x27;)

	###*
	# The DocPad locale path
	# @property {String} localePath
	###
	localePath: pathUtil.resolve(__dirname, &#x27;..&#x27;, &#x27;..&#x27;, &#x27;locale&#x27;)

	###*
	# The DocPad debug log path (docpad-debug.log)
	# @property {String} debugLogPath
	###
	debugLogPath: pathUtil.join(process.cwd(), &#x27;docpad-debug.log&#x27;)

	###*
	# The User&#x27;s configuration path (.docpad.cson)
	# @property {String} userConfigPath
	###
	userConfigPath: &#x27;.docpad.cson&#x27;

	# -----------------------------
	# Template Data


	###*
	# Description for initialTemplateData
	# @private
	# @property {Object} initialTemplateData
	###
	initialTemplateData: null  # {}

	###*
	# Plugin&#x27;s Extended Template Data
	# @private
	# @property {Object} pluginsTemplateData
	###
	pluginsTemplateData: null  # {}

	###*
	# Get Complete Template Data
	# @method getTemplateData
	# @param {Object} userTemplateData
	# @return {Object} templateData
	###
	getTemplateData: (userTemplateData) -&gt;
		# Prepare
		userTemplateData or= {}
		docpad = @
		locale = @getLocale()

		# Set the initial docpad template data
		@initialTemplateData ?=
			# Site Properties
			site: {}

			# Environment
			getEnvironment: -&gt;
				return docpad.getEnvironment()

			# Environments
			getEnvironments: -&gt;
				return docpad.getEnvironments()

			# Set that we reference other files
			referencesOthers: (flag) -&gt;
				document = @getDocument()
				document.referencesOthers()
				return null

			# Get the Document
			getDocument: -&gt;
				return @documentModel

			# Get a Path in respect to the current document
			getPath: (path,parentPath) -&gt;
				document = @getDocument()
				path = document.getPath(path, parentPath)
				return path

			# Get Files
			getFiles: (query,sorting,paging) -&gt;
				@referencesOthers()
				result = docpad.getFiles(query, sorting, paging)
				return result

			# Get another file&#x27;s URL based on a relative path
			getFile: (query,sorting,paging) -&gt;
				@referencesOthers()
				result = docpad.getFile(query,sorting,paging)
				return result

			# Get Files At Path
			getFilesAtPath: (path,sorting,paging) -&gt;
				@referencesOthers()
				path = @getPath(path)
				result = docpad.getFilesAtPath(path, sorting, paging)
				return result

			# Get another file&#x27;s model based on a relative path
			getFileAtPath: (relativePath) -&gt;
				@referencesOthers()
				path = @getPath(relativePath)
				result = docpad.getFileAtPath(path)
				return result

			# Get a specific file by its id
			getFileById: (id) -&gt;
				@referencesOthers()
				result = docpad.getFileById(id)
				return result

			# Get the entire database
			getDatabase: -&gt;
				@referencesOthers()
				return docpad.getDatabase()

			# Get a pre-defined collection
			getCollection: (name) -&gt;
				@referencesOthers()
				return docpad.getCollection(name)

			# Get a block
			getBlock: (name) -&gt;
				return docpad.getBlock(name,true)

			# Include another file taking in a relative path
			include: (subRelativePath,strict=true) -&gt;
				file = @getFileAtPath(subRelativePath)
				if file
					if strict and file.get(&#x27;rendered&#x27;) is false
						if docpad.getConfig().renderPasses is 1
							docpad.warn util.format(locale.renderedEarlyViaInclude, subRelativePath)
						return null
					return file.getOutContent()
				else
					err = new Error(util.format(locale.includeFailed, subRelativePath))
					throw err

		# Fetch our result template data
		templateData = extendr.extend({}, @initialTemplateData, @pluginsTemplateData, @getConfig().templateData, userTemplateData)

		# Add site data
		templateData.site.url or= @getSimpleServerUrl()
		templateData.site.date or= new Date()
		templateData.site.keywords or= []
		if typeChecker.isString(templateData.site.keywords)
			templateData.site.keywords = templateData.site.keywords.split(/,\s*/g)

		# Return
		templateData


	# -----------------------------
	# Locales

	###*
	# Determined locale
	# @private
	# @property {Object} locale
	###
	locale: null


	###*
	# Get the locale (language code and locale code)
	# @method getLocale
	# @return {Object} locale
	###
	getLocale: -&gt;
		if @locale? is false
			config = @getConfig()
			codes = uniq [
				&#x27;en&#x27;
				safeps.getLanguageCode config.localeCode
				safeps.getLanguageCode safeps.getLocaleCode()
				safeps.getLocaleCode   config.localeCode
				safeps.getLocaleCode   safeps.getLocaleCode()
			]
			locales = (@loadLocale(code)  for code in codes)
			@locale = extendr.extend(locales...)

		return @locale

	###*
	# Load the locale
	# @method loadLocale
	# @param {String} code
	# @return {Object} locale
	###
	loadLocale: (code) -&gt;
		# Check if it exists
		localeFilename = &quot;#{code}.cson&quot;
		localePath = pathUtil.join(@localePath, localeFilename)
		return null  unless safefs.existsSync(localePath)

		# Load it
		locale = CSON.parseCSONFile(localePath)

		# Log the error in the background and continue
		if locale instanceof Error
			locale.context = &quot;Failed to parse the CSON locale file: #{localePath}&quot;
			docpad.error(locale)  # @TODO: should this be a fatal error instead?
			return null

		# Success
		return locale


	# -----------------------------
	# Environments


	###*
	# Get the DocPad environment, eg: development,
	# production or static
	# @method getEnvironment
	# @return {String} the environment
	###
	getEnvironment: -&gt;
		env = @getConfig().env or &#x27;development&#x27;
		return env

	###*
	# Get the environments
	# @method getEnvironments
	# @return {Array} array of environment strings
	###
	getEnvironments: -&gt;
		env = @getEnvironment()
		envs = env.split(/[, ]+/)
		return envs


	# -----------------------------
	# Configuration

	###*
	# Hash Key
	# The key that we use to hash some data before sending it to our statistic server
	# @private
	# @property {String} string constant
	###
	hashKey: &#x27;7&gt;9}$3hP86o,4=@T&#x27;  # const

	###*
	# Website Package Configuration
	# @private
	# @property {Object} websitePackageConfig
	###
	websitePackageConfig: null  # {}

	###*
	# Merged Configuration
	# Merged in the order of:
	# - initialConfig
	# - userConfig
	# - websiteConfig
	# - instanceConfig
	# - environmentConfig
	# Use getConfig to retrieve this value
	# @private
	# @property {Object} config
	###
	config: null  # {}


	###*
	# Instance Configuration

	# @private
	# @property {Object} instanceConfig
	###
	instanceConfig: null  # {}

	###*
	# Website Configuration
	# Merged into the config property
	# @private
	# @property {Object} websiteConfig
	###
	websiteConfig: null  # {}

	###*
	# User Configuraiton
	# Merged into the config property
	# @private
	# @property {Object} userConfig
	###
	userConfig:
		# Name
		name: null

		# Email
		email: null

		# Username
		username: null

		# Subscribed
		subscribed: null

		# Subcribe Try Again
		# If our subscription has failed, when should we try again?
		subscribeTryAgain: null

		# Terms of Service
		tos: null

		# Identified
		identified: null

	###*
	# Initial Configuration. The default docpadConfig
	# settings that can be overridden in a project&#x27;s docpad.coffee file.
	# Merged into the config property
	# @private
	# @property {Object} initialConfig
	###
	initialConfig:

		# -----------------------------
		# Plugins

		# Force re-install of all plugin dependencies
		force: false

		# Whether or not we should use the global docpad instance
		global: false

		# Whether or not we should enable plugins that have not been listed or not
		enableUnlistedPlugins: true

		# Plugins which should be enabled or not pluginName: pluginEnabled
		enabledPlugins: {}

		# Whether or not we should skip unsupported plugins
		skipUnsupportedPlugins: true

		# Whether or not to warn about uncompiled private plugins
		warnUncompiledPrivatePlugins: true

		# Configuration to pass to any plugins pluginName: pluginConfiguration
		plugins: {}


		# -----------------------------
		# Project Paths

		# The project directory
		rootPath: process.cwd()

		# The project&#x27;s database cache path
		databaseCachePath: &#x27;.docpad.db&#x27;

		# The project&#x27;s package.json path
		packagePath: &#x27;package.json&#x27;

		# The project&#x27;s configuration paths
		# Reads only the first one that exists
		# If you want to read multiple configuration paths, then point it to a coffee|js file that requires
		# the other paths you want and exports the merged config
		configPaths: [
			&#x27;docpad.js&#x27;
			&#x27;docpad.coffee&#x27;
			&#x27;docpad.json&#x27;
			&#x27;docpad.cson&#x27;
		]

		# Plugin directories to load
		pluginPaths: []

		# The project&#x27;s plugins directory
		pluginsPaths: [
			&#x27;node_modules&#x27;
			&#x27;plugins&#x27;
		]

		# Paths that we should watch for reload changes in
		reloadPaths: []

		# Paths that we should watch for regeneration changes in
		regeneratePaths: []

		# The time to wait after a source file has changed before using it to regenerate
		regenerateDelay: 100

		# The time to wait before outputting the files we are waiting on
		slowFilesDelay: 20*1000

		# The project&#x27;s out directory
		outPath: &#x27;out&#x27;

		# The project&#x27;s src directory
		srcPath: &#x27;src&#x27;

		# The project&#x27;s documents directories
		# relative to the srcPath
		documentsPaths: [
			&#x27;documents&#x27;
			&#x27;render&#x27;
		]

		# The project&#x27;s files directories
		# relative to the srcPath
		filesPaths: [
			&#x27;files&#x27;
			&#x27;static&#x27;
			&#x27;public&#x27;
		]

		# The project&#x27;s layouts directory
		# relative to the srcPath
		layoutsPaths: [
			&#x27;layouts&#x27;
		]

		# Ignored file patterns during directory parsing
		ignorePaths: false
		ignoreHiddenFiles: false
		ignoreCommonPatterns: true
		ignoreCustomPatterns: false

		# Watch options
		watchOptions: null


		# -----------------------------
		# Server

		# Port
		# The port that the server should use
		# Defaults to these environment variables:
		# - PORT — Heroku, Nodejitsu, Custom
		# - VCAP_APP_PORT — AppFog
		# - VMC_APP_PORT — CloudFoundry
		port: null

		# Hostname
		# The hostname we wish to listen to
		# Defaults to these environment variables:
		# HOSTNAME — Generic
		# Do not set to &quot;localhost&quot; it does not work on heroku
		hostname: null

		# Max Age
		# The caching time limit that is sent to the client
		maxAge: 86400000

		# Server
		# The Express.js server that we want docpad to use
		serverExpress: null
		# The HTTP server that we want docpad to use
		serverHttp: null

		# Extend Server
		# Whether or not we should extend the server with extra middleware and routing
		extendServer: true

		# Which middlewares would you like us to activate
		# The standard middlewares (bodyParser, methodOverride, express router)
		middlewareStandard: true
		# The standard bodyParser middleware
		middlewareBodyParser: true
		# The standard methodOverride middleware
		middlewareMethodOverride: true
		# The standard express router middleware
		middlewareExpressRouter: true
		# Our own 404 middleware
		middleware404: true
		# Our own 500 middleware
		middleware500: true


		# -----------------------------
		# Logging

		# Log Level
		# Which level of logging should we actually output
		logLevel: (if (&#x27;-d&#x27; in process.argv) then 7 else 6)

		# Catch uncaught exceptions
		catchExceptions: true

		# Report Errors
		# Whether or not we should report our errors back to DocPad
		# By default it is only enabled if we are not running inside a test
		reportErrors: process.argv.join(&#x27;&#x27;).indexOf(&#x27;test&#x27;) is -1

		# Report Statistics
		# Whether or not we should report statistics back to DocPad
		# By default it is only enabled if we are not running inside a test
		reportStatistics: process.argv.join(&#x27;&#x27;).indexOf(&#x27;test&#x27;) is -1

		# Color
		# Whether or not our terminal output should have color
		# &#x60;null&#x60; will default to what the terminal supports
		color: null


		# -----------------------------
		# Other

		# Utilise the database cache
		databaseCache: false  # [false, true, &#x27;write&#x27;]

		# Detect Encoding
		# Should we attempt to auto detect the encoding of our files?
		# Useful when you are using foreign encoding (e.g. GBK) for your files
		detectEncoding: false

		# Render Single Extensions
		# Whether or not we should render single extensions by default
		renderSingleExtensions: false

		# Render Passes
		# How many times should we render documents that reference other documents?
		renderPasses: 1

		# Offline
		# Whether or not we should run in offline mode
		# Offline will disable the following:
		# - checkVersion
		# - reportErrors
		# - reportStatistics
		offline: false

		# Check Version
		# Whether or not to check for newer versions of DocPad
		checkVersion: false

		# Welcome
		# Whether or not we should display any custom welcome callbacks
		welcome: false

		# Prompts
		# Whether or not we should display any prompts
		prompts: false

		# Progress
		# Whether or not we should display any progress bars
		# Requires prompts being true, and log level 6 or above
		progress: true

		# Powered By DocPad
		# Whether or not we should include DocPad in the Powered-By meta header
		# Please leave this enabled as it is a standard practice and promotes DocPad in the web eco-system
		poweredByDocPad: true

		# Helper Url
		# Used for subscribing to newsletter, account information, and statistics etc
		# Helper&#x27;s source-code can be found at: https://github.com/docpad/helper
		helperUrl: if true then &#x27;http://helper.docpad.org/&#x27; else &#x27;http://localhost:8000/&#x27;

		# Safe Mode
		# If enabled, we will try our best to sandbox our template rendering so that they cannot modify things outside of them
		# Not yet implemented
		safeMode: false

		# Template Data
		# What data would you like to expose to your templates
		templateData: {}

		# Collections
		# A hash of functions that create collections
		collections: {}

		# Events
		# A hash of event handlers
		events: {}

		# Regenerate Every
		# Performs a regenerate every x milliseconds, useful for always having the latest data
		regenerateEvery: false

		# Regerenate Every Options
		# The generate options to use on the regenerate every call
		regenerateEveryOptions:
			populate: true
			partial:  false


		# -----------------------------
		# Environment Configuration

		# Locale Code
		# The code we shall use for our locale (e.g. en, fr, etc)
		localeCode: null

		# Environment
		# Whether or not we are in production or development
		# Separate environments using a comma or a space
		env: null

		# Environments
		# Environment specific configuration to over-ride the global configuration
		environments:
			development:
				# Always refresh from server
				maxAge: false

				# Only do these if we are running standalone (aka not included in a module)
				checkVersion: isUser
				welcome: isUser
				prompts: isUser

	###*
	# Regenerate Timer
	# When config.regenerateEvery is set to a value, we create a timer here
	# @private
	# @property {Object} regenerateTimer
	###
	regenerateTimer: null

	###*
	# Get the DocPad configuration. Commonly
	# called within the docpad.coffee file or within
	# plugins to access application specific configurations.
	# 	serverExtend: (opts) -&gt;
			# Extract the server from the options
			{server} = opts
			docpad = @docpad

			# As we are now running in an event,
			# ensure we are using the latest copy of the docpad configuraiton
			# and fetch our urls from it
			latestConfig = docpad.getConfig()
			oldUrls = latestConfig.templateData.site.oldUrls or []
			newUrl = latestConfig.templateData.site.url

			# Redirect any requests accessing one of our sites oldUrls to the new site url
			server.use (req,res,next) -&gt;
				...
	# @method getConfig
	# @return {Object} the DocPad configuration object
	###
	getConfig: -&gt;
		return @config or {}

	###*
	# Get the port that DocPad is listening on (eg 9778)
	# @method getPort
	# @return {Number} the port number
	###
	getPort: -&gt;
		return @getConfig().port ? require(&#x27;hostenv&#x27;).PORT ? 9778

	###*
	# Get the Hostname
	# @method getHostname
	# @return {String}
	###
	getHostname: -&gt;
		return @getConfig().hostname ? require(&#x27;hostenv&#x27;).HOSTNAME ? &#x27;0.0.0.0&#x27;

	###*
	# Get address
	# @method getServerUrl
	# @param {Object} [opts={}]
	# @return {String}
	###
	getServerUrl: (opts={}) -&gt;
		opts.hostname ?= @getHostname()
		opts.port ?= @getPort()
		opts.simple ?= false
		if opts.simple is true and opts.hostname in [&#x27;0.0.0.0&#x27;, &#x27;::&#x27;, &#x27;::1&#x27;]
			return &quot;http://127.0.0.1:#{opts.port}&quot;
		else
			return &quot;http://#{opts.hostname}:#{opts.port}&quot;

	###*
	# Get simple server URL (changes 0.0.0.0, ::, and ::1 to 127.0.0.1)
	# @method getSimpleServerUrl
	# @param {Object} [opts={}]
	# @param {Boolean} [opts.simple=true]
	# @return {String}
	###
	getSimpleServerUrl: (opts={}) -&gt;
		opts.simple = true
		return @getServerUrl(opts)


	# =================================
	# Initialization Functions

	###*
	# Constructor method. Sets up the DocPad instance.
	# next(err)
	# @method constructor
	# @param {Object} instanceConfig
	# @param {Function} next callback
	# @param {Error} next.err
	###
	constructor: (instanceConfig,next) -&gt;
		# Prepare
		[instanceConfig,next] = extractOptsAndCallback(instanceConfig, next)
		docpad = @

		# Create our own custom TaskGroup class for DocPad
		# That will listen to tasks as they execute and provide debugging information
		@TaskGroup = class extends TaskGroup
			constructor: -&gt;
				# Prepare
				super
				tasks = @

				# Listen to executing tasks and output their progress
				tasks.on &#x27;started&#x27;, -&gt;
					config = tasks.getConfig()
					name = tasks.getNames()
					progress = config.progress
					if progress
						totals = tasks.getItemTotals()
						progress.step(name).total(totals.total).setTick(totals.completed)
					else
						docpad.log(&#x27;debug&#x27;, name+&#x27; &gt; started&#x27;)

				# Listen to executing tasks and output their progress
				tasks.on &#x27;item.add&#x27;, (item) -&gt;
					config = tasks.getConfig()
					name = item.getNames()
					progress = config.progress
					if progress
						totals = tasks.getItemTotals()
						progress.step(name).total(totals.total).setTick(totals.completed)
					else
						docpad.log(&#x27;debug&#x27;, name+&#x27; &gt; added&#x27;)

				# Listen to executing tasks and output their progress
				tasks.on &#x27;item.started&#x27;, (item) -&gt;
					config = tasks.getConfig()
					name = item.getNames()
					progress = config.progress
					if progress
						totals = tasks.getItemTotals()
						progress.step(name).total(totals.total).setTick(totals.completed)
					else
						docpad.log(&#x27;debug&#x27;, name+&#x27; &gt; started&#x27;)

				# Listen to executing tasks and output their progress
				tasks.on &#x27;item.done&#x27;, (item, err) -&gt;
					config = tasks.getConfig()
					name = item.getNames()
					progress = config.progress
					if progress
						totals = tasks.getItemTotals()
						progress.step(name).total(totals.total).setTick(totals.completed)
					else
						docpad.log(&#x27;debug&#x27;, name+&#x27; &gt; done&#x27;)

				# Chain
				@

		# Binders
		# Using this over coffescript&#x27;s =&gt; on class methods, ensures that the method length is kept
		for methodName in &quot;&quot;&quot;
			action
			log warn error fatal inspector notify track identify subscribe checkRequest
			serverMiddlewareRouter serverMiddlewareHeader serverMiddleware404 serverMiddleware500
			destroyWatchers
			&quot;&quot;&quot;.split(/\s+/)
			@[methodName] = @[methodName].bind(@)

		# Allow DocPad to have unlimited event listeners
		@setMaxListeners(0)

		# Setup configuration event wrappers
		configEventContext = {docpad}  # here to allow the config event context to persist between event calls
		@getEvents().forEach (eventName) -&gt;
			# Bind to the event
			docpad.on eventName, (opts,next) -&gt;
				eventHandler = docpad.getConfig().events?[eventName]
				# Fire the config event handler for this event, if it exists
				if typeChecker.isFunction(eventHandler)
					args = [opts,next]
					ambi(eventHandler.bind(configEventContext), args...)
				# It doesn&#x27;t exist, so lets continue
				else
					next()

		# Create our action runner
		@actionRunnerInstance = @TaskGroup.create(&#x27;action runner&#x27;).whenDone (err) -&gt;
			docpad.error(err)  if err

		# Create our track runner
		@trackRunnerInstance = @TaskGroup.create(&#x27;track runner&#x27;).whenDone (err) -&gt;
			if err and docpad.getDebugging()
				locale = docpad.getLocale()
				docpad.warn(locale.trackError, err)

		# Initialize the loggers
		if (loggers = instanceConfig.loggers)
			delete instanceConfig.loggers
		else
			# Create
			logger = new (require(&#x27;caterpillar&#x27;).Logger)(lineOffset: 2)

			# console
			loggerConsole = logger
				.pipe(
					new (require(&#x27;caterpillar-filter&#x27;).Filter)
				)
				.pipe(
					new (require(&#x27;caterpillar-human&#x27;).Human)
				)

			# Apply
			loggers = {logger, console:loggerConsole}

		# Apply the loggers
		safefs.unlink(@debugLogPath, -&gt; )  # Remove the old debug log file
		@setLoggers(loggers)  # Apply the logger streams
		@setLogLevel(instanceConfig.logLevel ? @initialConfig.logLevel)  # Set the default log level

		# Log to bubbled events
		@on &#x27;log&#x27;, (args...) -&gt;
			docpad.log.apply(@,args)

		# Dereference and initialise advanced variables
		# we deliberately ommit initialTemplateData here, as it is setup in getTemplateData
		@slowPlugins = {}
		@loadedPlugins = {}
		@exchange = {}
		@pluginsTemplateData = {}
		@instanceConfig = {}
		@collections = []
		@blocks = {}
		@filesByUrl = {}
		@filesBySelector = {}
		@filesByOutPath = {}
		@database = new FilesCollection(null, {name:&#x27;database&#x27;})
			.on(&#x27;remove&#x27;, (model,options) -&gt;
				# Skip if we are not a writeable file
				return  if model.get(&#x27;write&#x27;) is false

				# Delete the urls
				for url in model.get(&#x27;urls&#x27;) or []
					delete docpad.filesByUrl[url]

				# Ensure we regenerate anything (on the next regeneration) that was using the same outPath
				outPath = model.get(&#x27;outPath&#x27;)
				if outPath
					updatedModels = docpad.database.findAll({outPath})
					updatedModels.remove(model)
					updatedModels.each (model) -&gt;
						model.set(&#x27;mtime&#x27;: new Date())

					# Log
					docpad.log(&#x27;debug&#x27;, &#x27;Updated mtime for these models due to remove of a similar one&#x27;, updatedModels.pluck(&#x27;relativePath&#x27;))

				# Return safely
				return true
			)
			.on(&#x27;add change:urls&#x27;, (model) -&gt;
				# Skip if we are not a writeable file
				return  if model.get(&#x27;write&#x27;) is false

				# Delete the old urls
				for url in model.previous(&#x27;urls&#x27;) or []
					delete docpad.filesByUrl[url]

				# Add the new urls
				for url in model.get(&#x27;urls&#x27;)
					docpad.filesByUrl[url] = model.cid

				# Return safely
				return true
			)
			.on(&#x27;add change:outPath&#x27;, (model) -&gt;
				# Skip if we are not a writeable file
				return  if model.get(&#x27;write&#x27;) is false

				# Check if we have changed our outPath
				previousOutPath = model.previous(&#x27;outPath&#x27;)
				if previousOutPath
					# Ensure we regenerate anything (on the next regeneration) that was using the same outPath
					previousModels = docpad.database.findAll(outPath:previousOutPath)
					previousModels.remove(model)
					previousModels.each (model) -&gt;
						model.set(&#x27;mtime&#x27;: new Date())

					# Log
					docpad.log(&#x27;debug&#x27;, &#x27;Updated mtime for these models due to addition of a similar one&#x27;, previousModels.pluck(&#x27;relativePath&#x27;))

					# Update the cache entry with another file that has the same outPath or delete it if there aren&#x27;t any others
					previousModelId = docpad.filesByOutPath[previousOutPath]
					if previousModelId is model.id
						if previousModels.length
							docpad.filesByOutPath[previousOutPath] = previousModelId
						else
							delete docpad.filesByOutPath[previousOutPath]

				# Update the cache entry and fetch the latest if it was already set
				if (outPath = model.get(&#x27;outPath&#x27;))
					existingModelId = docpad.filesByOutPath[outPath] ?= model.id
					if existingModelId isnt model.id
						existingModel = docpad.database.get(existingModelId)
						if existingModel
							# We have a conflict, let the user know
							modelPath = model.get(&#x27;fullPath&#x27;) or (model.get(&#x27;relativePath&#x27;)+&#x27;:&#x27;+model.id)
							existingModelPath = existingModel.get(&#x27;fullPath&#x27;) or (existingModel.get(&#x27;relativePath&#x27;)+&#x27;:&#x27;+existingModel.id)
							docpad.warn util.format(docpad.getLocale().outPathConflict, outPath, modelPath, existingModelPath)
						else
							# There reference was old, update it with our new one
							docpad.filesByOutPath[outPath] = model.id

				# Return safely
				return true
			)
		@userConfig = extendr.dereference(@userConfig)
		@initialConfig = extendr.dereference(@initialConfig)

		# Extract action
		if instanceConfig.action?
			action = instanceConfig.action
		else
			action = &#x27;load ready&#x27;

		# Check if we want to perform an action
		if action
			@action action, instanceConfig, (err) -&gt;
				if next?
					next(err, docpad)
				else if err
					docpad.fatal(err)
		else
			next?(null, docpad)

		# Chain
		@

	###*
	# Destructor. Destroy the DocPad instance
	# This is an action, and should be called as such
	# E.g. docpad.action(&#x27;destroy&#x27;, next)
	# @method destroy
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	destroy: (opts, next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @

		# Destroy Regenerate Timer
		docpad.destroyRegenerateTimer()

		# Wait one second to wait for any logging to complete
		docpadUtil.wait 1000, -&gt;

			# Destroy Plugins
			docpad.emitSerial &#x27;docpadDestroy&#x27;, (err) -&gt;
				# Check
				return next?(err)  if err

				# Destroy Plugins
				docpad.destroyPlugins()

				# Destroy Server
				docpad.destroyServer()

				# Destroy Watchers
				docpad.destroyWatchers()

				# Destroy Blocks
				docpad.destroyBlocks()

				# Destroy Collections
				docpad.destroyCollections()

				# Destroy Database
				docpad.destroyDatabase()

				# Destroy Logging
				docpad.destroyLoggers()

				# Destroy Process Listners
				process.removeListener(&#x27;uncaughtException&#x27;, docpad.error)

				# Destroy DocPad Listeners
				docpad.removeAllListeners()

				# Forward
				return next?()

		# Chain
		@

	###*
	# Emit event, serial
	# @private
	# @method emitSerial
	# @param {String} eventName
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	emitSerial: (eventName, opts, next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		locale = docpad.getLocale()

		# Log
		docpad.log &#x27;debug&#x27;, util.format(locale.emittingEvent, eventName)

		# Emit
		super eventName, opts, (err) -&gt;
			# Check
			return next(err)  if err

			# Log
			docpad.log &#x27;debug&#x27;, util.format(locale.emittedEvent, eventName)

			# Forward
			return next(err)

		# Chain
		@

	###*
	# Emit event, parallel
	# @private
	# @method emitParallel
	# @param {String} eventName
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	emitParallel: (eventName, opts, next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		locale = docpad.getLocale()

		# Log
		docpad.log &#x27;debug&#x27;, util.format(locale.emittingEvent, eventName)

		# Emit
		super eventName, opts, (err) -&gt;
			# Check
			return next(err)  if err

			# Log
			docpad.log &#x27;debug&#x27;, util.format(locale.emittedEvent, eventName)

			# Forward
			return next(err)

		# Chain
		@


	# =================================
	# Helpers

	###*
	# Get the ignore options for the DocPad project
	# @method getIgnoreOpts
	# @return {Array} string array of ignore options
	###
	getIgnoreOpts: -&gt;
		return pick(@config, [&#x27;ignorePaths&#x27;, &#x27;ignoreHiddenFiles&#x27;, &#x27;ignoreCommonPatterns&#x27;, &#x27;ignoreCustomPatterns&#x27;])

	###*
	# Is the supplied path ignored?
	# @method isIgnoredPath
	# @param {String} path
	# @param {Object} [opts={}]
	# @return {Boolean}
	###
	isIgnoredPath: (path,opts={}) -&gt;
		opts = extendr.extend(@getIgnoreOpts(), opts)
		return ignorefs.isIgnoredPath(path, opts)

	###*
	# Scan directory
	# @method scandir
	# @param {Object} [opts={}]
	###
	#NB: How does this work? What is returned?
	#Does it require a callback (next) passed as
	#one of the options
	scandir: (opts={}) -&gt;
		opts = extendr.extend(@getIgnoreOpts(), opts)
		return scandir(opts)

	###*
	# Watch Directory. Wrapper around the Bevry watchr
	# module (https://github.com/bevry/watchr). Used
	# internally by DocPad to watch project documents
	# and files and then activate the regeneration process
	# when any of those items are updated.
	#
	# Although it is possible to pass a range of options to watchdir
	# in practice these options are provided as part of
	# the DocPad config object with a number of default options
	# specified in the DocPad config.
	# @method watchdir
	# @param {Object} [opts={}]
	# @param {String} [opts.path] a single path to watch.
	# @param {Array} [opts.paths] an array of paths to watch.
	# @param {Function} [opts.listener] a single change listener to fire when a change occurs.
	# @param {Array} [opts.listeners] an array of listeners.
	# @param {Function} [opts.next] callback.
	# @param {Object} [opts.stat] a file stat object to use for the path, instead of fetching a new one.
	# @param {Number} [opts.interval=5007] for systems that poll to detect file changes, how often should it poll in millseconds.
	# @param {Number} [opts.catupDelay=200] handles system swap file deletions and renaming
	# @param {Array} [opts.preferredMethods=[&#x27;watch&#x27;,&#x27;watchFile&#x27;] which order should we prefer our watching methods to be tried?.
	# @param {Boolean} [opts.followLinks=true] follow symlinks, i.e. use stat rather than lstat.
	# @param {Boolean|Array} [opts.ignorePaths=false] an array of full paths to ignore.
	# @param {Boolean|Array} [opts.ignoreHiddenFiles=false] whether or not to ignored files which filename starts with a &quot;.&quot;.
	# @param {Boolean} [opts.ignoreCommonPatterns=true] whether or not to ignore common undesirable file patterns (e.g. .svn, .git, .DS_Store, thumbs.db, etc).
	# @param {Boolean|Array} [opts.ignoreCustomPatterns=null] any custom ignore patterns that you would also like to ignore along with the common patterns.
	# @return {Object} the watcher
	###
	watchdir: (opts={}) -&gt;
		opts = extendr.extend(@getIgnoreOpts(), opts, @config.watchOptions)
		return require(&#x27;watchr&#x27;).watch(opts)


	# =================================
	# Setup and Loading

	###*
	# DocPad is ready. Peforms the tasks needed after DocPad construction
	# and DocPad has loaded. Triggers the docpadReady event.
	# next(err,docpadInstance)
	# @private
	# @method ready
	# @param {Object} [opts]
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.docpadInstance
	###
	ready: (opts,next) -&gt;
		# Prepare
		[instanceConfig,next] = extractOptsAndCallback(instanceConfig,next)
		docpad = @
		config = @getConfig()
		locale = @getLocale()

		# Render Single Extensions
		@DocumentModel::defaults.renderSingleExtensions = config.renderSingleExtensions

		# Version Check
		@compareVersion()

		# Welcome Prepare
		if @getDebugging()
			pluginsList = (&quot;#{pluginName} v#{@loadedPlugins[pluginName].version}&quot;  for pluginName in Object.keys(@loadedPlugins).sort()).join(&#x27;, &#x27;)
		else
			pluginsList = Object.keys(@loadedPlugins).sort().join(&#x27;, &#x27;)

		# Welcome Output
		docpad.log &#x27;info&#x27;, util.format(locale.welcome, @getVersionString())
		docpad.log &#x27;notice&#x27;, locale.welcomeDonate
		docpad.log &#x27;info&#x27;, locale.welcomeContribute
		docpad.log &#x27;info&#x27;, util.format(locale.welcomePlugins, pluginsList)
		docpad.log &#x27;info&#x27;, util.format(locale.welcomeEnvironment, @getEnvironment())

		# Prepare
		tasks = new @TaskGroup &#x27;ready tasks&#x27;, next:(err) -&gt;
			# Error?
			return docpad.error(err)  if err

			# All done, forward our DocPad instance onto our creator
			return next?(null,docpad)

		tasks.addTask &#x27;welcome event&#x27;, (complete) -&gt;
			# No welcome
			return complete()  unless config.welcome

			# Welcome
			docpad.emitSerial(&#x27;welcome&#x27;, {docpad}, complete)

		tasks.addTask &#x27;track&#x27;, (complete) -&gt;
			# Identify
			return docpad.identify(complete)

		tasks.addTask &#x27;emit docpadReady&#x27;, (complete) -&gt;
			docpad.emitSerial(&#x27;docpadReady&#x27;, {docpad}, complete)

		# Run tasks
		tasks.run()

		# Chain
		@

	###*
	# Performs the merging of the passed configuration objects
	# @private
	# @method mergeConfigurations
	# @param {Object} configPackages
	# @param {Object} configsToMerge
	###
	mergeConfigurations: (configPackages,configsToMerge) -&gt;
		# Prepare
		envs = @getEnvironments()

		# Figure out merging
		for configPackage in configPackages
			continue  unless configPackage
			configsToMerge.push(configPackage)
			for env in envs
				envConfig = configPackage.environments?[env]
				configsToMerge.push(envConfig)  if envConfig

		# Merge
		extendr.safeDeepExtendPlainObjects(configsToMerge...)

		# Chain
		@

	###*
	# Set the instance configuration
	# by merging the properties of the passed object
	# with the existing DocPad instanceConfig object
	# @private
	# @method setInstanceConfig
	# @param {Object} instanceConfig
	###
	setInstanceConfig: (instanceConfig) -&gt;
		# Merge in the instance configurations
		if instanceConfig
			logLevel = @getLogLevel()
			extendr.safeDeepExtendPlainObjects(@instanceConfig, instanceConfig)
			extendr.safeDeepExtendPlainObjects(@config, instanceConfig)  if @config  # @TODO document why there is the if
			@setLogLevel(instanceConfig.logLevel)  if instanceConfig.logLevel and instanceConfig.logLevel isnt logLevel
		@

	###*
	# Set the DocPad configuration object.
	# Performs a number of tasks, including
	# merging the pass instanceConfig with DocPad&#x27;s
	# other config objects.
	# next(err,config)
	# @private
	# @method setConfig
	# @param {Object} instanceConfig
	# @param {Object} next
	# @param {Error} next.err
	# @param {Object} next.config
	###
	setConfig: (instanceConfig,next) -&gt;
		# Prepare
		[instanceConfig,next] = extractOptsAndCallback(instanceConfig,next)
		docpad = @
		locale = @getLocale()

		# Apply the instance configuration, generally we won&#x27;t have it at this level
		# as it would have been applied earlier the load step
		@setInstanceConfig(instanceConfig)  if instanceConfig

		# Apply the environment
		# websitePackageConfig.env is left out of the detection here as it is usually an object
		# that is already merged with our process.env by the environment runner
		# rather than a string which is the docpad convention
		@config.env = @instanceConfig.env or @websiteConfig.env or @initialConfig.env or process.env.NODE_ENV

		# Merge configurations
		configPackages = [@initialConfig, @userConfig, @websiteConfig, @instanceConfig]
		configsToMerge = [@config]
		docpad.mergeConfigurations(configPackages, configsToMerge)

		# Extract and apply the server
		@setServer extendr.safeShallowExtendPlainObjects({
			serverHttp: @config.serverHttp
			serverExpress: @config.serverExpress
		},  @config.server)

		# Extract and apply the logger
		@setLogLevel(@config.logLevel)

		# Resolve any paths
		@config.rootPath = pathUtil.resolve(@config.rootPath)
		@config.outPath = pathUtil.resolve(@config.rootPath, @config.outPath)
		@config.srcPath = pathUtil.resolve(@config.rootPath, @config.srcPath)
		@config.databaseCachePath = pathUtil.resolve(@config.rootPath, @config.databaseCachePath)
		@config.packagePath = pathUtil.resolve(@config.rootPath, @config.packagePath)

		# Resolve Documents, Files, Layouts paths
		for type in [&#x27;documents&#x27;,&#x27;files&#x27;,&#x27;layouts&#x27;]
			typePaths = @config[type+&#x27;Paths&#x27;]
			for typePath,key in typePaths
				typePaths[key] = pathUtil.resolve(@config.srcPath, typePath)

		# Resolve Plugins paths
		for type in [&#x27;plugins&#x27;]
			typePaths = @config[type+&#x27;Paths&#x27;]
			for typePath,key in typePaths
				typePaths[key] = pathUtil.resolve(@config.rootPath, typePath)

		# Bind the error handler, so we don&#x27;t crash on errors
		process.removeListener(&#x27;uncaughtException&#x27;, @error)
		@removeListener(&#x27;error&#x27;, @error)
		if @config.catchExceptions
			process.setMaxListeners(0)
			process.on(&#x27;uncaughtException&#x27;, @error)
			@on(&#x27;error&#x27;, @error)

		# Prepare the Post Tasks
		postTasks = new @TaskGroup &#x27;setConfig post tasks&#x27;, next:(err) -&gt;
			return next(err, docpad.config)

		###
		postTasks.addTask &#x27;lazy depedencnies: encoding&#x27;, (complete) =&gt;
			return complete()  unless @config.detectEncoding
			return lazyRequire &#x27;encoding&#x27;, {cwd:corePath, stdio:&#x27;inherit&#x27;}, (err) -&gt;
				docpad.warn(locale.encodingLoadFailed)  if err
				return complete()
		###

		postTasks.addTask &#x27;load plugins&#x27;, (complete) -&gt;
			docpad.loadPlugins(complete)

		postTasks.addTask &#x27;extend collections&#x27;, (complete) -&gt;
			docpad.extendCollections(complete)

		postTasks.addTask &#x27;fetch plugins templateData&#x27;, (complete) -&gt;
			docpad.emitSerial(&#x27;extendTemplateData&#x27;, {templateData:docpad.pluginsTemplateData}, complete)

		postTasks.addTask &#x27;fire the docpadLoaded event&#x27;, (complete) -&gt;
			docpad.emitSerial(&#x27;docpadLoaded&#x27;, complete)

		# Fire post tasks
		postTasks.run()

		# Chain
		@


	###*
	# Load the various configuration files from the
	# file system. Set the instanceConfig.
	# next(err,config)
	# @private
	# @method load
	# @param {Object} instanceConfig
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.config
	###
	load: (instanceConfig,next) -&gt;
		# Prepare
		[instanceConfig,next] = extractOptsAndCallback(instanceConfig,next)
		docpad = @
		locale = @getLocale()
		instanceConfig or= {}

		# Reset non persistant configurations
		@websitePackageConfig = {}
		@websiteConfig = {}
		@config = {}

		# Merge in the instance configurations
		@setInstanceConfig(instanceConfig)

		# Prepare the Load Tasks
		preTasks = new @TaskGroup &#x27;load tasks&#x27;, next:(err) =&gt;
			return next(err)  if err
			return @setConfig(next)

		preTasks.addTask &#x27;normalize the userConfigPath&#x27;, (complete) =&gt;
			safeps.getHomePath (err,homePath) =&gt;
				return complete(err)  if err
				dropboxPath = pathUtil.resolve(homePath, &#x27;Dropbox&#x27;)
				safefs.exists dropboxPath, (dropboxPathExists) =&gt;
					# @TODO: Implement checks here for
					# https://github.com/bevry/docpad/issues/799
					userConfigDirPath = if dropboxPathExists then dropboxPath else homePath
					@userConfigPath = pathUtil.resolve(userConfigDirPath, @userConfigPath)
					return complete()

		preTasks.addTask &quot;load the user&#x27;s configuration&quot;, (complete) =&gt;
			configPath = @userConfigPath
			docpad.log &#x27;debug&#x27;, util.format(locale.loadingUserConfig, configPath)
			@loadConfigPath {configPath}, (err,data) =&gt;
				return complete(err)  if err

				# Apply loaded data
				extendr.extend(@userConfig, data or {})

				# Done
				docpad.log &#x27;debug&#x27;, util.format(locale.loadingUserConfig, configPath)
				return complete()

		preTasks.addTask &quot;load the anonymous user&#x27;s configuration&quot;, (complete) =&gt;
			# Ignore if username is already identified
			return complete()  if @userConfig.username

			# User is anonymous, set their username to the hashed and salted mac address
			require(&#x27;getmac&#x27;).getMac (err,macAddress) =&gt;
				if err or !macAddress
					docpad.warn(locale.macError, err)
					return complete()

				# Hash with salt
				try
					macAddressHash = require(&#x27;crypto&#x27;).createHmac(&#x27;sha1&#x27;, docpad.hashKey).update(macAddress).digest(&#x27;hex&#x27;)
				catch err
					return complete()  if err

				# Apply
				if macAddressHash
					@userConfig.name ?= &quot;MAC #{macAddressHash}&quot;
					@userConfig.username ?= macAddressHash

				# Next
				return complete()

		preTasks.addTask &quot;load the website&#x27;s package data&quot;, (complete) =&gt;
			rootPath = pathUtil.resolve(@instanceConfig.rootPath or @initialConfig.rootPath)
			configPath = pathUtil.resolve(rootPath, @instanceConfig.packagePath or @initialConfig.packagePath)
			docpad.log &#x27;debug&#x27;, util.format(locale.loadingWebsitePackageConfig, configPath)
			@loadConfigPath {configPath}, (err,data) =&gt;
				return complete(err)  if err
				data or= {}

				# Apply loaded data
				@websitePackageConfig = data

				# Done
				docpad.log &#x27;debug&#x27;, util.format(locale.loadedWebsitePackageConfig, configPath)
				return complete()

		preTasks.addTask &quot;read the .env file if it exists&quot;, (complete) =&gt;
			rootPath = pathUtil.resolve(@instanceConfig.rootPath or @websitePackageConfig.rootPath or @initialConfig.rootPath)
			configPath = pathUtil.resolve(rootPath, &#x27;.env&#x27;)
			docpad.log &#x27;debug&#x27;, util.format(locale.loadingEnvConfig, configPath)
			safefs.exists configPath, (exists) -&gt;
				return complete()  unless exists
				require(&#x27;envfile&#x27;).parseFile configPath, (err,data) -&gt;
					return complete(err)  if err
					for own key,value of data
						process.env[key] = value
					docpad.log &#x27;debug&#x27;, util.format(locale.loadingEnvConfig, configPath)
					return complete()

		preTasks.addTask &quot;load the website&#x27;s configuration&quot;, (complete) =&gt;
			docpad.log &#x27;debug&#x27;, util.format(locale.loadingWebsiteConfig)
			rootPath = pathUtil.resolve(@instanceConfig.rootPath or @initialConfig.rootPath)
			configPaths = @instanceConfig.configPaths or @initialConfig.configPaths
			for configPath, index in configPaths
				configPaths[index] = pathUtil.resolve(rootPath, configPath)
			@loadConfigPath {configPaths}, (err,data) =&gt;
				return complete(err)  if err
				data or= {}

				# Apply loaded data
				extendr.extend(@websiteConfig, data)

				# Done
				docpad.log &#x27;debug&#x27;, util.format(locale.loadedWebsiteConfig)
				return complete()

		# Run the load tasks synchronously
		preTasks.run()

		# Chain
		@


	# =================================
	# Configuration

	###*
	# Update user configuration with the passed data
	# @method updateUserConfig
	# @param {Object} [data={}]
	# @param {Function} next
	# @param {Error} next.err
	###
	updateUserConfig: (data={},next) -&gt;
		# Prepare
		[data,next] = extractOptsAndCallback(data,next)
		docpad = @
		userConfigPath = @userConfigPath

		# Apply back to our loaded configuration
		# does not apply to @config as we would have to reparse everything
		# and that appears to be an imaginary problem
		extendr.extend(@userConfig, data)  if data

		# Convert to CSON
		CSON.createCSONString @userConfig, (err, userConfigString) -&gt;
			if err
				err.context = &quot;Failed to create the CSON string for the user configuration&quot;
				return next(err)

			# Write it
			safefs.writeFile userConfigPath, userConfigString, &#x27;utf8&#x27;, (err) -&gt;
				# Forward
				return next(err)

		# Chain
		@

	###*
	# Load a configuration url.
	# @method loadConfigUrl
	# @param {String} configUrl
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.parsedData
	###
	loadConfigUrl: (configUrl,next) -&gt;
		# Prepare
		docpad = @
		locale = @getLocale()

		# Log
		docpad.log &#x27;debug&#x27;, util.format(locale.loadingConfigUrl, configUrl)

		# Read the URL
		superAgent
			.get(configUrl)
			.timeout(30*1000)
			.end (err,res) -&gt;
				# Check
				return next(err)  if err

				# Read the string using CSON
				CSON.parseCSONString(res.text, next)

		# Chain
		@


	###*
	# Load the configuration from a file path
	# passed as one of the options (opts.configPath) or
	# from DocPad&#x27;s configPaths
	# @private
	# @method loadConfigPath
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.parsedData
	###
	loadConfigPath: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		locale = @getLocale()

		# Prepare
		load = (configPath) -&gt;
			# Check
			return next()  unless configPath

			# Log
			docpad.log &#x27;debug&#x27;, util.format(locale.loadingConfigPath, configPath)

			# Check that it exists
			safefs.exists configPath, (exists) -&gt;
				return next()  unless exists

				# Prepare CSON Options
				csonOptions =
					cson: true
					json: true
					coffeescript: true
					javascript: true

				# Read the path using CSON
				CSON.requireFile configPath, csonOptions, (err, data) -&gt;
					if err
						err.context = util.format(locale.loadingConfigPathFailed, configPath)
						return next(err)

					# Check if the data is a function, if so, then execute it as one
					while typeChecker.isFunction(data)
						try
							data = data(docpad)
						catch err
							return next(err)
					unless typeChecker.isObject(data)
						err = new Error(&quot;Loading the configuration #{docpad.inspector configPath} returned an invalid result #{docpad.inspector data}&quot;)
						return next(err)  if err

					# Return the data
					return next(null, data)

		# Check
		if opts.configPath
			load(opts.configPath)
		else
			@getConfigPath opts, (err,configPath) -&gt;
				load(configPath)

		# Chain
		@

	###*
	# Get config paths and check that those
	# paths exist
	# @private
	# @method getConfigPath
	# @param {Object} opts
	# @param {Object} next
	# @param {Error} next.err
	# @param {String} next.path
	###
	getConfigPath: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		config = @getConfig()
		result = null

		# Ensure array
		opts.configPaths ?= config.configPaths
		opts.configPaths = [opts.configPaths]  unless typeChecker.isArray(opts.configPaths)

		tasks = new @TaskGroup &#x27;getConfigPath tasks&#x27;, next:(err) -&gt;
			return next(err, result)

		# Determine our configuration path
		opts.configPaths.forEach (configPath) -&gt;
			tasks.addTask &quot;Checking if [#{configPath}] exists&quot;, (complete) -&gt;
				return complete()  if result
				safefs.exists configPath, (exists) -&gt;
					if exists
						result = configPath
						tasks.clear()
						complete()
					else
						complete()

		# Run them synchronously
		tasks.run()

		# Chain
		@


	###*
	# Extend collecitons. Create DocPad&#x27;s
	# standard (documents, files
	# layouts) and special (generate, referencesOthers,
	# hasLayout, html, stylesheet) collections. Set blocks
	# @private
	# @method extendCollections
	# @param {Function} next
	# @param {Error} next.err
	###
	extendCollections: (next) -&gt;
		# Prepare
		docpad = @
		docpadConfig = @getConfig()
		locale = @getLocale()
		database = @getDatabase()

		# Standard Collections
		@setCollections({
			# Standard Collections
			documents: database.createLiveChildCollection()
				.setQuery(&#x27;isDocument&#x27;, {
					render: true
					write: true
				})
				.on(&#x27;add&#x27;, (model) -&gt;
					docpad.log(&#x27;debug&#x27;, util.format(locale.addingDocument, model.getFilePath()))
				)
			files: database.createLiveChildCollection()
				.setQuery(&#x27;isFile&#x27;, {
					render: false
					write: true
				})
				.on(&#x27;add&#x27;, (model) -&gt;
					docpad.log(&#x27;debug&#x27;, util.format(locale.addingFile, model.getFilePath()))
				)
			layouts: database.createLiveChildCollection()
				.setQuery(&#x27;isLayout&#x27;, {
					$or:
						isLayout: true
						fullPath: $startsWith: docpadConfig.layoutsPaths
				})
				.on(&#x27;add&#x27;, (model) -&gt;
					docpad.log(&#x27;debug&#x27;, util.format(locale.addingLayout, model.getFilePath()))
					model.setDefaults({
						isLayout: true
						render: false
						write: false
					})
				)

			# Special Collections
			generate: database.createLiveChildCollection()
				.setQuery(&#x27;generate&#x27;, {
					dynamic: false
					ignored: false
				})
				.on(&#x27;add&#x27;, (model) -&gt;
					docpad.log(&#x27;debug&#x27;, util.format(locale.addingGenerate, model.getFilePath()))
				)
			referencesOthers: database.createLiveChildCollection()
				.setQuery(&#x27;referencesOthers&#x27;, {
					dynamic: false
					ignored: false
					referencesOthers: true
				})
				.on(&#x27;add&#x27;, (model) -&gt;
					docpad.log(&#x27;debug&#x27;, util.format(locale.addingReferencesOthers, model.getFilePath()))
				)
			hasLayout: database.createLiveChildCollection()
				.setQuery(&#x27;hasLayout&#x27;, {
					dynamic: false
					ignored: false
					layout: $exists: true
				})
				.on(&#x27;add&#x27;, (model) -&gt;
					docpad.log(&#x27;debug&#x27;, util.format(locale.addingHasLayout, model.getFilePath()))
				)
			html: database.createLiveChildCollection()
				.setQuery(&#x27;isHTML&#x27;, {
					write: true
					outExtension: &#x27;html&#x27;
				})
				.on(&#x27;add&#x27;, (model) -&gt;
					docpad.log(&#x27;debug&#x27;, util.format(locale.addingHtml, model.getFilePath()))
				)
			stylesheet: database.createLiveChildCollection()
				.setQuery(&#x27;isStylesheet&#x27;, {
					write: true
					outExtension: &#x27;css&#x27;
				})
		})

		# Blocks
		@setBlocks({
			meta: new MetaCollection()
			scripts: new ScriptsCollection()
			styles: new StylesCollection()
		})

		# Custom Collections Group
		tasks = new @TaskGroup &quot;extendCollections tasks&quot;, concurrency:0, next:(err) -&gt;
			docpad.error(err)  if err
			docpad.emitSerial(&#x27;extendCollections&#x27;, next)

		# Cycle through Custom Collections
		eachr docpadConfig.collections or {}, (fn,name) -&gt;
			if !name or !typeChecker.isString(name)
				err = new Error(&quot;Inside your DocPad configuration you have a custom collection with an invalid name of: #{docpad.inspector name}&quot;)
				docpad.error(err)
				return

			if !fn or !typeChecker.isFunction(fn)
				err = new Error(&quot;Inside your DocPad configuration you have a custom collection called #{docpad.inspector name} with an invalid method of: #{docpad.inspector fn}&quot;)
				docpad.error(err)
				return

			tasks.addTask &quot;creating the custom collection: #{name}&quot;, (complete) -&gt;
				# Init
				ambi [fn.bind(docpad), fn], database, (err, collection) -&gt;
					# Check for error
					if err
						docpad.error(err)
						return complete()

					# Check the type of the collection
					else unless collection instanceof QueryCollection
						docpad.warn util.format(locale.errorInvalidCollection, name)
						return complete()

					# Make it a live collection
					collection.live(true)  if collection

					# Apply the collection
					docpad.setCollection(name, collection)
					return complete()

		# Run Custom collections
		tasks.run()

		# Chain
		@


	###*
	# Reset collections. Perform a complete clean of our collections
	# @private
	# @method resetCollections
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	resetCollections: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		database = docpad.getDatabase()

		# Make it as if we have never generated before
		docpad.generated = false

		# Perform a complete clean of our collections
		database.reset([])
		meta = @getBlock(&#x27;meta&#x27;).reset([])
		scripts = @getBlock(&#x27;scripts&#x27;).reset([])
		styles = @getBlock(&#x27;styles&#x27;).reset([])
		# ^ Backbone.js v1.1 changes the return values of these, however we change that in our Element class
		# because if we didn&#x27;t, all our skeletons would fail

		# Add default block entries
		meta.add(&quot;&quot;&quot;&lt;meta name=&quot;generator&quot; content=&quot;DocPad v#{docpad.getVersion()}&quot; /&gt;&quot;&quot;&quot;)  if docpad.getConfig().poweredByDocPad isnt false

		# Reset caches
		@filesByUrl = {}
		@filesBySelector = {}
		@filesByOutPath = {}

		# Chain
		next()
		@


	###*
	# Initialise git repo
	# @private
	# @method initGitRepo
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.results
	###
	initGitRepo: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		config = @getConfig()

		# Extract
		opts.cwd ?= config.rootPath
		opts.output ?= @getDebugging()

		# Forward
		safeps.initGitRepo(opts, next)

		# Chain
		@

	###*
	# Init node modules
	# @private
	# @method initNodeModules
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.results
	###
	initNodeModules: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		config = @getConfig()

		# Extract
		opts.cwd ?= config.rootPath
		opts.output ?= docpad.getDebugging()
		opts.force ?= if config.offline then false else true
		# ^ @todo this line causes --force to be added, when it shouldn&#x27;t be
		opts.args ?= []
		opts.args.push(&#x27;--force&#x27;)  if config.force
		opts.args.push(&#x27;--no-registry&#x27;)  if config.offline

		# Log
		docpad.log(&#x27;info&#x27;, &#x27;npm install&#x27;)  if opts.output

		# Forward
		safeps.initNodeModules(opts, next)

		# Chain
		@

	###*
	# Fix node package versions
	# Combat to https://github.com/npm/npm/issues/4587#issuecomment-35370453
	# @private
	# @method fixNodePackageVersions
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	fixNodePackageVersions: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		config = @getConfig()

		# Extract
		opts.packagePath ?= config.packagePath

		# Read and replace
		safefs.readFile opts.packagePath, (err,buffer) -&gt;
			data = buffer.toString()
			data = data.replace(/(&quot;docpad(?:.*?)&quot;: &quot;)\^/g, &#x27;$1~&#x27;)
			safefs.writeFile opts.packagePath, data, (err) -&gt;
				return next(err)

		# Chain
		@


	###*
	# Install node module. Same as running
	# &#x27;npm install&#x27; through the command line
	# @private
	# @method installNodeModule
	# @param {Array} names
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.result
	###
	installNodeModule: (names,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		config = @getConfig()

		# Extract
		opts.cwd ?= config.rootPath
		opts.args ?= []
		if docpad.getDebugging()
			opts.stdio ?= &#x27;inherit&#x27;

		opts.global ?= false
		opts.global = [&#x27;--global&#x27;]             if opts.global is true
		opts.global = [opts.global]            if opts.global and Array.isArray(opts.global) is false

		opts.save ?= !opts.global
		opts.save = [&#x27;--save&#x27;]                 if opts.save is true
		opts.save = [opts.save]                if opts.save and Array.isArray(opts.save) is false

		# Command
		command = [&#x27;npm&#x27;, &#x27;install&#x27;]

		# Names
		names = names.split(/[,\s]+/)  unless typeChecker.isArray(names)
		names.forEach (name) -&gt;
			# Check
			return  unless name

			# Ensure latest if version isn&#x27;t specfied
			name += &#x27;@latest&#x27;  if name.indexOf(&#x27;@&#x27;) is -1

			# Push the name to the commands
			command.push(name)

		# Arguments
		command.push(opts.args...)
		command.push(&#x27;--force&#x27;)           if config.force
		command.push(&#x27;--no-registry&#x27;)     if config.offline
		command.push(opts.save...)        if opts.save
		command.push(opts.global...)      if opts.global

		# Log
		docpad.log(&#x27;info&#x27;, command.join(&#x27; &#x27;))  if opts.output

		# Forward
		safeps.spawn(command, opts, next)

		# Chain
		@


	###*
	# Uninstall node module. Same as running
	# &#x27;npm uninstall&#x27; through the command line
	# @private
	# @method uninstallNodeModule
	# @param {Array} names
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.result
	###
	uninstallNodeModule: (names,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		config = @getConfig()

		# Extract
		opts.cwd ?= config.rootPath
		opts.output ?= docpad.getDebugging()
		opts.args ?= []

		opts.global ?= false
		opts.global = [&#x27;--global&#x27;]             if opts.global is true
		opts.global = [opts.global]            if opts.global and Array.isArray(opts.global) is false

		opts.save ?= !opts.global
		opts.save = [&#x27;--save&#x27;, &#x27;--save-dev&#x27;]   if opts.save is true
		opts.save = [opts.save]                if opts.save and Array.isArray(opts.save) is false

		# Command
		command = [&#x27;npm&#x27;, &#x27;uninstall&#x27;]

		# Names
		names = names.split(/[,\s]+/)  unless typeChecker.isArray(names)
		command.push(names...)

		# Arguments
		command.push(opts.args...)
		command.push(opts.save...)        if opts.save
		command.push(opts.global...)      if opts.global

		# Log
		docpad.log(&#x27;info&#x27;, command.join(&#x27; &#x27;))  if opts.output

		# Forward
		safeps.spawn(command, opts, next)

		# Chain
		@



	# =================================
	# Logging

	###*
	# Set the log level
	# @private
	# @method setLogLevel
	# @param {Number} level
	###
	setLogLevel: (level) -&gt;
		@getLogger().setConfig({level})
		if level is 7
			loggers = @getLoggers()
			if loggers.debug? is false
				loggers.debug = loggers.logger
					.pipe(
						new (require(&#x27;caterpillar-human&#x27;).Human)(color:false)
					)
					.pipe(
						require(&#x27;fs&#x27;).createWriteStream(@debugLogPath)
					)
		@

	###*
	# Get the log level
	# @method getLogLevel
	# @return {Number} the log level
	###
	getLogLevel: -&gt;
		return @getConfig().logLevel

	###*
	# Are we debugging?
	# @method getDebugging
	# @return {Boolean}
	###
	getDebugging: -&gt;
		return @getLogLevel() is 7


	###*
	# Handle a fatal error
	# @private
	# @method fatal
	# @param {Object} err
	###
	fatal: (err) -&gt;
		docpad = @
		config = @getConfig()

		# Check
		return @  unless err

		# Handle
		@error(err)

		# Even though the error would have already been logged by the above
		# Ensure it is definitely outputted in the case the above fails
		docpadUtil.writeError(err)

		# Destroy DocPad
		@destroy()

		# Chain
		@


	###*
	# Inspect. Converts object to JSON string. Wrapper around nodes util.inspect method.
	# Can&#x27;t use the inspect namespace as for some silly reason it destroys everything
	# @method inspector
	# @param {Object} obj
	# @param {Object} opts
	# @return {String} JSON string of passed object
	###
	inspector: (obj, opts) -&gt;
		opts ?= {}
		opts.colors ?= @getConfig().color
		return docpadUtil.inspect(obj, opts)

	###*
	# Log arguments
	# @property {Object} log
	# @param {Mixed} args...
	###
	log: (args...) -&gt;
		# Log
		logger = @getLogger() or console
		logger.log.apply(logger, args)

		# Chain
		@


	###*
	# Create an error object
	# @method createError
	# @param {Object} err
	# @param {Object} opts
	# @return {Object} the error
	###
	# @TODO: Decide whether or not we should track warnings
	# Previously we didn&#x27;t, but perhaps it would be useful
	# If the statistics gets polluted after a while, we will remove it
	# Ask @balupton to check the stats after March 30th 2015
	createError: (err, opts) -&gt;
		# Prepare
		opts ?= {}
		opts.level ?= err.level ? &#x27;error&#x27;
		opts.track ?= err.track ? true
		opts.tracked ?= err.tracked ? false
		opts.log ?= err.log ? true
		opts.logged ?= err.logged ? false
		opts.notify ?= err.notify ? true
		opts.notified ?= err.notified ? false
		opts.context ?= err.context  if err.context?

		# Ensure we have an error object
		err = new Error(err)  unless err.stack

		# Add our options to the error object
		for own key,value of opts
			err[key] ?= value

		# Return the error
		return err


	###*
	# Create an error (tracks it) and log it
	# @method error
	# @param {Object} err
	# @param {Object} [level=&#x27;err&#x27;]
	###
	error: (err, level=&#x27;err&#x27;) -&gt;
		# Prepare
		docpad = @

		# Create the error and track it
		err = @createError(err, {level})

		# Track the error
		@trackError(err)

		# Log the error
		@logError(err)

		# Notify the error
		@notifyError(err)

		# Chain
		@

	###*
	# Log an error
	# @method logError
	# @param {Object} err
	###
	logError: (err) -&gt;
		# Prepare
		docpad = @
		locale = @getLocale()

		# Track
		if err and err.log isnt false and err.logged isnt true
			err = @createError(err, {logged:true})
			occured =
				if err.level in [&#x27;warn&#x27;, &#x27;warning&#x27;]
					locale.warnOccured
				else
					locale.errorOccured
			message =
				if err.context
					err.context+locale.errorFollows
				else
					occured
			message += &#x27;\n\n&#x27;+err.stack.toString().trim()
			message += &#x27;\n\n&#x27;+locale.errorSubmission
			docpad.log(err.level, message)

		# Chain
		@


	###*
	# Track an error in the background
	# @private
	# @method trackError
	# @param {Object} err
	###
	trackError: (err) -&gt;
		# Prepare
		docpad = @
		config = @getConfig()

		# Track
		if err and err.track isnt false and err.tracked isnt true and config.offline is false and config.reportErrors is true
			err = @createError(err, {tracked:true})
			data = {}
			data.message = err.message
			data.stack = err.stack.toString().trim()  if err.stack
			data.config = config
			data.env = process.env
			docpad.track(&#x27;error&#x27;, data)

		# Chain
		@

	###*
	# Notify error
	# @private
	# @method notifyError
	# @param {Object} err
	###
	notifyError: (err) -&gt;
		# Prepare
		docpad = @
		locale = @getLocale()

		# Check
		if err.notify isnt false and err.notified isnt true
			err.notified = true
			occured =
				if err.level in [&#x27;warn&#x27;, &#x27;warning&#x27;]
					locale.warnOccured
				else
					locale.errorOccured
			docpad.notify(err.message, {title:occured})

		# Chain
		@

	###*
	# Log an error of level &#x27;warn&#x27;
	# @method warn
	# @param {String} message
	# @param {Object} err
	# @return {Object} description
	###
	warn: (message, err) -&gt;
		# Handle
		if err
			err.context = message
			err.level = &#x27;warn&#x27;
			@error(err)
		else
			err =
				if message instanceof Error
					message
				else
					new Error(message)
			err.level = &#x27;warn&#x27;
			@error(err)

		# Chain
		@


	###*
	# Send a notify event to plugins (like growl)
	# @method notify
	# @param {String} message
	# @param {Object} [opts={}]
	###
	notify: (message,opts={}) -&gt;
		# Prepare
		docpad = @

		# Emit
		docpad.emitSerial &#x27;notify&#x27;, {message,opts}, (err) -&gt;
			docpad.error(err)  if err

		# Chain
		@


	###*
	# Check Request
	# @private
	# @method checkRequest
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.res
	###
	checkRequest: (next) -&gt;
		next ?= @error.bind(@)
		return (err,res) -&gt;
			# Check
			return next(err, res)  if err

			# Check
			if res.body?.success is false or res.body?.error
				err = new Error(res.body.error or &#x27;unknown request error&#x27;)  # @TODO localise this
				return next(err, res)

			# Success
			return next(null, res)


	###*
	# Subscribe to the DocPad email list.
	# @private
	# @method subscribe
	# @param {Function} next
	# @param {Error} next.err
	###
	subscribe: (next) -&gt;
		# Prepare
		config = @getConfig()

		# Check
		if config.offline is false
			if @userConfig?.email
				# Data
				data = {}
				data.email = @userConfig.email  # required
				data.name = @userConfig.name or null
				data.username = @userConfig.username or null

				# Apply
				superAgent
					.post(config.helperUrl)
					.type(&#x27;json&#x27;).set(&#x27;Accept&#x27;, &#x27;application/json&#x27;)
					.query(
						method: &#x27;add-subscriber&#x27;
					)
					.send(data)
					.timeout(30*1000)
					.end @checkRequest next
			else
				err = new Error(&#x27;Email not provided&#x27;)  # @TODO localise this
				next?(err)
		else
			next?()

		# Chain
		@

	###*
	# Track
	# @private
	# @method track
	# @param {String} name
	# @param {Object} [things={}]
	# @param {Function} next
	# @param {Error} next.err
	###
	track: (name,things={},next) -&gt;
		# Prepare
		docpad = @
		config = @getConfig()

		# Check
		if config.offline is false and config.reportStatistics
			# Data
			data = {}
			data.userId = @userConfig.username or null
			data.event = name
			data.properties = things

			# Things
			things.websiteName = @websitePackageConfig.name  if @websitePackageConfig?.name
			things.platform = @getProcessPlatform()
			things.environment = @getEnvironment()
			things.version = @getVersion()
			things.nodeVersion = @getProcessVersion()

			# Plugins
			eachr docpad.loadedPlugins, (value,key) -&gt;
				things[&#x27;plugin-&#x27;+key] = value.version or true

			# Apply
			trackRunner = docpad.getTrackRunner()
			trackRunner.addTask &#x27;track task&#x27;, (complete) -&gt;
				superAgent
					.post(config.helperUrl)
					.type(&#x27;json&#x27;).set(&#x27;Accept&#x27;, &#x27;application/json&#x27;)
					.query(
						method: &#x27;analytics&#x27;
						action: &#x27;track&#x27;
					)
					.send(data)
					.timeout(30*1000)
					.end docpad.checkRequest (err) -&gt;
						next?(err)
						complete(err)  # we pass the error here, as if we error, we want to stop all tracking

			# Execute the tracker tasks
			trackRunner.run()
		else
			next?()

		# Chain
		@

	###*
	# Identify DocPad user
	# @private
	# @method identify
	# @param {Function} next
	# @param {Error} next.err
	###
	identify: (next) -&gt;
		# Prepare
		docpad = @
		config = @getConfig()

		# Check
		if config.offline is false and config.reportStatistics and @userConfig?.username
			# Data
			data = {}
			data.userId = @userConfig.username  # required
			data.traits = things = {}

			# Things
			now = new Date()
			things.username = @userConfig.username  # required
			things.email = @userConfig.email or null
			things.name = @userConfig.name or null
			things.lastLogin = now.toISOString()
			things.lastSeen = now.toISOString()
			things.countryCode = safeps.getCountryCode()
			things.languageCode = safeps.getLanguageCode()
			things.platform = @getProcessPlatform()
			things.version = @getVersion()
			things.nodeVersion = @getProcessVersion()

			# Is this a new user?
			if docpad.userConfig.identified isnt true
				# Update
				things.created = now.toISOString()

				# Create the new user
				docpad.getTrackRunner().addTask &#x27;create new user&#x27;, (complete) -&gt;
					superAgent
						.post(config.helperUrl)
						.type(&#x27;json&#x27;).set(&#x27;Accept&#x27;, &#x27;application/json&#x27;)
						.query(
							method: &#x27;analytics&#x27;
							action: &#x27;identify&#x27;
						)
						.send(data)
						.timeout(30*1000)
						.end docpad.checkRequest (err) -&gt;
							# Save the changes with these
							docpad.updateUserConfig({identified:true}, complete)

			# Or an existing user?
			else
				# Update the existing user&#x27;s information witht he latest
				docpad.getTrackRunner().addTask &#x27;update user&#x27;, (complete) -&gt;
					superAgent
						.post(config.helperUrl)
						.type(&#x27;json&#x27;).set(&#x27;Accept&#x27;, &#x27;application/json&#x27;)
						.query(
							method: &#x27;analytics&#x27;
							action: &#x27;identify&#x27;
						)
						.send(data)
						.timeout(30*1000)
						.end docpad.checkRequest complete

		# Chain
		next?()
		@


	# =================================
	# Models and Collections

	# ---------------------------------
	# b/c compat functions

	###*
	# Create file model. Calls
	# {{#crossLink &quot;DocPad/createModel:method&quot;}}{{/crossLink}}
	# with the &#x27;file&#x27; modelType.
	# @method createFile
	# @param {Object} [attrs={}]
	# @param {Object} [opts={}]
	# @return {Object} FileModel
	###
	createFile: (attrs={},opts={}) -&gt;
		opts.modelType = &#x27;file&#x27;
		return @createModel(attrs, opts)

	###*
	# Create document model. Calls
	# {{#crossLink &quot;DocPad/createModel:method&quot;}}{{/crossLink}}
	# with the &#x27;document&#x27; modelType.
	# @method createDocument
	# @param {Object} [attrs={}]
	# @param {Object} [opts={}]
	# @return {Object} DocumentModel
	###
	createDocument: (attrs={},opts={}) -&gt;
		opts.modelType = &#x27;document&#x27;
		return @createModel(attrs, opts)


	###*
	# Parse the files directory and
	# return a files collection to
	# the passed callback
	# @method parseFileDirectory
	# @param {Object} [opts={}]
	# @param {Function} next callback
	# @param {Error} next.err
	# @param {Object} next.files files collection
	###
	parseFileDirectory: (opts={},next) -&gt;
		opts.modelType ?= &#x27;file&#x27;
		opts.collection ?= @getDatabase()
		return @parseDirectory(opts, next)

	###*
	# Parse the documents directory and
	# return a documents collection to
	# the passed callback.
	#
	# The partials plugin (https://github.com/docpad/docpad-plugin-partials)
	# uses this method to load a collection of
	# files from the partials directory.
	#
	# 	docpad.parseDocumentDirectory({path: config.partialsPath}, next)
	#
	# @method parseDocumentDirectory
	# @param {Object} [opts={}]
	# @param {String} [opts.modelType=&#x27;document&#x27;]
	# @param {Object} [opts.collection=docpad.database]
	# @param {Object} [opts.path]
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.files files collection of documents
	###
	parseDocumentDirectory: (opts={},next) -&gt;
		opts.modelType ?= &#x27;document&#x27;
		opts.collection ?= @getDatabase()
		return @parseDirectory(opts, next)


	# ---------------------------------
	# Standard functions


	###*
	# Attach events to a document model.
	# @private
	# @method attachModelEvents
	# @param {Object} model
	###
	attachModelEvents: (model) -&gt;
		# Prepare
		docpad = @

		# Only attach events if we haven&#x27;t already done so
		if model.attachedDocumentEvents isnt true
			model.attachedDocumentEvents = true

			# Attach document events
			if model.type is &#x27;document&#x27;
				# Clone
				model.on &#x27;clone&#x27;, (clonedModel) -&gt;
					docpad.attachModelEvents(clonedModel)

				# Render
				model.on &#x27;render&#x27;, (args...) -&gt;
					docpad.emitSerial(&#x27;render&#x27;, args...)

				# Render document
				model.on &#x27;renderDocument&#x27;, (args...) -&gt;
					docpad.emitSerial(&#x27;renderDocument&#x27;, args...)

				# Fetch a layout
				model.on &#x27;getLayout&#x27;, (opts={},next) -&gt;
					opts.collection = docpad.getCollection(&#x27;layouts&#x27;)
					layout = docpad.getFileBySelector(opts.selector, opts)
					next(null, {layout})

			# Remove
			#model.on &#x27;remove&#x27;, (file) -&gt;
			#	docpad.getDatabase().remove(file)
			# ^ Commented out as for some reason this stops layouts from working

			# Error
			model.on &#x27;error&#x27;, (args...) -&gt;
				docpad.error(args...)

			# Log
			model.on &#x27;log&#x27;, (args...) -&gt;
				if args.length is 2
					if args[0] in [&#x27;err&#x27;, &#x27;error&#x27;]
						docpad.error(args[1])
						return

					if args[0] in [&#x27;warn&#x27;, &#x27;warning&#x27;]
						docpad.warn(args[1])
						return

				docpad.log(args...)

		# Chain
		@

	###*
	# Add supplied model to the DocPad database. If the passed
	# model definition is a plain object of properties, a new
	# model will be created prior to adding to the database.
	# Calls {{#crossLink &quot;DocPad/createModel:method&quot;}}{{/crossLink}}
	# before adding the model to the database.
	#
	#	# Override the stat&#x27;s mtime to now
	#	# This is because renames will not update the mtime
	#	fileCurrentStat?.mtime = new Date()
	#
	#	# Create the file object
	#	file = docpad.addModel({fullPath:filePath, stat:fileCurrentStat})
	#
	# @method addModel
	# @param {Object} model either a plain object defining the required properties, in particular
	# the file path or an actual model object
	# @param {Object} opts
	# @return {Object} the model
	###
	addModel: (model, opts) -&gt;
		model = @createModel(model, opts)
		@getDatabase().add(model)
		return model

	###*
	# Add the supplied collection of models to the DocPad database.
	# Calls {{#crossLink &quot;DocPad/createModels:method&quot;}}{{/crossLink}}
	# before adding the models to the database.
	#
	# 	databaseData = JSON.parse data.toString()
	#	models = docpad.addModels(databaseData.models)
	#
	# @method addModels
	# @param {Object} models DocPad collection of models
	# @param {Object} opts
	# @return {Object} the models
	###
	addModels: (models, opts) -&gt;
		models = @createModels(models, opts)
		@getDatabase().add(models)
		return models

	###*
	# Create a collection of models from the supplied collection
	# ensuring that the collection is suitable for adding to the
	# DocPad database. The method calls {{#crossLink &quot;DocPad/createModel&quot;}}{{/crossLink}}
	# for each model in the models array.
	# @private
	# @method createModels
	# @param {Object} models DocPad collection of models
	# @param {Object} opts
	# @return {Object} the models
	###
	createModels: (models, opts) -&gt;
		for model in models
			@createModel(model, opts)
		# return the for loop results

	###*
	# Creates either a file or document model.
	# The model type to be created can be passed
	# as an opts property, if not, the method will
	# attempt to determing the model type by checking
	# if the file is in one of the documents or
	# layout paths.
	#
	# Ensures a duplicate model is not created
	# and all required attributes are present and
	# events attached.
	#
	# Generally it is not necessary for an application
	# to manually create a model via creatModel as DocPad
	# will handle this process when watching a project&#x27;s
	# file and document directories. However, it is possible
	# that a plugin might have a requirement to do so.
	#
	# 	model = @docpad.createModel({fullPath:fullPath})
    #   model.load()
    #   @docpad.getDatabase().add(model)
	#
	# @method createModel
	# @param {Object} [attrs={}]
	# @param {String} attrs.fullPath the full path to the file
	# @param {Object} [opts={}]
	# @param {String} opts.modelType either &#x27;file&#x27; or &#x27;document&#x27;
	# @return {Object} the file or document model
	###
	createModel: (attrs={},opts={}) -&gt;
		# Check
		if attrs instanceof FileModel
			return attrs

		# Prepare
		docpad = @
		config = @getConfig()
		database = @getDatabase()
		fileFullPath = attrs.fullPath or null


		# Find or create
		# This functionality use to be inside ensureModel
		# But that caused duplicates in some instances
		# So now we will always check
		if attrs.fullPath
			result = database.findOne(fullPath: attrs.fullPath)
			if result
				return result


		# -----------------------------
		# Try and determine the model type

		# If the type hasn&#x27;t been specified try and detemrine it based on the full path
		if fileFullPath
			# Check if we have a document or layout
			unless opts.modelType
				for dirPath in config.documentsPaths.concat(config.layoutsPaths)
					if fileFullPath.indexOf(dirPath) is 0
						attrs.relativePath or= fileFullPath.replace(dirPath, &#x27;&#x27;).replace(/^[\/\\]/,&#x27;&#x27;)
						opts.modelType = &#x27;document&#x27;
						break

			# Check if we have a file
			unless opts.modelType
				for dirPath in config.filesPaths
					if fileFullPath.indexOf(dirPath) is 0
						attrs.relativePath or= fileFullPath.replace(dirPath, &#x27;&#x27;).replace(/^[\/\\]/,&#x27;&#x27;)
						opts.modelType = &#x27;file&#x27;
						break

		# -----------------------------
		# Create the appropriate emodel

		# Extend the opts with things we need
		opts = extendr.extend({
			detectEncoding: config.detectEncoding
			rootOutDirPath: config.outPath
			locale: @getLocale()
			TaskGroup: @TaskGroup
		}, opts)

		if opts.modelType is &#x27;file&#x27;
			# Create a file model
			model = new FileModel(attrs, opts)
		else
			# Create document model
			model = new DocumentModel(attrs, opts)

		# -----------------------------
		# Finish up

		# Attach Events
		@attachModelEvents(model)

		# Return
		return model

	###*
	# Parse a directory and return a
	# files collection
	# @method parseDirectory
	# @param {Object} [opts={}]
	# @param {Object} next
	# @param {Error} next.err
	# @param {Object} next.files files collection
	###
	parseDirectory: (opts={},next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		locale = @getLocale()

		# Extract
		{path,createFunction} = opts
		createFunction ?= @createModel
		files = opts.collection or new FilesCollection()

		# Check if the directory exists
		safefs.exists path, (exists) -&gt;
			# Check
			unless exists
				# Log
				docpad.log &#x27;debug&#x27;, util.format(locale.renderDirectoryNonexistant, path)

				# Forward
				return next()

			# Log
			docpad.log &#x27;debug&#x27;, util.format(locale.renderDirectoryParsing, path)

			# Files
			docpad.scandir(
				# Path
				path: path

				# File Action
				fileAction: (fileFullPath,fileRelativePath,nextFile,fileStat) -&gt;
					# Prepare
					data =
						fullPath: fileFullPath
						relativePath: fileRelativePath
						stat: fileStat

					# Create file
					file = createFunction.call(docpad, data, opts)

					# Update the file&#x27;s stat
					# To ensure changes files are handled correctly in generation
					file.action &#x27;load&#x27;, (err) -&gt;
						# Error?
						return nextFile(err)  if err

						# Add the file to the collection
						files.add(file)

						# Next
						nextFile()

				# Next
				next: (err) -&gt;
					# Check
					return next(err)  if err

					# Log
					docpad.log &#x27;debug&#x27;, util.format(locale.renderDirectoryParsed, path)

					# Forward
					return next(null, files)
			)

		# Chain
		@


	# =================================
	# Plugins

	###*
	# Get a plugin by it&#x27;s name
	# @method getPlugin
	# @param {Object} pluginName
	# @return {Object} a DocPad plugin
	###
	getPlugin: (pluginName) -&gt;
		@loadedPlugins[pluginName]


	###*
	# Check if we have any plugins
	# @method hasPlugins
	# @return {Boolean}
	###
	hasPlugins: -&gt;
		return typeChecker.isEmptyObject(@loadedPlugins) is false

	###*
	# Destructor. Destroy plugins
	# @private
	# @method destroyPlugins
	###
	destroyPlugins: -&gt;
		for own name,plugin of @loadedPlugins
			plugin.destroy()
			@loadedPlugins[name] = null
		@

	###*
	# Load plugins from the file system
	# next(err)
	# @private
	# @method loadPlugins
	# @param {Function} next
	# @param {Error} next.err
	###
	loadPlugins: (next) -&gt;
		# Prepare
		docpad = @
		locale = @getLocale()

		# Snore
		@slowPlugins = {}
		snore = balUtil.createSnore -&gt;
			docpad.log &#x27;notice&#x27;, util.format(locale.pluginsSlow, Object.keys(docpad.slowPlugins).join(&#x27;, &#x27;))

		# Async
		tasks = new @TaskGroup &quot;loadPlugins tasks&quot;, concurrency:0, next:(err) -&gt;
			docpad.slowPlugins = {}
			snore.clear()
			return next(err)

		# Load website plugins
		(@config.pluginsPaths or []).forEach (pluginsPath) -&gt;
			tasks.addTask &quot;load the website&#x27;s plugins at: #{pluginsPath}&quot;, (complete) -&gt;
				safefs.exists pluginsPath, (exists) -&gt;
					return complete()  unless exists
					docpad.loadPluginsIn(pluginsPath, complete)

		# Load specific plugins
		(@config.pluginPaths or []).forEach (pluginPath) -&gt;
			tasks.addTask &quot;load custom plugins at: #{pluginPath}&quot;, (complete) -&gt;
				safefs.exists pluginPath, (exists) -&gt;
					return complete()  unless exists
					docpad.loadPlugin(pluginPath, complete)

		# Execute the loading asynchronously
		tasks.run()

		# Chain
		@

	###*
	# Checks if a plugin was loaded succesfully.
	# @method loadedPlugin
	# @param {String} pluginName
	# @param {Function} next
	# @param {Error} next.err
	# @param {Boolean} next.loaded
	###
	loadedPlugin: (pluginName,next) -&gt;
		# Prepare
		docpad = @

		# Check
		loaded = docpad.loadedPlugins[pluginName]?
		next(null,loaded)

		# Chain
		@

	###*
	# Load a plugin from its full file path
	# _next(err)
	# @private
	# @method loadPlugin
	# @param {String} fileFullPath
	# @param {Function} _next
	# @param {Error} _next.err
	# @return {Object} description
	###
	loadPlugin: (fileFullPath,_next) -&gt;
		# Prepare
		docpad = @
		config = @getConfig()
		locale = @getLocale()
		next = (err) -&gt;
			# Remove from slow plugins
			delete docpad.slowPlugins[pluginName]
			# Forward
			return _next(err)

		# Prepare variables
		loader = new PluginLoader(
			dirPath: fileFullPath
			docpad: @
			BasePlugin: BasePlugin
		)
		pluginName = loader.pluginName
		enabled = (
			(config.enableUnlistedPlugins  and  config.enabledPlugins[pluginName]? is false)  or
			config.enabledPlugins[pluginName] is true
		)

		# If we&#x27;ve already been loaded, then exit early as there is no use for us to load again
		if docpad.loadedPlugins[pluginName]?
			# However we probably want to reload the configuration as perhaps the user or environment configuration has changed
			docpad.loadedPlugins[pluginName].setConfig()
			# Complete
			return _next()

		# Add to loading stores
		docpad.slowPlugins[pluginName] = true

		# Check
		unless enabled
			# Skip
			docpad.log &#x27;debug&#x27;, util.format(locale.pluginSkipped, pluginName)
			return next()
		else
			# Load
			docpad.log &#x27;debug&#x27;, util.format(locale.pluginLoading, pluginName)

			# Check existance
			loader.exists (err,exists) -&gt;
				# Error or doesn&#x27;t exist?
				return next(err)  if err or not exists

				# Check support
				loader.unsupported (err,unsupported) -&gt;
					# Error?
					return next(err)  if err

					# Unsupported?
					if unsupported
						# Version?
						if unsupported in [&#x27;version-docpad&#x27;,&#x27;version-plugin&#x27;] and config.skipUnsupportedPlugins is false
							docpad.log &#x27;warn&#x27;, util.format(locale.pluginContinued, pluginName)
						else
							# Type?
							if unsupported is &#x27;type&#x27;
								docpad.log &#x27;debug&#x27;, util.format(locale.pluginSkippedDueTo, pluginName, unsupported)

							# Something else?
							else
								docpad.log &#x27;warn&#x27;, util.format(locale.pluginSkippedDueTo, pluginName, unsupported)
							return next()

					# Load the class
					loader.load (err) -&gt;
						return next(err)  if err

						# Create an instance
						loader.create {}, (err,pluginInstance) -&gt;
							return next(err)  if err

							# Add to plugin stores
							docpad.loadedPlugins[loader.pluginName] = pluginInstance

							# Log completion
							docpad.log &#x27;debug&#x27;, util.format(locale.pluginLoaded, pluginName)

							# Forward
							return next()

		# Chain
		@

	###*
	# Load plugins from a directory path
	# @private
	# @method loadPluginsIn
	# @param {String} pluginsPath
	# @param {Function} next
	# @param {Error} next.err
	###
	loadPluginsIn: (pluginsPath, next) -&gt;
		# Prepare
		docpad = @
		locale = @getLocale()

		# Load Plugins
		docpad.log &#x27;debug&#x27;, util.format(locale.pluginsLoadingFor, pluginsPath)
		@scandir(
			# Path
			path: pluginsPath

			# Skip files
			fileAction: false

			# Handle directories
			dirAction: (fileFullPath,fileRelativePath,nextFile) -&gt;
				# Prepare
				pluginName = pathUtil.basename(fileFullPath)

				# Delve deeper into the directory if it is a direcotry of plugins
				return nextFile(null, false)  if fileFullPath is pluginsPath

				# Otherwise, it is a plugin directory, so load the plugin
				docpad.loadPlugin fileFullPath, (err) -&gt;
					# Warn about the plugin load error if there is one
					if err
						docpad.warn util.format(locale.pluginFailedToLoad, pluginName, fileFullPath), err

					# All done and don&#x27;t recurse into this directory
					return nextFile(null, true)

			# Next
			next: (err) -&gt;
				docpad.log &#x27;debug&#x27;, util.format(locale.pluginsLoadedFor, pluginsPath)
				return next(err)
		)

		# Chain
		@


	# =================================
	# Utilities

	# ---------------------------------
	# Utilities: Misc

	###*
	# Compare current DocPad version to the latest
	# and print out the result to the console.
	# Used at startup.
	# @private
	# @method compareVersion
	###
	compareVersion: -&gt;
		# Prepare
		docpad = @
		config = @getConfig()
		locale = @getLocale()

		# Check
		return @  if config.offline or !config.checkVersion

		# Check
		balUtil.packageCompare(
			local: @packagePath
			remote: config.helperUrl+&#x27;latest&#x27;
			newVersionCallback: (details) -&gt;
				isLocalInstallation = docpadUtil.isLocalDocPadExecutable()
				message = (if isLocalInstallation then locale.versionOutdatedLocal else locale.versionOutdatedGlobal)
				currentVersion = &#x27;v&#x27;+details.local.version
				latestVersion = &#x27;v&#x27;+details.remote.version
				upgradeUrl = details.local.upgradeUrl or details.remote.installUrl or details.remote.homepage
				messageFilled = util.format(message, currentVersion, latestVersion, upgradeUrl)
				docpad.notify(latestVersion, title:locale.versionOutdatedNotification)
				docpad.log(&#x27;notice&#x27;, messageFilled)
		)

		# Chain
		@


	# ---------------------------------
	# Utilities: Exchange


	###*
	# Get DocPad&#x27;s exchange data
	# Requires internet access
	# next(err,exchange)
	# @private
	# @method getExchange
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.exchange docpad.exchange
	###
	getExchange: (next) -&gt;
		# Prepare
		docpad = @
		config = @getConfig()
		locale = @getLocale()

		# Check if it is stored locally
		return next(null, docpad.exchange)  if typeChecker.isEmptyObject(docpad.exchange) is false

		# Offline?
		return next(null, null)  if config.offline

		# Log
		docpad.log(&#x27;info&#x27;, locale.exchangeUpdate+&#x27; &#x27;+locale.pleaseWait)

		# Otherwise fetch it from the exchangeUrl
		exchangeUrl = config.helperUrl+&#x27;?method=exchange&amp;version=&#x27;+@version
		docpad.loadConfigUrl exchangeUrl, (err,parsedData) -&gt;
			# Check
			if err
				locale = docpad.getLocale()
				docpad.warn(locale.exchangeError, err)
				return next()

			# Log
			docpad.log(&#x27;info&#x27;, locale.exchangeUpdated)

			# Success
			docpad.exchange = parsedData
			return next(null, parsedData)

		# Chain
		@


	# ---------------------------------
	# Utilities: Files

	###*
	# Contextualize files.
	# Contextualizing is the process of adding layouts and
	# awareness of other documents to our document. The
	# contextualizeBefore and contextualizeAfter events
	# are emitted here.
	# @private
	# @method contextualizeFiles
	# @param {Object} [opts={}]
	# @param {Function} next
	# @param {Error} next.err
	###
	contextualizeFiles: (opts={},next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		{collection,templateData} = opts
		docpad = @
		config = @getConfig()
		locale = @getLocale()
		slowFilesObject = {}
		slowFilesTimer = null

		# Update progress
		opts.progress?.step(&quot;contextualizeFiles (preparing)&quot;).total(1).setTick(0)

		# Log
		docpad.log &#x27;debug&#x27;, util.format(locale.contextualizingFiles, collection.length)

		# Start contextualizing
		docpad.emitSerial &#x27;contextualizeBefore&#x27;, {collection,templateData}, (err) -&gt;
			# Prepare
			return next(err)  if err

			# Completion callback
			tasks = new docpad.TaskGroup &quot;contextualizeFiles tasks&quot;, concurrency:0, next:(err) -&gt;
				# Kill the timer
				clearInterval(slowFilesTimer)
				slowFilesTimer = null

				# Check
				return next(err)  if err

				# Update progress
				opts.progress?.step(&quot;contextualizeFiles (postparing)&quot;).total(1).setTick(0)

				# After
				docpad.emitSerial &#x27;contextualizeAfter&#x27;, {collection}, (err) -&gt;
					# Check
					return next(err)  if err

					# Log
					docpad.log &#x27;debug&#x27;, util.format(locale.contextualizedFiles, collection.length)

					# Forward
					return next()

			# Add contextualize tasks
			opts.progress?.step(&#x27;contextualizeFiles&#x27;).total(collection.length).setTick(0)
			collection.forEach (file,index) -&gt;
				filePath = file.getFilePath()
				slowFilesObject[file.id] = file.get(&#x27;relativePath&#x27;) or file.id
				tasks.addTask &quot;conextualizing: #{filePath}&quot;, (complete) -&gt;
					file.action &#x27;contextualize&#x27;, (err) -&gt;
						delete slowFilesObject[file.id]
						opts.progress?.tick()
						return complete(err)

			# Setup the timer
			slowFilesTimer = setInterval(
				-&gt;
					slowFilesArray = (value or key  for own key,value of slowFilesObject)
					docpad.log(&#x27;info&#x27;, util.format(locale.slowFiles, &#x27;contextualizeFiles&#x27;)+&#x27; \n&#x27;+slowFilesArray.join(&#x27;\n&#x27;))
				config.slowFilesDelay
			)

			# Run tasks
			tasks.run()

		# Chain
		@

	###*
	# Render the DocPad project&#x27;s files.
	# The renderCollectionBefore, renderCollectionAfter,
	# renderBefore, renderAfter events are all emitted here.
	# @private
	# @method renderFiles
	# @param {Object} [opts={}]
	# @param {Function} next
	# @param {Error} next.err
	###
	renderFiles: (opts={},next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		{collection,templateData,renderPasses} = opts
		docpad = @
		config = @getConfig()
		locale = @getLocale()
		slowFilesObject = {}
		slowFilesTimer = null

		# Update progress
		opts.progress?.step(&quot;renderFiles (preparing)&quot;).total(1).setTick(0)

		# Log
		docpad.log &#x27;debug&#x27;, util.format(locale.renderingFiles, collection.length)

		# Render File
		# next(null, outContent, file)
		renderFile = (file,next) -&gt;
			# Render
			if file.get(&#x27;render&#x27;) is false or !file.get(&#x27;relativePath&#x27;)
				file.attributes.rtime = new Date()
				next(null, file.getOutContent(), file)
			else
				file.action(&#x27;render&#x27;, {templateData}, next)

			# Return
			return file

		# Render Collection
		renderCollection = (collectionToRender,{renderPass},next) -&gt;
			# Plugin Event
			docpad.emitSerial &#x27;renderCollectionBefore&#x27;, {collection:collectionToRender,renderPass}, (err) -&gt;
				# Prepare
				return next(err)  if err

				subTasks = new docpad.TaskGroup &quot;renderCollection: #{collectionToRender.options.name}&quot;, concurrency:0, next:(err) -&gt;
					# Prepare
					return next(err)  if err

					# Plugin Event
					docpad.emitSerial(&#x27;renderCollectionAfter&#x27;, {collection:collectionToRender,renderPass}, next)

				# Cycle
				opts.progress?.step(&quot;renderFiles (pass #{renderPass})&quot;).total(collectionToRender.length).setTick(0)
				collectionToRender.forEach (file) -&gt;
					filePath = file.getFilePath()
					slowFilesObject[file.id] = file.get(&#x27;relativePath&#x27;)
					subTasks.addTask &quot;rendering: #{filePath}&quot;, (complete) -&gt;
						renderFile file, (err) -&gt;
							delete slowFilesObject[file.id] or file.id
							opts.progress?.tick()
							return complete(err)

				# Return
				subTasks.run()
				return collectionToRender

		# Plugin Event
		docpad.emitSerial &#x27;renderBefore&#x27;, {collection,templateData}, (err) -&gt;
			# Prepare
			return next(err)  if err

			# Async
			tasks = new docpad.TaskGroup &quot;renderCollection: renderBefore tasks&quot;, next:(err) -&gt;
				# Kill the timer
				clearInterval(slowFilesTimer)
				slowFilesTimer = null

				# Check
				return next(err)  if err

				# Update progress
				opts.progress?.step(&quot;renderFiles (postparing)&quot;).total(1).setTick(0)

				# After
				docpad.emitSerial &#x27;renderAfter&#x27;, {collection}, (err) -&gt;
					# Check
					return next(err)  if err

					# Log
					docpad.log &#x27;debug&#x27;, util.format(locale.renderedFiles, collection.length)

					# Forward
					return next()

			# Queue the initial render
			initialCollection = collection.findAll(&#x27;referencesOthers&#x27;:false)
			subsequentCollection = null
			tasks.addTask &quot;rendering the initial collection&quot;, (complete) -&gt;
				renderCollection initialCollection, {renderPass:1}, (err) -&gt;
					return complete(err)  if err
					subsequentCollection = collection.findAll(&#x27;referencesOthers&#x27;:true)
					renderCollection(subsequentCollection, {renderPass:2}, complete)

			# Queue the subsequent renders
			if renderPasses &gt; 1
				[3..renderPasses].forEach (renderPass) -&gt;  tasks.addTask &quot;rendering the subsequent collection index #{renderPass}&quot;, (complete) -&gt;
					renderCollection(subsequentCollection, {renderPass}, complete)

			# Setup the timer
			slowFilesTimer = setInterval(
				-&gt;
					slowFilesArray = (value or key  for own key,value of slowFilesObject)
					docpad.log(&#x27;info&#x27;, util.format(locale.slowFiles, &#x27;renderFiles&#x27;)+&#x27; \n&#x27;+slowFilesArray.join(&#x27;\n&#x27;))
				config.slowFilesDelay
			)

			# Run tasks
			tasks.run()

		# Chain
		@

	###*
	# Write rendered files to the DocPad out directory.
	# The writeBefore and writeAfter events are emitted here.
	# @private
	# @method writeFiles
	# @param {Object} [opts={}]
	# @param {Function} next
	# @param {Error} next.err
	###
	writeFiles: (opts={},next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		{collection,templateData} = opts
		docpad = @
		config = @getConfig()
		locale = @getLocale()
		slowFilesObject = {}
		slowFilesTimer = null

		# Update progress
		opts.progress?.step(&quot;writeFiles (preparing)&quot;).total(1).setTick(0)

		# Log
		docpad.log &#x27;debug&#x27;, util.format(locale.writingFiles, collection.length)

		# Plugin Event
		docpad.emitSerial &#x27;writeBefore&#x27;, {collection,templateData}, (err) -&gt;
			# Prepare
			return next(err)  if err

			# Completion callback
			tasks = new docpad.TaskGroup &quot;writeFiles tasks&quot;, concurrency:0, next:(err) -&gt;
				# Kill the timer
				clearInterval(slowFilesTimer)
				slowFilesTimer = null

				# Check
				return next(err)  if err

				# Update progress
				opts.progress?.step(&quot;writeFiles (postparing)&quot;).total(1).setTick(0)

				# After
				docpad.emitSerial &#x27;writeAfter&#x27;, {collection}, (err) -&gt;
					# Check
					return next(err)  if err

					# docpad.log &#x27;debug&#x27;, util.format(locale.wroteFiles, collection.length)
					return next()

			# Add write tasks
			opts.progress?.step(&#x27;writeFiles&#x27;).total(collection.length).setTick(0)
			collection.forEach (file,index) -&gt;
				filePath = file.getFilePath()
				tasks.addTask &quot;writing the file: #{filePath}&quot;, (complete) -&gt;
					# Prepare
					slowFilesObject[file.id] = file.get(&#x27;relativePath&#x27;)

					# Create sub tasks
					fileTasks = new docpad.TaskGroup &quot;tasks for file write: #{filePath}&quot;, concurrency:0, next:(err) -&gt;
						delete slowFilesObject[file.id]
						opts.progress?.tick()
						return complete(err)

					# Write out
					if file.get(&#x27;write&#x27;) isnt false and file.get(&#x27;dynamic&#x27;) isnt true and file.get(&#x27;outPath&#x27;)
						fileTasks.addTask &quot;write out&quot;, (complete) -&gt;
							file.action(&#x27;write&#x27;, complete)

					# Write source
					if file.get(&#x27;writeSource&#x27;) is true and file.get(&#x27;fullPath&#x27;)
						fileTasks.addTask &quot;write source&quot;, (complete) -&gt;
							file.action(&#x27;writeSource&#x27;, complete)

					# Run sub tasks
					fileTasks.run()

			# Setup the timer
			slowFilesTimer = setInterval(
				-&gt;
					slowFilesArray = (value or key  for own key,value of slowFilesObject)
					docpad.log(&#x27;info&#x27;, util.format(locale.slowFiles, &#x27;writeFiles&#x27;)+&#x27; \n&#x27;+slowFilesArray.join(&#x27;\n&#x27;))
				config.slowFilesDelay
			)

			# Run tasks
			tasks.run()

		# Chain
		@


	# ---------------------------------
	# Generate

	# Generate Helpers
	###*
	# Has DocPad&#x27;s generation process started?
	# @private
	# @property {Boolean} generateStarted
	###
	generateStarted: null

	###*
	# Has DocPad&#x27;s generation process ended?
	# @private
	# @property {Boolean} generateEnded
	###
	generateEnded: null

	###*
	# Is DocPad currently generating?
	# @private
	# @property {Boolean} generating
	###
	generating: false

	###*
	# Has DocPad done at least one generation?
	# True once the first generation has occured.
	# @private
	# @property {Object} generated
	###
	generated: false

	###*
	# Create the console progress bar.
	# Progress only shown if the DocPad config &#x27;progress&#x27;
	# option is true, the DocPad config &#x27;prompts&#x27; option is true
	# and the log level is 6 (default)
	# @private
	# @method createProgress
	# @return {Object} the progress object
	###
	createProgress: -&gt;
		# Prepare
		docpad = @
		config = docpad.getConfig()

		# Only show progress if
		# - progress is true
		# - prompts are supported (so no servers)
		# - and we are log level 6 (the default level)
		progress = null
		if config.progress and config.prompts and @getLogLevel() is 6
			progress = require(&#x27;progressbar&#x27;).create()
			@getLoggers().console.unpipe(process.stdout)
			@getLogger().once &#x27;log&#x27;, progress.logListener ?= (data) -&gt;
				if data.levelNumber &lt;= 5  # notice or higher
					docpad.destroyProgress(progress)

		# Return
		return progress

	###*
	# Destructor. Destroy the progress object
	# @private
	# @method destroyProgress
	# @param {Object} progress
	# @return {Object} the progress object
	###
	destroyProgress: (progress) -&gt;
		# Fetch
		if progress
			progress.finish()
			@getLoggers().console.unpipe(process.stdout).pipe(process.stdout)

		# Return
		return progress

	###*
	# Destructor. Destroy the regeneration timer.
	# @private
	# @method destroyRegenerateTimer
	###
	destroyRegenerateTimer: -&gt;
		# Prepare
		docpad = @

		# Clear Regenerate Timer
		if docpad.regenerateTimer
			clearTimeout(docpad.regenerateTimer)
			docpad.regenerateTimer = null

		# Chain
		@

	###*
	# Create the regeneration timer
	# @private
	# @method createRegenerateTimer
	###
	createRegenerateTimer: -&gt;
		# Prepare
		docpad = @
		locale = docpad.getLocale()
		config = docpad.getConfig()

		# Create Regenerate Timer
		if config.regenerateEvery
			docpad.regenerateTimer = setTimeout(
				-&gt;
					docpad.log(&#x27;info&#x27;, locale.renderInterval)
					docpad.action(&#x27;generate&#x27;, config.regenerateEveryOptions)
				config.regenerateEvery
			)

		# Chain
		@

	###*
	# Set off DocPad&#x27;s generation process.
	# The generated, populateCollectionsBefore, populateCollections, populateCollections
	# generateBefore and generateAfter events are emitted here
	# @method generate
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	generate: (opts, next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = docpad.getConfig()
		locale = docpad.getLocale()
		database = docpad.getDatabase()

		# Check
		return next()  if opts.collection?.length is 0


		# Update generating flag
		lastGenerateStarted = docpad.generateStarted
		docpad.generateStarted = new Date()
		docpad.generateEnded = null
		docpad.generating = true

		# Update the cached database
		docpad.databaseTempCache = new FilesCollection(database.models)  if database.models.length

		# Create Progress
		# Can be over-written by API calls
		opts.progress ?= docpad.createProgress()

		# Grab the template data we will use for rendering
		opts.templateData = docpad.getTemplateData(opts.templateData or {})

		# How many render passes will we require?
		# Can be over-written by API calls
		opts.renderPasses or= config.renderPasses


		# Destroy Regenerate Timer
		docpad.destroyRegenerateTimer()

		# Check plugin count
		docpad.log(&#x27;notice&#x27;, locale.renderNoPlugins)  unless docpad.hasPlugins()

		# Log
		docpad.log(&#x27;info&#x27;, locale.renderGenerating)
		docpad.notify (new Date()).toLocaleTimeString(), {title: locale.renderGeneratingNotification}

		# Tasks
		tasks = new @TaskGroup(&quot;generate tasks&quot;, {progress: opts.progress}).done (err) -&gt;
			# Update generating flag
			docpad.generating = false
			docpad.generateEnded = new Date()

			# Update caches
			docpad.databaseTempCache = null

			# Create Regenerate Timer
			docpad.createRegenerateTimer()

			# Clear Progress
			if opts.progress
				docpad.destroyProgress(opts.progress)
				opts.progress = null

			# Error?
			return next(err)  if err

			# Log success message
			seconds = (docpad.generateEnded - docpad.generateStarted) / 1000
			howMany = &quot;#{opts.collection?.length or 0}/#{database.length}&quot;
			docpad.log &#x27;info&#x27;, util.format(locale.renderGenerated, howMany, seconds)
			docpad.notify (new Date()).toLocaleTimeString(), {title: locale.renderGeneratedNotification}

			# Generated
			if opts.initial is true
				docpad.generated = true
				return docpad.emitSerial(&#x27;generated&#x27;, opts, next)

			# Safety check if generated is false but initial was false too
			# https://github.com/bevry/docpad/issues/811
			else if docpad.generated is false
				return next(
					new Error(&#x27;DocPad is in an invalid state, please report this on the github issue tracker. Reference 3360&#x27;)
				)

			else
				return next()

		# Extract functions from tasks for simplicity
		# when dealing with nested tasks/groups
		addGroup = tasks.addGroup.bind(tasks)
		addTask = tasks.addTask.bind(tasks)


		# Setup a clean database
		addTask &#x27;Reset our collections&#x27;, (complete) -&gt;
			# Skip if we are not a reset generation, or an initial generation (generated is false)
			return complete()  unless opts.reset is true or docpad.generated is false
			return docpad.resetCollections(opts, complete)


		# Figure out the options
		# This is here as resetCollections could change our state
		# https://github.com/bevry/docpad/issues/811
		addTask &#x27;Figure out options&#x27;, -&gt;
			# Mode: Cache
			# Shall we write to the database cache?
			# Set to true if the configuration option says we can, and we are the initial generation
			opts.cache     ?= config.databaseCache

			# Mode: Initial
			# Shall we do some basic initial checks
			# Set to the opts.reset value if specified, or whether are the initial generation
			opts.initial   ?= !(docpad.generated)

			# Mode: Reset
			# Shall we reset the database
			# Set to true if we are the initial generation
			opts.reset     ?= opts.initial

			# Mode: Populate
			# Shall we fetch in new data?
			# Set to the opts.reset value if specified, or the opts.initial value
			opts.populate  ?= opts.reset

			# Mode: Reload
			# Shall we rescan the file system for changes?
			# Set to the opts.reset value if specified, or the opts.initial value
			opts.reload    ?= opts.reset

			# Mode: Partial
			# Shall we perform a partial generation (false) or a completion generation (true)?
			# Set to false if we are the initial generation
			opts.partial   ?= !(opts.reset)

			# Log our opts
			docpad.log(
				&#x27;debug&#x27;
				&#x27;Generate options:&#x27;
				pick(opts, [&#x27;cache&#x27;, &#x27;initial&#x27;, &#x27;reset&#x27;, &#x27;populate&#x27;, &#x27;reload&#x27;, &#x27;partial&#x27;, &#x27;renderPasses&#x27;])
			)


		# Check directory structure
		addTask &#x27;check source directory exists&#x27;, (complete) -&gt;
			# Skip if we are not the initial generation
			return complete()  unless opts.initial is true

			# Continue if we are the initial generation
			safefs.exists config.srcPath, (exists) -&gt;
				# Check
				unless exists
					err = new Error(locale.renderNonexistant)
					return complete(err)

				# Forward
				return complete()


		addGroup &#x27;fetch data to render&#x27;, (addGroup, addTask) -&gt;
			# Fetch new data
			# If we are a populate generation (by default an initial generation)
			if opts.populate is true
				# This will pull in new data from plugins
				addTask &#x27;populateCollectionsBefore&#x27;, (complete) -&gt;
					docpad.emitSerial(&#x27;populateCollectionsBefore&#x27;, opts, complete)

				# Import the cached data
				# If we are the initial generation, and we have caching enabled
				if opts.initial is true and opts.cache in [true, &#x27;read&#x27;]
					addTask &#x27;import data from cache&#x27;, (complete) -&gt;
						# Check if we do have a databae cache
						safefs.exists config.databaseCachePath, (exists) -&gt;
							return complete()  if exists is false

							# Read the database cache if it exists
							safefs.readFile config.databaseCachePath, (err, data) -&gt;
								return complete(err)  if err

								# Parse it and apply the data values
								databaseData = JSON.parse data.toString()
								opts.cache     = true
								opts.initial   = true
								opts.reset     = false
								opts.populate  = true
								opts.reload    = true
								opts.partial   = true

								lastGenerateStarted = new Date(databaseData.generateStarted)
								addedModels = docpad.addModels(databaseData.models)
								docpad.log &#x27;info&#x27;, util.format(locale.databaseCacheRead, database.length, databaseData.models.length)

								# @TODO we need a way of detecting deleted files between generations

								return complete()

				# Rescan the file system
				# If we are a reload generation (by default an initial generation)
				# This is useful when the database is out of sync with the source files
				# For instance, someone shut down docpad, and made some changes, then ran docpad again
				# See https://github.com/bevry/docpad/issues/705#issuecomment-29243666 for details
				if opts.reload is true
					addGroup &#x27;import data from file system&#x27;, (addGroup, addTask) -&gt;
						# Documents
						config.documentsPaths.forEach (documentsPath) -&gt;
							addTask &#x27;import documents&#x27;, (complete) -&gt;
								docpad.parseDirectory({
									modelType: &#x27;document&#x27;
									collection: database
									path: documentsPath
									next: complete
								})

						# Files
						config.filesPaths.forEach (filesPath) -&gt;
							addTask &#x27;import files&#x27;, (complete) -&gt;
								docpad.parseDirectory({
									modelType: &#x27;file&#x27;
									collection: database
									path: filesPath
									next: complete
								})

						# Layouts
						config.layoutsPaths.forEach (layoutsPath) -&gt;
							addTask &#x27;import layouts&#x27;, (complete) -&gt;
								docpad.parseDirectory({
									modelType: &#x27;document&#x27;
									collection: database
									path: layoutsPath
									next: complete
								})

				# This will pull in new data from plugins
				addTask &#x27;populateCollections&#x27;, (complete) -&gt;
					docpad.emitSerial(&#x27;populateCollections&#x27;, opts, complete)


		addGroup &#x27;determine files to render&#x27;, (addGroup, addTask) -&gt;
			# Perform a complete regeneration
			# If we are a reset generation (by default an initial non-cached generation)
			if opts.partial is false
				# Use Entire Collection
				addTask &#x27;Add all database models to render queue&#x27;, -&gt;
					opts.collection ?= new FilesCollection().add(docpad.getCollection(&#x27;generate&#x27;).models)

			# Perform a partial regeneration
			# If we are not a reset generation (by default any non-initial generation)
			else
				# Use Partial Collection
				addTask &#x27;Add only changed models to render queue&#x27;, -&gt;
					changedQuery =
						$or:
							# Get changed files
							mtime: $gte: lastGenerateStarted

							# Get new files
							$and:
								wtime: null
								write: true
					opts.collection ?= new FilesCollection().add(docpad.getCollection(&#x27;generate&#x27;).findAll(changedQuery).models)


		addTask &#x27;generateBefore&#x27;, (complete) -&gt;
			# If we have nothing to generate
			if opts.collection.length is 0
				# then there is no need to execute further tasks
				tasks.clear()
				complete()

			# Otherwise continue down the task loop
			else
				docpad.emitSerial(&#x27;generateBefore&#x27;, opts, complete)


		addTask &#x27;prepare files&#x27;, (complete) -&gt;
			# Log the files to generate if we are in debug mode
			docpad.log &#x27;debug&#x27;, &#x27;Files to generate at&#x27;, (lastGenerateStarted), &#x27;\n&#x27;, (
				{
					id: model.id
					path: model.getFilePath()
					mtime: model.get(&#x27;mtime&#x27;)
					wtime: model.get(&#x27;wtime&#x27;)
					dynamic: model.get(&#x27;dynamic&#x27;)
					ignored: model.get(&#x27;ignored&#x27;)
					write: model.get(&#x27;write&#x27;)
				}  for model in opts.collection.models
			)

			# Add anything that references other documents (e.g. partials, listing, etc)
			# This could eventually be way better
			standalones = opts.collection.pluck(&#x27;standalone&#x27;)
			allStandalone = standalones.indexOf(false) is -1
			if allStandalone is false
				opts.collection.add(docpad.getCollection(&#x27;referencesOthers&#x27;).models)

			# Deeply/recursively add the layout children
			addLayoutChildren = (collection) -&gt;
				collection.forEach (file) -&gt;
					if file.get(&#x27;isLayout&#x27;) is true
						# Find
						layoutChildrenQuery =
							layoutRelativePath: file.get(&#x27;relativePath&#x27;)
						layoutChildrenCollection = docpad.getCollection(&#x27;hasLayout&#x27;).findAll(layoutChildrenQuery)

						# Log the files to generate if we are in debug mode
						docpad.log &#x27;debug&#x27;, &#x27;Layout children to generate at&#x27;, (lastGenerateStarted), &#x27;\n&#x27;, (
							{
								id: model.id
								path: model.getFilePath()
								mtime: model.get(&#x27;mtime&#x27;)
								wtime: model.get(&#x27;wtime&#x27;)
								write: model.get(&#x27;write&#x27;)
							}  for model in layoutChildrenCollection.models
						), &#x27;\n&#x27;, layoutChildrenQuery

						# Recurse
						addLayoutChildren(layoutChildrenCollection)

						# Add
						opts.collection.add(layoutChildrenCollection.models)
			addLayoutChildren(opts.collection)

			# Filter out ignored, and no-render no-write files
			opts.collection.reset opts.collection.reject (file) -&gt;
				return (file.get(&#x27;render&#x27;) is false and file.get(&#x27;write&#x27;) is false)

			# Log the files to generate if we are in debug mode
			docpad.log &#x27;debug&#x27;, &#x27;Files to generate at&#x27;, (lastGenerateStarted), &#x27;\n&#x27;, (
				{
					id: model.id
					path: model.getFilePath()
					mtime: model.get(&#x27;mtime&#x27;)
					wtime: model.get(&#x27;wtime&#x27;)
					dynamic: model.get(&#x27;dynamic&#x27;)
					ignored: model.get(&#x27;ignored&#x27;)
					write: model.get(&#x27;write&#x27;)
				}  for model in opts.collection.models
			)

			# Forward
			return complete()


		addGroup &#x27;process file&#x27;, (addGroup, addTask) -&gt;
			addTask &#x27;contextualizeFiles&#x27;, {args:[opts]}, docpad.contextualizeFiles.bind(docpad)
			addTask &#x27;renderFiles&#x27;, {args:[opts]}, docpad.renderFiles.bind(docpad)
			addTask &#x27;writeFiles&#x27;, {args:[opts]}, docpad.writeFiles.bind(docpad)


		addTask &#x27;generateAfter&#x27;, (complete) -&gt;
			docpad.emitSerial(&#x27;generateAfter&#x27;, opts, complete)


		# Write the cache file
		addTask &#x27;Write the database cache&#x27;, (complete) -&gt;
			# Skip if we do not care for writing the cache
			return complete()  unless opts.cache in [true, &#x27;write&#x27;]

			# Write the cache
			databaseData =
				generateStarted: docpad.generateStarted
				generateEnded: docpad.generateEnded
				models: (model.getAttributes()  for model in database.models)
			databaseDataDump = JSON.stringify(databaseData, null, &#x27;  &#x27;)
			docpad.log &#x27;info&#x27;, util.format(locale.databaseCacheWrite, databaseData.models.length)
			return safefs.writeFile(config.databaseCachePath, databaseDataDump, complete)


		# Run
		tasks.run()

		# Chain
		@


	# ---------------------------------
	# Render

	###*
	# Load a document
	# @private
	# @method loadDocument
	# @param {Object} document
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.document
	###
	loadDocument: (document,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)

		# Load
		# @TODO: don&#x27;t load if already loaded
		document.action(&#x27;load contextualize&#x27;, opts, next)

		# Chain
		@

	###*
	# Load and render a document
	# @method loadAndRenderDocument
	# @param {Object} document
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.document
	###
	loadAndRenderDocument: (document,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @

		# Load
		docpad.loadDocument document, opts, (err) -&gt;
			return next(err)  if err

			# Render
			docpad.renderDocument(document, opts, next)

		# Chain
		@

	###*
	# Render a document
	# @method renderDocument
	# @param {Object} document
	# @param {Object} opts
	# @param {Object} next
	# @param {Error} next.err
	# @param {Object} next.result
	# @param {Object} next.document
	###
	renderDocument: (document,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)

		# Render
		clone = document.clone().action &#x27;render&#x27;, opts, (err) -&gt;
			result = clone.getOutContent()
			return next(err, result, document)

		# Chain
		@

	###*
	# Render a document at a file path
	# next(err,result)
	# @method renderPath
	# @param {String} path
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.result the rendered document
	###
	renderPath: (path,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		attributes = extendr.extend({
			fullPath: path
		},opts.attributes)

		# Handle
		document = @createDocument(attributes)
		@loadAndRenderDocument(document, opts, next)

		# Chain
		@

	###*
	# Render the passed content data as a
	# document. Required option, filename
	# (opts.filename)
	# next(err,result)
	# @method renderData
	# @param {String} content
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.result the rendered document
	###
	renderData: (content,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		attributes = extendr.extend({
			filename: opts.filename
			data: content
		}, opts.attributes)

		# Handle
		document = @createDocument(attributes)
		@loadAndRenderDocument(document, opts, next)

		# Chain
		@

	# Render Text
	# Doesn&#x27;t extract meta information, or render layouts
	# TODO: Why not? Why not just have renderData?

	###*
	# Render the passed text data as a
	# document. Required option, filename
	# (opts.filename)
	# next(err,result)
	# @private
	# @method renderText
	# @param {String} text
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Object} next.result the rendered content
	# @param {Object} next.document the rendered document model
	###
	renderText: (text,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		opts.actions ?= [&#x27;renderExtensions&#x27;, &#x27;renderDocument&#x27;]
		attributes = extendr.extend({
			filename: opts.filename
			data: text
			body: text
			content: text
		}, opts.attributes)

		# Handle
		document = @createDocument(attributes)

		# Render
		clone = document.clone().action &#x27;normalize contextualize render&#x27;, opts, (err) -&gt;
			result = clone.getOutContent()
			return next(err, result, document)

		# Chain
		@

	###*
	# Render action
	# next(err,document,result)
	# @method render
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	render: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		locale = @getLocale()

		# Extract document
		if opts.document
			@renderDocument(opts.document, opts, next)
		else if opts.data
			@renderData(opts.data, opts, next)
		else if opts.text
			@renderText(opts.text, opts, next)
		else
			path = opts.path or opts.fullPath or opts.filename or null
			if path
				@renderPath(path, opts, next)
			else
				# Check
				err = new Error(locale.renderInvalidOptions)
				return next(err)

		# Chain
		@


	# ---------------------------------
	# Watch

	###*
	# Array of file watchers
	# @private
	# @property {Array} watchers
	###
	watchers: null

	###*
	# Destructor. Destroy the watchers used
	# by DocPad
	# @private
	# @method destroyWatchers
	###
	destroyWatchers: -&gt;
		# Prepare
		docpad = @

		# Check
		if docpad.watchers
			# Close each of them
			for watcher in docpad.watchers
				watcher.close()

			# Reset the array
			docpad.watchers = []

		# Chain
		@

	###*
	# Start up file watchers used by DocPad
	# @private
	# @method watch
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	watch: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = @getConfig()
		locale = @getLocale()
		database = @getDatabase()
		@watchers ?= []

		# Restart our watchers
		restartWatchers = (next) -&gt;
			# Close our watchers
			docpad.destroyWatchers()

			# Start a group
			tasks = new docpad.TaskGroup(&quot;watch tasks&quot;, {concurrency:0, next})

			# Watch reload paths
			reloadPaths = union(config.reloadPaths, config.configPaths)
			tasks.addTask &quot;watch reload paths&quot;, (complete) -&gt; docpad.watchdir(
				paths: reloadPaths
				listeners:
					&#x27;log&#x27;: docpad.log
					&#x27;error&#x27;: docpad.error
					&#x27;change&#x27;: -&gt;
						docpad.log &#x27;info&#x27;, util.format(locale.watchReloadChange, new Date().toLocaleTimeString())
						docpad.action &#x27;load&#x27;, (err) -&gt;
							return docpad.fatal(err)  if err
							performGenerate(reset:true)
				next: (err,_watchers) -&gt;
					if err
						docpad.warn(&quot;Watching the reload paths has failed:\n&quot;+docpad.inspector(reloadPaths), err)
						return complete()
					for watcher in _watchers
						docpad.watchers.push(watcher)
					return complete()
			)

			# Watch regenerate paths
			regeneratePaths = config.regeneratePaths
			tasks.addTask &quot;watch regenerate paths&quot;, (complete) -&gt; docpad.watchdir(
				paths: regeneratePaths
				listeners:
					&#x27;log&#x27;: docpad.log
					&#x27;error&#x27;: docpad.error
					&#x27;change&#x27;: -&gt; performGenerate(reset:true)
				next: (err,_watchers) -&gt;
					if err
						docpad.warn(&quot;Watching the regenerate paths has failed:\n&quot;+docpad.inspector(regeneratePaths), err)
						return complete()
					for watcher in _watchers
						docpad.watchers.push(watcher)
					return complete()
			)

			# Watch the source
			srcPath = config.srcPath
			tasks.addTask &quot;watch the source path&quot;, (complete) -&gt; docpad.watchdir(
				path: srcPath
				listeners:
					&#x27;log&#x27;: docpad.log
					&#x27;error&#x27;: docpad.error
					&#x27;change&#x27;: changeHandler
				next: (err,watcher) -&gt;
					if err
						docpad.warn(&quot;Watching the src path has failed: &quot;+srcPath, err)
						return complete()
					docpad.watchers.push(watcher)
					return complete()
			)

			# Run
			tasks.run()

			# Chain
			@

		# Timer
		regenerateTimer = null
		queueRegeneration = -&gt;
			# Reset the wait
			if regenerateTimer
				clearTimeout(regenerateTimer)
				regenerateTimer = null

			# Regenerat after a while
			regenerateTimer = setTimeout(performGenerate, config.regenerateDelay)

		performGenerate = (opts={}) -&gt;
			# Q: Should we also pass over the collection?
			# A: No, doing the mtime query in generate is more robust

			# Log
			docpad.log util.format(locale.watchRegenerating, new Date().toLocaleTimeString())

			# Afterwards, re-render anything that should always re-render
			docpad.action &#x27;generate&#x27;, opts, (err) -&gt;
				docpad.error(err)  if err
				docpad.log util.format(locale.watchRegenerated, new Date().toLocaleTimeString())

		# Change event handler
		changeHandler = (changeType,filePath,fileCurrentStat,filePreviousStat) -&gt;
			# Prepare
			fileEitherStat = (fileCurrentStat or filePreviousStat)

			# For some reason neither of the stats may exist, this will cause errors as this is an invalid state
			# as we depend on at least one stat existing, otherwise, what on earth is going on?
			# Whatever the case, this should be fixed within watchr, not docpad
			# as watchr should not be giving us invalid data
			# https://github.com/bevry/docpad/issues/792
			unless fileEitherStat
				err = new Error(&quot;&quot;&quot;
						DocPad has encountered an invalid state while detecting changes for your files.
						So the DocPad team can fix this right away, please provide any information you can to:
						https://github.com/bevry/docpad/issues/792
						&quot;&quot;&quot;)
				return docpad.error(err)

			# Log the change
			docpad.log &#x27;info&#x27;, util.format(locale.watchChange, new Date().toLocaleTimeString()), changeType, filePath

			# Check if we are a file we don&#x27;t care about
			# This check should not be needed with v2.3.3 of watchr
			# however we&#x27;ve still got it here as it may still be an issue
			isIgnored = docpad.isIgnoredPath(filePath)
			if isIgnored
				docpad.log &#x27;debug&#x27;, util.format(locale.watchIgnoredChange, new Date().toLocaleTimeString()), filePath
				return

			# Don&#x27;t care if we are a directory
			isDirectory = fileEitherStat.isDirectory()
			if isDirectory
				docpad.log &#x27;debug&#x27;, util.format(locale.watchDirectoryChange, new Date().toLocaleTimeString()), filePath
				return

			# Override the stat&#x27;s mtime to now
			# This is because renames will not update the mtime
			fileCurrentStat?.mtime = new Date()

			# Create the file object
			file = docpad.addModel({fullPath:filePath, stat:fileCurrentStat})
			file.setStat(fileCurrentStat)  if changeType is &#x27;update&#x27;

			# File was deleted, delete the rendered file, and remove it from the database
			if changeType is &#x27;delete&#x27;
				database.remove(file)
				file.action &#x27;delete&#x27;, (err) -&gt;
					return docpad.error(err)  if err
					queueRegeneration()

			# File is new or was changed, update it&#x27;s mtime by setting the stat
			else if changeType in [&#x27;create&#x27;, &#x27;update&#x27;]
				file.action &#x27;load&#x27;, (err) -&gt;
					return docpad.error(err)  if err
					queueRegeneration()

		# Watch
		docpad.log(locale.watchStart)
		restartWatchers (err) -&gt;
			return next(err)  if err
			docpad.log(locale.watchStarted)
			return next()

		# Chain
		@


	# ---------------------------------
	# Run Action

	###*
	# Run an action
	# @method run
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	run: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts, next)
		docpad = @
		locale = @getLocale()
		config = @getConfig()
		{srcPath, rootPath} = config

		# Prepare
		run = (complete) -&gt;
			balUtil.flow(
				object: docpad
				action: &#x27;server generate watch&#x27;
				args: [opts]
				next: complete
			)

		# Check if we have the docpad structure
		safefs.exists srcPath, (exists) -&gt;
			# Check if have the correct structure, if so let&#x27;s proceed with DocPad
			return run(next)  if exists

			# We don&#x27;t have the correct structure
			# Check if we are running on an empty directory
			safefs.readdir rootPath, (err,files) -&gt;
				return next(err)  if err

				# Check if our directory is empty
				if files.length
					# It isn&#x27;t empty, display a warning
					docpad.warn util.format(locale.skeletonNonexistant, rootPath)
					return next()
				else
					docpad.skeleton opts, (err) -&gt;
						# Check
						return next(err)  if err

						# Keep in global?
						return run(next)  if opts.global is true or docpad.getConfig().global is true

						# Log
						docpad.log(&#x27;notice&#x27;, locale.startLocal)

						# Destroy our DocPad instance so we can boot the local one
						docpad.destroy (err) -&gt;
							# Check
							return next(err)  if err

							# Forward onto the local DocPad Instance now that it has been installed
							return docpadUtil.startLocalDocPadExecutable(next)

		# Chain
		@


	# ---------------------------------
	# Skeleton

	###*
	# Initialize the skeleton install process.
	# @private
	# @method initInstall
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	initInstall: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = @getConfig()

		# Tasks
		tasks = new @TaskGroup(&quot;initInstall tasks&quot;, {concurrency:0, next})

		tasks.addTask &quot;node modules&quot;, (complete) -&gt;
			path = pathUtil.join(config.rootPath, &#x27;node_modules&#x27;)
			safefs.ensurePath(path, complete)

		tasks.addTask &quot;package&quot;, (complete) -&gt;
			# Exists?
			path = pathUtil.join(config.rootPath, &#x27;package.json&#x27;)
			safefs.exists path, (exists) -&gt;
				# Check
				return complete()  if exists

				# Write
				data = JSON.stringify({
					name: &#x27;no-skeleton.docpad&#x27;
					version: &#x27;0.1.0&#x27;
					description: &#x27;New DocPad project without using a skeleton&#x27;
					dependencies:
						docpad: &#x27;~&#x27;+docpad.getVersion()
					main: &#x27;node_modules/.bin/docpad-server&#x27;
					scripts:
						start: &#x27;node_modules/.bin/docpad-server&#x27;
				}, null, &#x27;  &#x27;)
				safefs.writeFile(path, data, complete)

		# Run
		tasks.run()

		# Chain
		@

	###*
	# Uninstall a plugin.
	# @private
	# @method uninstall
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	uninstall: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = @getConfig()

		# Tasks
		tasks = new @TaskGroup(&quot;uninstall tasks&quot;, {next})

		# Uninstall a plugin
		if opts.plugin
			tasks.addTask &quot;uninstall the plugin: #{opts.plugin}&quot;, (complete) -&gt;
				plugins =
					for plugin in opts.plugin.split(/[,\s]+/)
						plugin = &quot;docpad-plugin-#{plugin}&quot;  if plugin.indexOf(&#x27;docpad-plugin-&#x27;) isnt 0
						plugin
				docpad.uninstallNodeModule(plugins, {
					stdio: &#x27;inherit&#x27;
					next: complete
				})

		# Re-load configuration
		tasks.addTask &quot;re-load configuration&quot;, (complete) -&gt;
			docpad.load(complete)

		# Run
		tasks.run()

		# Chain
		@

	###*
	# Install a plugin
	# @private
	# @method install
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	install: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = @getConfig()

		# Tasks
		tasks = new @TaskGroup(&quot;install tasks&quot;, {next})

		tasks.addTask &quot;init the installation&quot;, (complete) -&gt;
			docpad.initInstall(opts, complete)

		# Install a plugin
		if opts.plugin
			tasks.addTask &quot;install the plugin: #{opts.plugin}&quot;, (complete) -&gt;
				plugins =
					for plugin in opts.plugin.split(/[,\s]+/)
						plugin = &quot;docpad-plugin-#{plugin}&quot;  if plugin.indexOf(&#x27;docpad-plugin-&#x27;) isnt 0
						plugin += &#x27;@&#x27;+docpad.pluginVersion  if plugin.indexOf(&#x27;@&#x27;) is -1
						plugin
				docpad.installNodeModule(plugins, {
					stdio: &#x27;inherit&#x27;
					next: complete
				})

		tasks.addTask &quot;re-initialize the website&#x27;s modules&quot;, (complete) -&gt;
			docpad.initNodeModules({
				stdio: &#x27;inherit&#x27;
				next: complete
			})

		tasks.addTask &quot;fix node package versions&quot;, (complete) -&gt;
			docpad.fixNodePackageVersions(complete)

		tasks.addTask &quot;re-load the configuration&quot;, (complete) -&gt;
			docpad.load(complete)

		# Run
		tasks.run()

		# Chain
		@

	###*
	# Update global NPM and DocPad
	# @private
	# @method upgrade
	# @param {Object} opts
	# @param {Object} next
	# @param {Error} next.err
	# @return {Object} description
	###
	upgrade: (opts,next) -&gt;
		# Update Global NPM and DocPad
		@installNodeModule(&#x27;npm docpad@6&#x27;, {
			global: true
			stdio: &#x27;inherit&#x27;
			next: next
		})

		# Chain
		@

	###*
	# Update the local DocPad and plugin dependencies
	# @private
	# @method update
	# @param {Object} opts
	# @param {Object} next
	# @param {Error} next.err
	###
	update: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = @getConfig()

		# Tasks
		tasks = new @TaskGroup(&quot;update tasks&quot;, {next})

		tasks.addTask &quot;init the install&quot;, (complete) -&gt;
			docpad.initInstall(opts, complete)

		# Update the local docpad and plugin dependencies
		# Grouped together to avoid npm dependency shortcuts that can cause missing dependencies
		# But don&#x27;t update git/http/https dependencies, those are special for some reason
		# &gt; https://github.com/bevry/docpad/pull/701
		dependencies = []
		eachr docpad.websitePackageConfig.dependencies, (version,name) -&gt;
			return  if /^docpad-plugin-/.test(name) is false or /// :// ///.test(version) is true
			dependencies.push(name+&#x27;@&#x27;+docpad.pluginVersion)
		if dependencies.length isnt 0
			tasks.addTask &quot;update plugins that are dependencies&quot;, (complete) -&gt;
				docpad.installNodeModule(&#x27;docpad@6 &#x27;+dependencies, {
					stdio: &#x27;inherit&#x27;
					next: complete
				})

		# Update the plugin dev dependencies
		devDependencies = []
		eachr docpad.websitePackageConfig.devDependencies, (version,name) -&gt;
			return  if /^docpad-plugin-/.test(name) is false
			devDependencies.push(name+&#x27;@&#x27;+docpad.pluginVersion)
		if devDependencies.length isnt 0
			tasks.addTask &quot;update plugins that are dev dependencies&quot;, (complete) -&gt;
				docpad.installNodeModule(devDependencies, {
					save: &#x27;--save-dev&#x27;
					stdio: &#x27;inherit&#x27;
					next: complete
				})

		tasks.addTask &quot;fix node package versions&quot;, (complete) -&gt;
			docpad.fixNodePackageVersions(complete)

		tasks.addTask &quot;re-initialize the rest of the website&#x27;s modules&quot;, (complete) -&gt;
			docpad.initNodeModules({
				stdio: &#x27;inherit&#x27;
				next: complete
			})

		# Run
		tasks.run()

		# Chain
		@

	###*
	# DocPad cleanup tasks.
	# @private
	# @method clean
	# @param {Object} opts
	# @param {Object} next
	# @param {Error} next.err
	# @return {Object} description
	###
	clean: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = docpad.getConfig()
		locale = @getLocale()

		# Log
		docpad.log(&#x27;info&#x27;, locale.renderCleaning)

		# Tasks
		tasks = new @TaskGroup &quot;clean tasks&quot;, {concurrency:0}, next:(err) -&gt;
			# Error?
			return next(err)  if err

			# Log
			docpad.log(&#x27;info&#x27;, locale.renderCleaned)

			# Forward
			return next()

		tasks.addTask &#x27;reset the collecitons&#x27;, (complete) -&gt;
			docpad.resetCollections(opts, complete)

		# Delete out path
		# but only if our outPath is not a parent of our rootPath
		tasks.addTask &#x27;delete out path&#x27;, (complete) -&gt;
			# Check if our outPath is higher than our root path, so do not remove files
			return complete()  if config.rootPath.indexOf(config.outPath) isnt -1

			# Our outPath is not related or lower than our root path, so do remove it
			rimraf(config.outPath, complete)

		# Delete database cache
		tasks.addTask &#x27;delete database cache file&#x27;, (complete) -&gt;
			safefs.unlink(config.databaseCachePath, complete)

		# Run tasks
		tasks.run()

		# Chain
		@



	###*
	# Initialize a Skeleton into to a Directory
	# @private
	# @method initSkeleton
	# @param {Object} skeletonModel
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	initSkeleton: (skeletonModel,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = @getConfig()

		# Defaults
		opts.destinationPath ?= config.rootPath

		# Tasks
		tasks = new @TaskGroup(&quot;initSkeleton tasks&quot;, {next})

		tasks.addTask &quot;ensure the path we are writing to exists&quot;, (complete) -&gt;
			safefs.ensurePath(opts.destinationPath, complete)

		# Clone out the repository if applicable
		if skeletonModel? and skeletonModel.id isnt &#x27;none&#x27;
			tasks.addTask &quot;clone out the git repo&quot;, (complete) -&gt;
				docpad.initGitRepo({
					cwd: opts.destinationPath
					url: skeletonModel.get(&#x27;repo&#x27;)
					branch: skeletonModel.get(&#x27;branch&#x27;)
					remote: &#x27;skeleton&#x27;
					stdio: &#x27;inherit&#x27;
					next: complete
				})
		else
			tasks.addTask &quot;ensure src path exists&quot;, (complete) -&gt;
				safefs.ensurePath(config.srcPath, complete)

			tasks.addGroup &quot;initialize the website directory files&quot;, -&gt;
				@setConfig(concurrency:0)

				# README
				@addTask &quot;README.md&quot;, (complete) -&gt;
					# Exists?
					path = pathUtil.join(config.rootPath, &#x27;README.md&#x27;)
					safefs.exists path, (exists) -&gt;
						# Check
						return complete()  if exists

						# Write
						data = &quot;&quot;&quot;
							# Your [DocPad](http://docpad.org) Project

							## License
							Copyright &amp;copy; #{(new Date()).getFullYear()}+ All rights reserved.
							&quot;&quot;&quot;
						safefs.writeFile(path, data, complete)

				# Config
				@addTask &quot;docpad.coffee configuration file&quot;, (complete) -&gt;
					# Exists?
					docpad.getConfigPath (err,path) -&gt;
						# Check
						return complete(err)  if err or path
						path = pathUtil.join(config.rootPath, &#x27;docpad.coffee&#x27;)

						# Write
						data = &quot;&quot;&quot;
							# DocPad Configuration File
							# http://docpad.org/docs/config

							# Define the DocPad Configuration
							docpadConfig = {
								# ...
							}

							# Export the DocPad Configuration
							module.exports = docpadConfig
							&quot;&quot;&quot;
						safefs.writeFile(path, data, complete)

				# Documents
				@addTask &quot;documents directory&quot;, (complete) -&gt;
					safefs.ensurePath(config.documentsPaths[0], complete)

				# Layouts
				@addTask &quot;layouts directory&quot;, (complete) -&gt;
					safefs.ensurePath(config.layoutsPaths[0], complete)

				# Files
				@addTask &quot;files directory&quot;, (complete) -&gt;
					safefs.ensurePath(config.filesPaths[0], complete)

		# Run
		tasks.run()

		# Chain
		@

	###*
	# Install a Skeleton into a Directory
	# @private
	# @method installSkeleton
	# @param {Object} skeletonModel
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	installSkeleton: (skeletonModel,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @

		# Defaults
		opts.destinationPath ?= @getConfig().rootPath

		# Initialize and install the skeleton
		docpad.initSkeleton skeletonModel, opts, (err) -&gt;
			# Check
			return next(err)  if err

			# Forward
			docpad.install(opts, next)

		# Chain
		@

	###*
	# Use a Skeleton
	# @private
	# @method useSkeleton
	# @param {Object} skeletonModel
	# @param {Object} opts
	# @param {Object} next
	# @param {Error} next.err
	# @return {Object} description
	###
	useSkeleton: (skeletonModel,opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		locale = @getLocale()

		# Defaults
		opts.destinationPath ?= @getConfig().rootPath

		# Extract
		skeletonId = skeletonModel?.id or &#x27;none&#x27;
		skeletonName = skeletonModel?.get(&#x27;name&#x27;) or locale.skeletonNoneName

		# Track
		docpad.track(&#x27;skeleton-use&#x27;, {skeletonId})

		# Log
		docpad.log(&#x27;info&#x27;, util.format(locale.skeletonInstall, skeletonName, opts.destinationPath)+&#x27; &#x27;+locale.pleaseWait)

		# Install Skeleton
		docpad.installSkeleton skeletonModel, opts, (err) -&gt;
			# Error?
			return next(err)  if err

			# Log
			docpad.log(&#x27;info&#x27;, locale.skeletonInstalled)

			# Forward
			return next(err)

		# Chain
		@


	###*
	# Select a Skeleton
	# @private
	# @method selectSkeleton
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	# @param {Error} next.skeletonModel
	###
	selectSkeleton: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		opts.selectSkeletonCallback ?= null

		# Track
		docpad.track(&#x27;skeleton-ask&#x27;)

		# Get the available skeletons
		docpad.getSkeletons (err,skeletonsCollection) -&gt;
			# Check
			return next(err)  if err

			# Provide selection to the interface
			opts.selectSkeletonCallback(skeletonsCollection, next)

		# Chain
		@

	###*
	# Skeleton Empty?
	# @private
	# @method skeletonEmpty
	# @param {Object} path
	# @param {Function} next
	# @param {Error} next.err
	###
	skeletonEmpty: (path, next) -&gt;
		# Prepare
		locale = @getLocale()

		# Defaults
		path ?= @getConfig().rootPath

		# Check the destination path is empty
		safefs.exists pathUtil.join(path, &#x27;package.json&#x27;), (exists) -&gt;
			# Check
			if exists
				err = new Error(locale.skeletonExists)
				return next(err)

			# Success
			return next()

		# Chain
		@

	###*
	# Initialize the project directory
	# with the basic skeleton.
	# @private
	# @method skeleton
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	skeleton: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		opts.selectSkeletonCallback ?= null

		# Init the directory with the basic skeleton
		@skeletonEmpty null, (err) -&gt;
			# Check
			return next(err)  if err

			# Select Skeleton
			docpad.selectSkeleton opts, (err,skeletonModel) -&gt;
				# Check
				return next(err)  if err

				# Use Skeleton
				docpad.useSkeleton(skeletonModel, next)

		# Chain
		@

	###*
	# Initialize the project directory
	# with the basic skeleton.
	# @private
	# @method init
	# @param {Object} opts
	# @param {Object} next
	# @param {Error} next.err
	# @return {Object} description
	###
	init: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @

		# Init the directory with the basic skeleton
		@skeletonEmpty null, (err) -&gt;
			# Check
			return next(err)  if err

			# Basic Skeleton
			docpad.useSkeleton(null, next)

		# Chain
		@


	# ---------------------------------
	# Server

	###*
	# Serve a document
	# @private
	# @method serveDocument
	# @param {Object} opts
	# @param {Function} next
	# @param {Error} next.err
	###
	serveDocument: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		{document,err,req,res} = opts
		docpad = @
		config = @getConfig()

		# If no document, then exit early
		unless document
			if opts.statusCode?
				return res.send(opts.statusCode)
			else
				return next()

		# Prepare
		res.setHeaderIfMissing ?= (name, value) -&gt;
			res.setHeader(name, value)  unless res.getHeader(name)

		# Content Type + Encoding/Charset
		encoding = document.get(&#x27;encoding&#x27;)
		charset = &#x27;utf-8&#x27;  if encoding in [&#x27;utf8&#x27;, &#x27;utf-8&#x27;]
		contentType = document.get(&#x27;outContentType&#x27;) or document.get(&#x27;contentType&#x27;)
		res.setHeaderIfMissing(&#x27;Content-Type&#x27;, contentType + (if charset then &quot;; charset=#{charset}&quot; else &#x27;&#x27;))

		# Cache-Control (max-age)
		res.setHeaderIfMissing(&#x27;Cache-Control&#x27;, &quot;public, max-age=#{config.maxAge}&quot;)  if config.maxAge

		# Send
		dynamic = document.get(&#x27;dynamic&#x27;)
		if dynamic
			# If you are debugging why a dynamic document isn&#x27;t rendering
			# it could be that you don&#x27;t have cleanurls installed
			# e.g. if index.html is dynamic, and you are accessing it via /
			# then this code will not be reached, as we don&#x27;t register that url
			# where if we have the cleanurls plugin installed, then do register that url
			# against the document, so this is reached
			collection = new FilesCollection([document], {name:&#x27;dynamic collection&#x27;})
			templateData = extendr.extend({}, req.templateData or {}, {req,err})
			docpad.action &#x27;generate&#x27;, {collection, templateData}, (err) -&gt;
				content = document.getOutContent()
				if err
					docpad.error(err)
					return next(err)
				else
					if opts.statusCode?
						return res.send(opts.statusCode, content)
					else
						return res.send(content)

		else
			# ETag: &#x60;&quot;&lt;size&gt;-&lt;mtime&gt;&quot;&#x60;
			ctime = document.get(&#x27;date&#x27;)    # use the date or mtime, it should always exist
			mtime = document.get(&#x27;wtime&#x27;)   # use the last generate time, it may not exist though
			stat = document.getStat()
			etag = stat.size + &#x27;-&#x27; + Number(mtime)   if mtime and stat
			res.setHeaderIfMissing(&#x27;ETag&#x27;, &#x27;&quot;&#x27; + etag + &#x27;&quot;&#x27;)  if etag

			# Date
			res.setHeaderIfMissing(&#x27;Date&#x27;, ctime.toUTCString())  if ctime?.toUTCString?
			res.setHeaderIfMissing(&#x27;Last-Modified&#x27;, mtime.toUTCString())  if mtime?.toUTCString?
			# @TODO:
			# The above .toUTCString? check is a workaround because sometimes the date object
			# isn&#x27;t really a date object, this needs to be fixed properly
			# https://github.com/bevry/docpad/pull/781

			# Send
			if etag and etag is (req.get(&#x27;If-None-Match&#x27;) or &#x27;&#x27;).replace(/^&quot;|&quot;$/g, &#x27;&#x27;)
				res.send(304)  # not modified
			else
				content = document.getOutContent()
				if content
					if opts.statusCode?
						res.send(opts.statusCode, content)
					else
						res.send(content)
				else
					if opts.statusCode?
						res.send(opts.statusCode)
					else
						next()

		# Chain
		@


	###*
	# Server Middleware: Header
	# @private
	# @method serverMiddlewareHeader
	# @param {Object} req
	# @param {Object} res
	# @param {Object} next
	###
	serverMiddlewareHeader: (req,res,next) -&gt;
		# Prepare
		docpad = @

		# Handle
		# Always enable this until we get a complaint about not having it
		# For instance, Express.js also forces this
		tools = res.get(&#x27;X-Powered-By&#x27;).split(/[,\s]+/g)
		tools.push(&quot;DocPad v#{docpad.getVersion()}&quot;)
		tools = tools.join(&#x27;, &#x27;)
		res.set(&#x27;X-Powered-By&#x27;, tools)

		# Forward
		next()

		# Chain
		@


	###*
	# Server Middleware: Router
	# @private
	# @method serverMiddlewareRouter
	# @param {Object} req
	# @param {Object} res
	# @param {Function} next
	# @param {Error} next.err
	###
	serverMiddlewareRouter: (req,res,next) -&gt;
		# Prepare
		docpad = @

		# Get the file
		docpad.getFileByRoute req.url, (err,file) -&gt;
			# Check
			return next(err)  if err or file? is false

			# Check if we are the desired url
			# if we aren&#x27;t do a permanent redirect
			url = file.get(&#x27;url&#x27;)
			cleanUrl = docpad.getUrlPathname(req.url)
			if (url isnt cleanUrl) and (url isnt req.url)
				return res.redirect(301, url)

			# Serve the file to the user
			docpad.serveDocument({document:file, req, res, next})

		# Chain
		@


	###*
	# Server Middleware: 404
	# @private
	# @method serverMiddleware404
	# @param {Object} req
	# @param {Object} res
	# @param {Object} next
	###
	serverMiddleware404: (req,res,next) -&gt;
		# Prepare
		docpad = @
		database = docpad.getDatabaseSafe()

		# Notify the user of a 404
		docpad.log(&#x27;notice&#x27;, &quot;404 Not Found:&quot;, req.url)

		# Check
		return res.send(500)  unless database

		# Serve the document to the user
		document = database.findOne({relativeOutPath: &#x27;404.html&#x27;})
		docpad.serveDocument({document, req, res, next, statusCode:404})

		# Chain
		@


	###*
	# Server Middleware: 500
	# @private
	# @method serverMiddleware500
	# @param {Object} err
	# @param {Object} req
	# @param {Object} res
	# @param {Function} next
	###
	serverMiddleware500: (err,req,res,next) -&gt;
		# Prepare
		docpad = @
		database = docpad.getDatabaseSafe()

		# Check
		return res.send(500)  unless database

		# Serve the document to the user
		document = database.findOne({relativeOutPath: &#x27;500.html&#x27;})
		docpad.serveDocument({document,err,req,res,next,statusCode:500})

		# Chain
		@

	###*
	# Configure and start up the DocPad web server.
	# Http and express server is created, extended with
	# middleware, started up and begins listening.
	# The events serverBefore, serverExtend and
	# serverAfter emitted here.
	# @private
	# @method server
	# @param {Object} opts
	# @param {Function} next
	###
	server: (opts,next) -&gt;
		# Prepare
		[opts,next] = extractOptsAndCallback(opts,next)
		docpad = @
		config = @config
		locale = @getLocale()
		port = @getPort()
		hostname = @getHostname()

		# Require
		http = require(&#x27;http&#x27;)
		express = require(&#x27;express&#x27;)

		# Config
		servers = @getServer(true)
		opts.serverExpress ?= servers.serverExpress
		opts.serverHttp ?= servers.serverHttp
		opts.middlewareBodyParser ?= config.middlewareBodyParser ? config.middlewareStandard
		opts.middlewareMethodOverride ?= config.middlewareMethodOverride ? config.middlewareStandard
		opts.middlewareExpressRouter ?= config.middlewareExpressRouter ? config.middlewareStandard
		opts.middleware404 ?= config.middleware404
		opts.middleware500 ?= config.middleware500
		# @TODO: Why do we do opts here instead of config???

		# Tasks
		tasks = new @TaskGroup(&quot;server tasks&quot;, {next})

		# Before Plugin Event
		tasks.addTask &quot;emit serverBefore&quot;, (complete) -&gt;
			docpad.emitSerial(&#x27;serverBefore&#x27;, complete)

		# Create server when none is defined
		if !opts.serverExpress or !opts.serverHttp
			tasks.addTask &quot;create server&quot;, -&gt;
				opts.serverExpress or= express()
				opts.serverHttp or= http.createServer(opts.serverExpress)
				docpad.setServer(opts)

		# Extend the server with our middlewares
		if config.extendServer is true
			tasks.addTask &quot;extend the server&quot;, (complete) -&gt;
				# Parse url-encoded and json encoded form data
				if opts.middlewareBodyParser isnt false
					opts.serverExpress.use(express.urlencoded())
					opts.serverExpress.use(express.json())

				# Allow over-riding of the request type (e.g. GET, POST, PUT, DELETE)
				if opts.middlewareMethodOverride isnt false
					if typeChecker.isString(opts.middlewareMethodOverride)
						opts.serverExpress.use(require(&#x27;method-override&#x27;)(opts.middlewareMethodOverride))
					else
						opts.serverExpress.use(require(&#x27;method-override&#x27;)())

				# Emit the serverExtend event
				# So plugins can define their routes earlier than the DocPad routes
				docpad.emitSerial &#x27;serverExtend&#x27;, {
					server: opts.serverExpress # b/c
					express: opts.serverExpress # b/c
					serverHttp: opts.serverHttp
					serverExpress: opts.serverExpress
				}, (err) -&gt;
					return next(err)  if err

					# DocPad Header Middleware
					# Keep it after the serverExtend event
					opts.serverExpress.use(docpad.serverMiddlewareHeader)

					# Router Middleware
					# Keep it after the serverExtend event
					opts.serverExpress.use(opts.serverExpress.router)  if opts.middlewareExpressRouter isnt false

					# DocPad Router Middleware
					# Keep it after the serverExtend event
					opts.serverExpress.use(docpad.serverMiddlewareRouter)

					# Static
					# Keep it after the serverExtend event
					if config.maxAge
						opts.serverExpress.use(express.static(config.outPath, {maxAge:config.maxAge}))
					else
						opts.serverExpress.use(express.static(config.outPath))

					# DocPad 404 Middleware
					# Keep it after the serverExtend event
					opts.serverExpress.use(docpad.serverMiddleware404)  if opts.middleware404 isnt false

					# DocPad 500 Middleware
					# Keep it after the serverExtend event
					opts.serverExpress.use(docpad.serverMiddleware500)  if opts.middleware500 isnt false

					# Done
					return complete()

		# Start Server
		tasks.addTask &quot;start the server&quot;, (complete) -&gt;
			# Catch
			opts.serverHttp.once &#x27;error&#x27;, (err) -&gt;
				# Friendlify the error message if it is what we suspect it is
				if err.message.indexOf(&#x27;EADDRINUSE&#x27;) isnt -1
					err = new Error(util.format(locale.serverInUse, port))

				# Done
				return complete(err)

			# Listen
			docpad.log &#x27;debug&#x27;, util.format(locale.serverStart, hostname, port)
			opts.serverHttp.listen port, hostname,  -&gt;
				# Log
				address = opts.serverHttp.address()
				serverUrl = docpad.getServerUrl(
					hostname: address.hostname
					port: address.port
				)
				simpleServerUrl = docpad.getSimpleServerUrl(
					hostname: address.hostname
					port: address.port
				)
				docpad.log &#x27;info&#x27;, util.format(locale.serverStarted, serverUrl)
				if serverUrl isnt simpleServerUrl
					docpad.log &#x27;info&#x27;, util.format(locale.serverBrowse, simpleServerUrl)

				# Done
				return complete()

		# After Plugin Event
		tasks.addTask &quot;emit serverAfter&quot;, (complete) -&gt;
			docpad.emitSerial(&#x27;serverAfter&#x27;, {
				server: opts.serverExpress # b/c
				express: opts.serverExpress # b/c
				serverHttp: opts.serverHttp
				serverExpress: opts.serverExpress
			}, complete)

		# Run the tasks
		tasks.run()

		# Chain
		@


# ---------------------------------
# Export

module.exports = DocPad

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
